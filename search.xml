<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Road 2 NLP- Word Embedding词向量（ELMo）</title>
      <link href="/2019/07/02/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88ELMo%EF%BC%89/"/>
      <url>/2019/07/02/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88ELMo%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-参考资料"><a href="#1-参考资料" class="headerlink" title="1. 参考资料"></a>1. 参考资料</h1><blockquote><ul><li>ELMo论文：<a href="https://github.com/Eajack/NLP-Papers/blob/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/ELMo/%E3%80%8ADeep%20contextualized%20word%20representations%E3%80%8B.pdf" target="_blank" rel="noopener">《Deep contextualized word representations》</a>，作者Matthew et al. ，AllenNLP</li><li>ELMo前论文（ELMo基于该论文模型改进）：<a href="https://github.com/Eajack/NLP-Papers/blob/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/ELMo/Semi-supervised%20sequence%20tagging%20with%20bidirectional%20language%20models.pdf" target="_blank" rel="noopener">《Semi-supervised sequence tagging with bidirectional language models》</a></li><li><a href="https://zhuanlan.zhihu.com/p/51679783" target="_blank" rel="noopener">知乎专栏文《ELMo原理解析及简单上手使用》</a></li></ul></blockquote><h1 id="2-RNN基础：标准RNN-LSTM-GRU"><a href="#2-RNN基础：标准RNN-LSTM-GRU" class="headerlink" title="2. RNN基础：标准RNN/LSTM/GRU"></a>2. RNN基础：标准RNN/LSTM/GRU</h1><p>ELMo基于双向LSTM，因此在此之前先了解下常用RNN结构，顺便了解RNN结构。</p><p><strong>ELMo中的常用RNN结构：LSTM &amp; GRU（均为标准RNN的变体）。</strong></p><h2 id="2-1-标准RNN（Recurrent-Neural-Networks）"><a href="#2-1-标准RNN（Recurrent-Neural-Networks）" class="headerlink" title="2.1 标准RNN（Recurrent Neural Networks）"></a>2.1 标准RNN（Recurrent Neural Networks）</h2><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/ELMo/%E5%9B%BE1.png" alt="图1- 标准RNN"></p><p>如上图，符号说明：$(t)、(t-1)$表示时序，即对应句子分词后词语的词向量；$h_{m×1}$为隐状态；$x_{n×1}$为词向量；$W_{m×n}、U_{m×m}$分别为系数矩阵，初值随机化；$h_{m×1}^{(0)}$初值随机化。<strong>注意，$W_{m×n}、U_{m×m}$矩阵共享，不因时序而不同。</strong></p><p>因此，标准RNN隐状态更新公式为</p><script type="math/tex; mode=display">h_{m×1}^{(t)}=f(W_{m×n}x_{n×1}^{(t)}+U_{m×m}h_{m×1}^{(t-1)}+b_{m×1})</script><p>其中，$f(X)=tanh(X)$。</p><p>标准RNN存在梯度消失问题。单个RNN cell的参数量：$mn+mm+m$，包括$W_{m×n}、U_{m×m}、b_{m×1}$；$h_{m×1}$是生成的，不算入参数。</p><h2 id="2-2-LSTM（Long-Short-Term-Memory）"><a href="#2-2-LSTM（Long-Short-Term-Memory）" class="headerlink" title="2.2 LSTM（Long Short-Term Memory）"></a>2.2 LSTM（Long Short-Term Memory）</h2><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/ELMo/%E5%9B%BE2.png" alt="图2- LSTM"></p><p>LSTM（Long Short-Term Memory），属于标准RNN变体，当前时刻状态可受前面几个时刻的影响。公式如下：</p><script type="math/tex; mode=display">输入门input：i_{m×1}^{(t)}=\sigma(W_{m×n}^{i}x_{n×1}^{(t)}+U_{m×m}^{i}h_{m×1}^{(t-1)}+b_{m×1}^{i})\\遗忘门forget：f_{m×1}^{(t)}=\sigma(W_{m×n}^{f}x_{n×1}^{(t)}+U_{m×m}^{f}h_{m×1}^{(t-1)}+b_{m×1}^{f})\\输出门output：o_{m×1}^{(t)}=\sigma(W_{m×n}^{o}x_{n×1}^{(t)}+U_{m×m}^{o}h_{m×1}^{(t-1)}+b_{m×1}^{o})\\普通门gate：g_{m×1}^{(t)}=tanh(W_{m×n}^{g}x_{n×1}^{(t)}+U_{m×m}^{g}h_{m×1}^{(t-1)}+b_{m×1}^{g})\\cell状态c：c_{m×1}^{(t)}=f_{m×1}^{(t)} \cdot c_{m×1}^{(t-1)}+i_{m×1}^{(t)} \cdot g_{m×1}^{(t)}\\隐状态h：h_{m×1}^{t}=o_{m×1}^{(t)} \cdot tanh(c_{m×1}^{(t)})\\</script><p><strong>PS：注意上述式子中c、h的乘法均为，按对应位的元素相乘，即$a_{m×1} \cdot b_{m×1} = c_{m×1}$。</strong>其中，$\sigma(x)= \frac{1}{1+e^{-x}}$，是sigmoid函数，此处为按点求$\sigma(x)$。</p><p>单个LSTM cell的参数量：$4(mn+mm+m)$，包括4组$W_{m×n}、U_{m×m}、b_{m×1}$。符号说明和标准RNN一致。</p><h2 id="2-3-GRU（Gated-Recurrent-Unit）"><a href="#2-3-GRU（Gated-Recurrent-Unit）" class="headerlink" title="2.3 GRU（Gated Recurrent Unit）"></a>2.3 GRU（Gated Recurrent Unit）</h2><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/ELMo/%E5%9B%BE3.png" alt="图3- GRU"></p><script type="math/tex; mode=display">重置门reset：r_{m×1}^{(t)}=\sigma(W_{m×n}^{r}x_{n×1}^{(t)}+U_{m×m}^{r}h_{m×1}^{(t-1)}+b_{m×1}^{r})\\更新门update：z_{m×1}^{(t)}=\sigma(W_{m×n}^{z}x_{n×1}^{(t)}+U_{m×m}^{z}h_{m×1}^{(t-1)}+b_{m×1}^{z})\\隐状态h：h_{m×1}^{(t)}=(1-z_{m×1}^{(t)}) \cdot h_{m×1}^{(t-1)}+z_{m×1}^{(t)} \cdot tanh(U_{m×m}^{h} \cdot (r_{m×1}^{(t)} \cdot h_{m×1}^{(t-1)})+W_{m×n}^{h} \cdot x_{n×1}^{(t)})</script><p>可以看出，GRU其实是LSTM变体，简单版LSTM。符号说明和标准RNN一致。</p><h2 id="3-ELMo（Embeddings-from-Language-Models）"><a href="#3-ELMo（Embeddings-from-Language-Models）" class="headerlink" title="3. ELMo（Embeddings from Language Models）"></a>3. ELMo（Embeddings from Language Models）</h2><p>ELMo框架如下（LSTM可换GRU）：</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/ELMo/%E5%9B%BE4.png" alt="图5- ELMo"></p><p>ELMo包含1个biLM（Bidirectional Language Models，即双向语言模型），分别是前向预测和后向预测。</p><script type="math/tex; mode=display">前向LM：p\left(t_{1}, t_{2}, \ldots, t_{N}\right)=\prod_{k=1}^{N} p\left(t_{k} | t_{1}, t_{2}, \ldots, t_{k-1}\right)\\后向LM：p\left(t_{1}, t_{2}, \ldots, t_{N}\right)=\prod_{k=1}^{N} p\left(t_{k} | t_{k+1}, t_{k+2}, \ldots, t_{N}\right)\\biLM：\sum_{k=1}^{N}\left(\log p\left(t_{k} | t_{1}, \ldots, t_{k-1} ; \Theta_{x}, \vec{\Theta}_{L S T M}, \Theta_{s}\right)\right.+\log p\left(t_{k} | t_{k+1}, \ldots, t_{N} ; \Theta_{x}, \Theta_{L S T M}, \Theta_{s}\right) )</script><p>即ELMo目标函数为biLM对数似然函数。</p><p>观察ELMo网络可知，以上图2层LSTM为例。分析如下：</p><ol><li><p><strong>注意：底层$E_{i}(i=1,2,…)$输入，为句子分词后对应位置单词的静态词向量，常用Word2vec/GloVe等。词向量维度为n</strong></p></li><li><p>记下层为层1，上层为层2。</p></li><li><strong>注意：1层LSTM包括前向LM &amp; 后向LM，且二者cell数目一致，等于词语数目。设词语数为A，则1层LSTM cell数目 = 2*A。</strong></li><li>以上图第二个词语，即$E_{2}$处，的前向LM为例，有上图所示。<strong>观察可以发现，其实在层2的下侧输入中，标准LSTM输入应该为$x_{n×1}$，即n维向量。然而！又由于LSTM隐状态输出为$h_{m×1}$,即m维向量！！因此，不难推断出，biLM中，其实是取m = n了！！</strong></li><li>如何获得ELMo词向量：</li></ol><ul><li><p>loss function为biLM对数似然函数，常规用SGD等算法优化更新参数；</p></li><li><p>ELMo词向量获取方法有多种：</p><ul><li><p>(1) 只取顶层LSTM的输出隐状态h向量（该例子即为层2）</p><p>以该例子（2层LSTM）中单词$E_{2}$为例，其对应ELMo词向量为</p></li></ul><script type="math/tex; mode=display">ELMo\_E2\_method1 = concat(x_{2},h_{m×1}^{(2,2)}) = concat(x_{2},T_{2})</script><p><strong>即将该单词原输入词向量$x_{2}$和对应LSTM cell输出隐状态$T_{2}$，直接拼接。由于m = n，则ELMo词向量维度为2m。</strong>e.g.，取Word2vec维度为300输入，则ELMo输出为600维度词向量。</p><ul><li><p>(2) 取所有层的LSTM的输出隐状态h向量（<strong>层数设为L</strong>）</p><p>在这方法中，又有2种思路：<strong>1- 直接concat；2- 带系数求和后concat</strong></p><p>1- 直接concat</p><p>同上，以该例子（2层LSTM）中单词$E_{2}$为例，此思路的对应ELMo词向量为：</p><script type="math/tex; mode=display">ELMo\_E2\_method2 = concat(x_{2},h_{m×1}^{(1,2)},h_{m×1}^{(2,2)})\\= concat(x_{2},h_{m×1}^{(1,2)},T_{2})</script><p><strong>和方法1相比，方法2也就只是concat多1层h向量。然而，在这例子是多1层，当层数很大时，例如100，则是concat多99层。</strong></p><p><strong>该方法下ELMo词向量维度和LSTM层数有关，为m(L+1)维度</strong></p><p>即下图的右侧图，左侧不用管。来源：《Semi-supervised sequence tagging with bidirectional language models》</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/ELMo/%E5%9B%BE5.PNG" alt="图5- ELMo1"></p></li></ul></li></ul><pre><code>2- 带系数求和后concat同上，有该思路下,单词$E_{2}$ELMo词向量：$$ELMo_{E2}=γ\sum_{j=0}^{L}{s^{(j,2)} \cdot h_{m×1}^{(j,2)}} \\ELMo\_E2\_method3 = concat(x_{2},ELMo_{E2})$$该思路关键如下：给每一层LSTM一个系数向量$s_{2A×1}$，按位置和该层的2A个$h$向量相乘后，所有层求和。最后再乘上系数γ，作为向量$ELMO_{E}$。**注意：$ELMO_{E}$维度为m**。然后，将原输入静态词向量$x$和$ELMO_{E}$concat。**该方法下ELMo词向量维度，为2m维度**</code></pre><p>  <strong>论文采取方式：方法3，带系数求和后concat。</strong>即</p><script type="math/tex; mode=display">ELMo_{E2}=γ\sum_{j=0}^{L}{s^{(j,2)} \cdot h_{m×1}^{(j,2)}} \\ELMo\_E2\_method3 = concat(x_{2},ELMo_{E2})</script><p>其实方法2也可以，直接concat所有层h，但可能维度过高了。</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> ELMo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Road 2 NLP- Word Embedding词向量（FastText）</title>
      <link href="/2019/07/01/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88FastText%EF%BC%89/"/>
      <url>/2019/07/01/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88FastText%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-参考资料"><a href="#1-参考资料" class="headerlink" title="1. 参考资料"></a>1. 参考资料</h1><blockquote><ul><li>论文1：FastText1词向量，<a href="https://github.com/Eajack/NLP-Papers/blob/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/FastText/Enriching%20Word%20Vectors%20with%20Subword%20Information.pdf" target="_blank" rel="noopener">《Enriching Word Vectors with Subword Information》</a>，作者Bojanowski et al. （包括Mikolov），FAIR（Facebook AI Research）</li><li>论文2：FastText2文本分类模型，<a href="https://github.com/Eajack/NLP-Papers/blob/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/FastText/Bag%20of%20Tricks%20for%20Efficient%20Text%20Classification.pdf" target="_blank" rel="noopener">《Bag of Tricks for Efficient Text Classification》</a>，作者Joulin et al. （包括Mikolov），FAIR（Facebook AI Research）</li><li>博客文：<a href="https://heleifz.github.io/14732610572844.html" target="_blank" rel="noopener">《fastText 源码分析》</a></li><li><a href="https://github.com/facebookresearch/fastText/tree/master/src" target="_blank" rel="noopener">FastText源代码（C++）</a></li></ul></blockquote><p>主要参考资料如上，其实还有其他博客文，然而很多博客文都是互相抄袭的……而且很多都是讲解<strong>FastText文本分类模型</strong>，而非<strong>FastText词向量</strong>，前者基于后者建模。FastText文本分类模型原理简单易懂，然而词向量的训练原理有某些地方讲的很含糊。基于以上参考资料，我只能做出个人理解。（因为看源码看了很久，还是感觉没能解决我的核心疑惑……）</p><p>FastText其实是包括2个东西的：</p><ul><li><p>FastText词向量（PS：和Word2vec、GloVe一样，FastText词向量也属于<strong>静态词向量</strong>），对应论文1</p></li><li><p>FastText文本分类模型，对应论文2</p></li></ul><p>虽说本系列文章主题是：<strong>Word Embedding词向量</strong>，但是由于FastText特殊性，这里一起讲<strong>FastText文本分类模型</strong>。</p><p>FastText的最大优点：快速。</p><pre><code>《Efficient estimation of word representations in vector space》摘要部分：We can train fastText on more than one billion words in less than ten minutes using a standard multicore CPU, and classify half a million sentences among 312K classes in less than a minute.</code></pre><h1 id="2-FastText原理1：词向量训练"><a href="#2-FastText原理1：词向量训练" class="headerlink" title="2. FastText原理1：词向量训练"></a>2. FastText原理1：词向量训练</h1><p>关于FastText词向量资料，原论文<a href="https://github.com/Eajack/NLP-Papers/blob/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/FastText/Enriching%20Word%20Vectors%20with%20Subword%20Information.pdf" target="_blank" rel="noopener">《Enriching Word Vectors with Subword Information》</a>的原理部分提及得相当简略。</p><p>FastText词向量框架是基于Word2vec框架的，区别主要如下：</p><p>前者利用n-grams向量之和作为词向量（<strong>key point &amp; 疑惑点</strong>）</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/FastText/%E5%9B%BE1.PNG" alt="图1- FastText词向量表示"></p><p>即单词w对应1个n-grams集合（原论文为提取3-grams ~ 6-grams的所有子串），每个字串会有对应的向量，因此该单词w的词向量 = 所有n-grams字串向量求和。</p><p>关于n-grams，原论文有以下例子：</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/FastText/%E5%9B%BE2.PNG" alt="图2- n-grams"></p><p>这里，以<code>where</code>为例，其对应的3-grams子串集合<code>G={&quot;&lt;wh&quot;,&quot;whe&quot;,&quot;her&quot;,&quot;ere&quot;,&quot;re&gt;&quot;,&quot;&lt;where&gt;&quot;}</code>，其中每一个子串对应1个向量表示，则<code>where</code>词向量则为求和。同理对于中文，举例<code>苏格拉底</code>的3-grams子串集合<code>G_1={&quot;&lt;苏格&quot;,&quot;苏格拉&quot;,&quot;格拉底&quot;,&quot;拉底&gt;,&quot;&lt;苏格拉底&gt;&quot;}</code>。</p><p>以上原理都不难理解，关键在于：<strong>原论文貌似没给出子串向量是如何获得！</strong>当然n-grams向量理应是训练得到，然而如何训练，网络结构如何，原论文没提及，只是说基于Word2vec架构。Word2vec原理如下文：</p><p><a href="https://eajack.github.io/2019/06/21/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88Word2vec%EF%BC%89/">Road 2 NLP- Word Embedding词向量（Word2vec）</a></p><p>本人一直卡在<strong>如何训练n-grams子串向量</strong>这问题上。涉及资料主要是：博客文<a href="https://heleifz.github.io/14732610572844.html" target="_blank" rel="noopener">《fastText 源码分析》</a>、<a href="https://github.com/facebookresearch/fastText/tree/master/src" target="_blank" rel="noopener">FastText源代码（C++）</a>。经过多次分析猜测（由于本人最后还是放弃通读C++源码…我看了挺久，但还是不知道如何训练n-grams子串获得向量的，只发现了<strong>如何获取子串string</strong>代码）。</p><p><strong>FastText默认Skip-Gram模型，对比Word2vec的Skip-Gram模型，有以下个人理解</strong>（由于画图较为复杂，此处文字描述）：</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/Word2vec/%E5%9B%BE3.PNG" alt="图3- Skip-Gram"></p><p>如上图为Word2vec原Skip-Gram模型。</p><ul><li>输入层：输入为当前单词w的n-grams的index集合，从输入向量矩阵$W_{V×N}$中挑出对应n-grams向量求和，作为输入层的$x_{k}$。<strong>因此，FastText的输入层和Word2vec的区别在于：前者取n-gram求和作为词向量，后者取One-Hot词向量；前者输入向量矩阵$W_{V×N}$，其N为所有语料的n-grams总数，后者则为语料word总数。</strong></li><li>隐含层&amp;输出层：Word2vec &amp; FastText一致。</li></ul><p>因此，FastText词向量训练框架 &amp; Word2vec不一致仅在于输入层。（PS：个人理解）</p><h1 id="3-FastText原理2：文本分类模型"><a href="#3-FastText原理2：文本分类模型" class="headerlink" title="3. FastText原理2：文本分类模型"></a>3. FastText原理2：文本分类模型</h1><p>FastText文本分类模型和词向量训练框架差不多，有了词向量的原理基础，该模型可以很简单地用下图总结：</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/FastText/%E5%9B%BE3.PNG" alt="图4- FastText文本分类模型"></p><p>如上图，FastText文本分类模型仅3层。</p><ul><li>输入层：句子的n-grams表示向量（<strong>PS：此处的n-grams向量为经过FastText词向量训练获得</strong>）</li><li>隐藏层：n-grams向量求平均（<strong>PS：FastText词向量训练则是求和</strong>）</li><li>输出层：softmax层（<strong>PS：沿用Word2vec的Hierarchical Softmax</strong>）</li></ul><p>由此可以看出，关键是输入层的<strong>n-grams向量</strong>，而这个便是FastText词向量训练步骤。所以，FastText文本分类模型包括2步：<strong>1- FastText词向量训练；2- FastText文本分类模型构建</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FastText </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Road 2 NLP- Word Embedding词向量（GloVe）</title>
      <link href="/2019/06/22/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88GloVe%EF%BC%89/"/>
      <url>/2019/06/22/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88GloVe%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>参考资料</strong></p><blockquote><ul><li>GloVe开山之作：《GloVe: Global Vectors for Word Representation》，作者Jeffrey Pennington（Stanford NLP）</li><li>CSDN博客文章：<a href="https://blog.csdn.net/u014665013/article/details/79642083" target="_blank" rel="noopener">理解GloVe模型（+总结）</a></li></ul></blockquote><p>个人觉得这篇文章：<a href="https://blog.csdn.net/u014665013/article/details/79642083" target="_blank" rel="noopener">理解GloVe模型（+总结）</a>，已经讲的很好了…我直接看这文章弄懂了GloVe原理的。有了上一篇Word2vec基础，GloVe原理不是很难：</p><p><a href="https://eajack.github.io/2019/06/21/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88Word2vec%EF%BC%89/">Road 2 NLP- Word Embedding词向量（Word2vec）</a></p><p>按照GloVe原文可知，GloVe综合2类Word Representation模型优点：</p><pre><code>The two main model families for learning word vectors are: 1) global matrix factorization methods,such as latent semantic analysis (LSA) (Deerwester et al., 1990) and 2) local context window methods, such as the skip-gram model of Mikolov et al. (2013c).GloVe = global matrix factorization methods + local context window methods</code></pre>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> GloVe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog建站日志</title>
      <link href="/2019/06/21/blog%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/"/>
      <url>/2019/06/21/blog%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>该个人blog powered by Hexo &amp; github pages，在建blog时涉及到的资料有以下几个：</p><blockquote><ul><li><a href="http://opiece.me/2015/04/09/hexo-guide/" target="_blank" rel="noopener">使用Hexo搭建个人博客(基于hexo3.0)</a></li><li>参考风格源于<a href="http://flygon.net/" target="_blank" rel="noopener">龙哥盟</a></li><li><a href="https://github.com/wizardforcel/blog" target="_blank" rel="noopener">龙哥盟blog</a>的github开源地址</li><li>Hexo的<a href="https://github.com/wizardforcel/hexo-theme-cyanstyle" target="_blank" rel="noopener">cyanstyle</a>风格github源码</li><li><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></li></ul></blockquote><p><strong>update on 2017/8/19</strong></p><p>关于搭建博客如何备份md的问题，刚好搜到相关资料，可以把source下的markdown文章储存在Github博客同一仓库的其它分支branch上。具体参考资料如下：</p><blockquote><ul><li>博客教程<a href="http://fanzhenyu.me/2017/08/10/Github-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9B%9B%EF%BC%89/#more" target="_blank" rel="noopener">Github Pages + Hexo搭建博客（四）</a></li><li>Github开源库<a href="https://github.com/coneycode/hexo-git-backup" target="_blank" rel="noopener">hexo-git-backup</a></li></ul></blockquote><p><strong>update on 2018/7/28</strong></p><p>终于，blog换了新主题了，之前的老问题也相应的修复了。找了好久，感觉这个<a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="noopener">material主题</a>不错，挺喜欢的。</p><p>以下为本人迁移主题时涉及到的主要资料：</p><blockquote><ul><li>博客教程1<a href="https://zdran.com/20180326.html" target="_blank" rel="noopener">Hexo + Material + Github 搭建博客与配置</a></li><li>博客教程2<a href="https://crowncj.com/20170616.html" target="_blank" rel="noopener">Hexo Material 主题博客搭建以及优化心得</a></li></ul></blockquote><p><strong>update on 2019/6/21</strong></p><p>添加hexo支持Mathjax输入数学公式的功能，TeX公式语法。尽管Typora内置渲染可以显示TeX公式，然而Hexo原生并不行。该教程也是Material主题，因此选了这个教程。</p><blockquote><ul><li>Hexo + Mathjax教程：<a href="https://ranmaosong.github.io/2017/11/29/hexo-support-mathjax" target="_blank" rel="noopener">如何在 hexo 中支持 Mathjax？</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Road 2 NLP- Word Embedding词向量（Word2vec）</title>
      <link href="/2019/06/21/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88Word2vec%EF%BC%89/"/>
      <url>/2019/06/21/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88Word2vec%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-参考资料"><a href="#1-参考资料" class="headerlink" title="1. 参考资料"></a>1. 参考资料</h1><blockquote><ul><li>Word2vec 开山之作1：《Distributed Representations of Sentences and Documents》，作者Mikolov</li><li>Word2vec 开山之作2：《Efficient estimation of word representations in vector space》，作者Mikolov</li><li>Word2vec论文讲解：《word2vec Parameter Learning Explained》,作者Xin Rong</li><li>知乎专栏文：<a href="https://zhuanlan.zhihu.com/p/26306795" target="_blank" rel="noopener">[NLP] 秒懂词向量Word2vec的本质</a></li><li>博客文章：<a href="https://www.cnblogs.com/pinard/p/7249903.html" target="_blank" rel="noopener">word2vec原理(三) 基于Negative Sampling的模型</a></li></ul></blockquote><p>以下为<a href="https://zhuanlan.zhihu.com/p/26306795" target="_blank" rel="noopener">[NLP] 秒懂词向量Word2vec的本质</a> 的推荐资料分析：</p><pre><code>1. Mikolov 两篇原论文：『Distributed Representations of Sentences and Documents』      贡献：在前人基础上提出更精简的语言模型（language model）框架并用于生成词向量，这个框架就是 Word2vec『Efficient estimation of word representations in vector space』      贡献：专门讲训练 Word2vec 中的两个trick：hierarchical softmax 和 negative sampling优点：Word2vec 开山之作，两篇论文均值得一读缺点：只见树木，不见森林和树叶，读完不得要义。      这里『森林』指 word2vec 模型的理论基础——即 以神经网络形式表示的语言模型      『树叶』指具体的神经网络形式、理论推导、hierarchical softmax 的实现细节等等2. 北漂浪子的博客：『深度学习word2vec 笔记之基础篇』优点：非常系统，结合源码剖析，语言平实易懂缺点：太啰嗦，有点抓不住精髓3. Yoav Goldberg 的论文：『word2vec Explained- Deriving Mikolov et al.’s Negative-Sampling Word-Embedding Method』优点：对 negative-sampling 的公式推导非常完备缺点：不够全面，而且都是公式，没有图示，略显干枯4. Xin Rong 的论文：『word2vec Parameter Learning Explained』：！重点推荐！理论完备由浅入深非常好懂，且直击要害，既有 high-level 的 intuition 的解释，也有细节的推导过程一定要看这篇paper！一定要看这篇paper！一定要看这篇paper！5. 来斯惟的博士论文『基于神经网络的词和文档语义向量表示方法研究』以及他的博客（网名：licstar）可以作为更深入全面的扩展阅读，这里不仅仅有 word2vec，而是把词嵌入的所有主流方法通通梳理了一遍6. 几位大牛在知乎的回答：『word2vec 相比之前的 Word Embedding 方法好在什么地方？』刘知远、邱锡鹏、李韶华等知名学者从不同角度发表对 Word2vec 的看法，非常值得一看7. Sebastian 的博客：『On word embeddings - Part 2: Approximating the Softmax』详细讲解了 softmax 的近似方法，Word2vec 的 hierarchical softmax 只是其中一种</code></pre><p><strong>对比上述所有资料，重点看《word2vec Parameter Learning Explained》，并期望基于此文完全弄懂Word2vec原理。</strong></p><h1 id="2-Word2vec原理（《word2vec-Parameter-Learning-Explained》）"><a href="#2-Word2vec原理（《word2vec-Parameter-Learning-Explained》）" class="headerlink" title="2. Word2vec原理（《word2vec Parameter Learning Explained》）"></a>2. Word2vec原理（《word2vec Parameter Learning Explained》）</h1><p><strong>Word2vec = CBOW + Skip-Gram（Hierarchical Softmax &amp; Negative Sampling）</strong></p><p>其中，</p><ul><li>CBOW：上下文词语 预测 中心词</li><li>Skip-Gram：中心词 预测 上下文词语</li></ul><h2 id="2-1-One-Word-Context（CBOW-amp-Skip-Gram一致的最简单情形）"><a href="#2-1-One-Word-Context（CBOW-amp-Skip-Gram一致的最简单情形）" class="headerlink" title="2.1. One-Word Context（CBOW &amp; Skip-Gram一致的最简单情形）"></a>2.1. One-Word Context（CBOW &amp; Skip-Gram一致的最简单情形）</h2><ul><li>问题描述：最简单情形，<strong>input =&gt; 当前词，output =&gt; 下一个词，即输入当前词预测下一个词</strong></li><li>模型框架</li></ul><p>为方便解说，这里不直接引用原论文图，自己重新Visio画。</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/Word2vec/%E5%9B%BE1.png" alt="图1- One-Word-Context"></p><p>(1). Input layer：输入：$X_{V×1} = OneHot(wordNow)$（模型外部输入input1）, 初始化随机矩阵$W_{V×N}$（<strong>PS：$W_{V×N}$第w行的行向量 $V_w$,称作输入向量(input vector)，Size为：1×N，N为词向量维度，V&gt;&gt;N</strong>）。输出：$h_{N×1}=W_{V×N}^{T}X_{V×1}$。</p><p>(2). Hidden layer：输入：Input层输出$h_{N×1}$，初始化随机矩阵 $W^{‘}_{V×N}$（<strong>PS：$W^{‘}_{V×N}$的第w列的列向量 , $V^{‘}_w$称作输出向量(output vector)，Size为：N×1</strong>）。输出：$u_{V×1}=W^{‘T}_{N×V}h_{N×1}$。</p><p>(3). Output layer：输入：Hidden层输出$u$。输出：$y_j = \frac{exp(u_j)}{\sum_{a=1}^{V}exp(u_a)}$（预测输出Y_predict）。实际输出（模型外部输入input2）$YReal=OneHot(wordNext)$。Y_predict &amp; Y_real构造loss function更新权值$W$、$W^{‘}$。</p><p>输入向量矩阵$W$、输出向量矩阵$W^{‘}$，均可作为词语的词向量表示。<strong>但是Word2vec采用输入向量矩阵$W$</strong>。原因：输出向量矩阵$W^{‘}$更新代价大，以下为《word2vec Parameter Learning Explained》原文</p><pre><code>1. 英文原文：Learning the input vectors is cheap; but learning the output vectors is very expensive. From the update equations (22)and (33), we can and that, in order to update v_w , for each training instance, we have to iterate through every word w_j in the vocabulary, compute their net input u_j , probability prediction y_j (or y_{cj} for skip-gram), their prediction error e_j (or EI_j for skip-gram), and finally use their prediction error to update their output vector v^{&#39;}_{j}.Doing such computations for all words for every training instance is very expensive,making it impractical to scale up to large vocabularies or large training corpora. To solve this problem, an intuition is to limit the number of output vectors that must be updated per training instance. One elegant approach to achieving this is hierarchical softmax; another approach is through sampling, which will be discussed in the next section.2. 中文翻译（Google）：学习输入向量很便宜; 但学习输出向量非常昂贵。从更新方程（22）和（33），我们可以和那个为了更新v_w，对于每个训练实例，我们必须遍历词汇表中的每个单词w_j，计算它们的净输入u_j，概率预测y_j（ 或者y_ {cj}用于skip-gram），它们的预测误差e_j（或者用于skip-gram的EI_j），并且最后使用它们的预测误差来更新它们的输出向量v^{&#39;}_{j}。对每个训练实例的所有单词进行此类计算非常昂贵，使扩展到大型词汇表或大型培训语料库变得不切实际。为了解决这个问题，直觉是限制每个训练实例必须更新的输出向量的数量。 实现这一目标的一个优雅方法是分层softmax; 另一种方法是通过抽样，这将在下一节中讨论。</code></pre><p><strong>这段文字有2个结论：（1）训练输入向量更容易；（2）Hierarchical Softmax &amp; Negative Sampling 方法都是用于更新输出向量的。</strong></p><ul><li>模型本质</li></ul><p>通过上面对3层分析，Word2vec模型本质：<strong>训练更新权值矩阵W，即输入向量矩阵，作为词向量表。因为矩阵W尺寸为V×N，则每一行的行向量对应着该位置的词的Word2vec词向量</strong></p><ul><li>模型例子</li></ul><p>词库为：“我”、“喜欢”、“苹果”，对应的One-Hot词向量分别为[1,0,0]、[0,1,0]、[0,0,1]。输入到One-Word-Context CBOW模型，取词向量维度N=2（一般V&gt;&gt;N，此处V=3，作为例子取N=2）经过训练得到W矩阵如下：</p><script type="math/tex; mode=display">W = \begin{bmatrix}0.2 & 0.4\\\\0.6 &0.7\\\\0.8 &0.1\end{bmatrix}</script><p>尺寸为V x N，即3 x 2。因此，“我”的Word2vec词向量为[0.2, 0.4]，“喜欢”的Word2vec词向量为[0.6, 0.7]，“苹果的”Word2vec词向量为[0.8, 0.1]。</p><ul><li>loss function</li></ul><p>Output层的预测输出：$y_j = \frac{exp(u_j)}{\sum_{a=1}^{V}exp(u_a)}$</p><p>联合额外公式：$h_{N×1}=W_{V×N}^{T}X_{V×1}=v_{wI}^{T}$、 <script type="math/tex">u_j=V_w^{'T}h_{N×1}</script> PS：$u_j$为标量，$V_w^{‘T}$尺寸为1×N。</p><p>推导出：</p><script type="math/tex; mode=display">y_j = \frac{exp(V_{w_j}^{'T}v_{wI}^{T})}{\sum_{a=1}^{V}{exp(V_{w_a}^{'T}v_{wI}^{T}})}</script><p>令loss function为最大似然函数：</p><script type="math/tex; mode=display">E=log(y_j)=u_j - log(\sum_{a=1}^{V}exp(u_a))</script><ul><li>模型训练：参数更新（BP/SGD算法）</li></ul><p>PS：此处涉及矩阵求导。。也不是很懂，尽可能去理解。部分公式可能编辑有问题，能理解原意即可。</p><p>(1). $W^{‘}$更新：$u→W^{‘}$(output→hidden)</p><p>$u$：$\frac{\partial E}{\partial u_j}=y_j - t_j := e_j$（y$_j$为实际输出；$t_j=1(j=j^{real})$，$j$为预测输出y位置，$j^{real}$后者则为实际输出；$e_j为$预测error）</p><p>$W^{‘}$：$\frac{\partial E}{\partial w_{ij}}=\frac{\partial E}{\partial u_j} - \frac{\partial u_j}{\partial w_{ij}} := e_j * h_i$</p><p><strong>更新公式</strong>：</p><script type="math/tex; mode=display">w_{ij}^{(new)} = w_{ij}^{(old)}  - η * e_j * h_i</script><script type="math/tex; mode=display">V_{wj}^{'(new)} = V_{wj}^{'(old)}  - η * e_j * h</script><p>$V_{wj}$为$W^{‘}$矩阵的第$j$列的列向量，即输出向量。</p><p>(2). $W$更新：$h→W$(hidden→input)</p><p>$h：\frac{\partial E}{\partial h_i}=\sum_{j=1}^{V}{\frac{\partial E}{\partial u_j}\frac{\partial u_j}{\partial h_i}} =\sum_{j=1}^{V}{e_j * w^{‘}_{ij}}:= Z_i$</p><p>$W：\frac{\partial E}{\partial w_{ki}}=\frac{\partial E}{\partial h_i}\frac{\partial h_i}{\partial w_{ki}}=Z_i*X_k$</p><p>PS：$\frac{\partial E}{\partial W}=X_{V×1}叉乘Z$，叉乘定义：$a 叉乘 b = |a||b|sin(a,b)$。由于$X$仅有唯一位置非0，则$\frac{\partial E}{\partial W}$仅有唯一的一行非零向量，其值为$Z^T$</p><p><strong>更新公式</strong>：</p><script type="math/tex; mode=display">V^{(new)}_{wI}=V^{(old)}_{wI}-η*Z^{T}</script><p>$V_{wI}$为$W$矩阵的第$i$行的行向量，即输入向量。</p><p>至此One-Word-Context所有原理结束，接下来的Multi-Word CBOW &amp; Skip-Gram模型原理和这个差别不大，仅在此基础上修改部分公式。</p><h2 id="2-2-CBOW（Continuous-Bag-of-Word-Model）"><a href="#2-2-CBOW（Continuous-Bag-of-Word-Model）" class="headerlink" title="2.2 CBOW（Continuous Bag-of-Word Model）"></a>2.2 CBOW（Continuous Bag-of-Word Model）</h2><h3 id="2-2-1-Multi-Word-Context"><a href="#2-2-1-Multi-Word-Context" class="headerlink" title="2.2.1 Multi-Word Context"></a>2.2.1 Multi-Word Context</h3><p>Multi-Word的意思是说，多个上下文词语 =&gt; 中心词（当前词）。<strong>CBOW，即为One-Word-Context的Input layer扩展</strong>。此处直接借用文献图</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/Word2vec/%E5%9B%BE2.PNG" alt="图2- CBOW"></p><ul><li>和One-Word-Context的唯一区别：$h=\frac{1}{C}W^{T}(x_{1}+x_{2}+···+x_{C})=\frac{1}{C}(V_{w1}+V_{w2}+···+V_{wC})^{T}$，<strong>即取上下文总共C个词语的One-Hot编码，上下文词数分别为$\frac{2}{C}$，求平均所有Input layer输入</strong>。</li></ul><h2 id="2-3-Skip-Gram"><a href="#2-3-Skip-Gram" class="headerlink" title="2.3 Skip-Gram"></a>2.3 Skip-Gram</h2><p>同CBOW理，<strong>Skip-Gram，即为One-Word-Context的Output layer扩展</strong>。</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/Word2vec/%E5%9B%BE3.PNG" alt="图3- Skip-Gram"></p><ul><li>和One-Word-Context的唯一区别：loss function<script type="math/tex; mode=display">\begin{aligned} E &=-\log p\left(w_{O, 1}, w_{O, 2}, \cdots, w_{O, C} | w_{I}\right) \\ &=-\log \prod_{c=1}^{C} \frac{\exp \left(u_{c, j_{c}}^{*}\right)}{\sum_{j^{\prime}=1}^{V} \exp \left(u_{j^{\prime}}\right)} \\ &=-\sum_{c=1}^{C} u_{j_{c}^{*}}+C \cdot \log \sum_{j^{\prime}=1}^{V} \exp \left(u_{j^{\prime}}\right) \end{aligned}</script></li></ul><h2 id="2-4-Hierarchical-Softmax"><a href="#2-4-Hierarchical-Softmax" class="headerlink" title="2.4 Hierarchical Softmax"></a>2.4 Hierarchical Softmax</h2><p>分层softmax（Hierarchical Softmax）本质是优化版softmax，<strong>即引入Hierarchical Softmax仅是代替原来softmax结构，优化output vector计算复杂度</strong>。</p><ul><li>原softmax：$y_{i}=\frac{exp(x_i)}{\sum_{a=1}^{V}{exp(x_a)}}$，其中$x_i$为输入向量$X_{V×1}$第$i$位数值标量，$y_i$则为对应输出，输出向量$Y_{V×1}$</li></ul><p>可以看出，计算一次$y_i$需要知道所有$x_{i}$值。复杂度为O(V)。</p><ul><li><p>Hierarchical Softmax：引入霍夫曼树，首先依据词频构建霍夫曼树，词语节点都是叶节点。q</p><p>如下图为论文原图</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/Word2vec/%E5%9B%BE4.PNG" alt="图4- Hierarchical Softmax"></p></li></ul><p>在Hierarchical Softmax中，举例如上图，计算词语$w_{2}$对应的softmax近似概率（H-softmax计算近似值）：</p><script type="math/tex; mode=display">y_{i}=P(w_{2}=w_{O})=P(n(w_2,1),left)*P(n(w_2,2),left)*P(n(w_2,3),right)=σ(v^{'T}_{n(w_{2},1)}h)*σ(v^{'T}_{n(w_{2},2)}h)*(1-σ(v^{'T}_{n(w_{2},3)}h))</script><p>其中$v^{‘T}_{n(w_{2},1)}、v^{‘T}_{n(w_{2},2)}、v^{‘T}_{n(w_{2},3)}$分别为3个节点参数，需要训练更新。</p><p>且</p><script type="math/tex; mode=display">\sum_{a=1}^{V}{P(w_{i}=w_{O})}=1</script><p>为表示方便，上图例子公式如下</p><script type="math/tex; mode=display">y_{i}=σ(θ^{'T}_{n(w_{2},1)}h)*σ(θ^{'T}_{n(w_{2},2)}h)*(1-σ(θ^{'T}_{n(w_{2},3)}h))</script><p>其中，$σ(x)$函数为二元逻辑回归函数$y=\frac{1}{1+exp(-X^{T}*θ)}$。</p><p>容易看出，上面计算$y_{i}$公式计算复杂度下降，不再需要计算V步，仅需要$log(V)$步（即$w_2$路径长）。所以Hierarchical Softmax的计算复杂度为$O(log(V))$</p><p><strong>参数更新：</strong></p><script type="math/tex; mode=display">\theta^{(new)}_j = \theta^{(old)}_j – \eta(\sigma({\theta_j}^Th)-t_j)h</script><h2 id="2-5-Negative-Sampling"><a href="#2-5-Negative-Sampling" class="headerlink" title="2.5 Negative Sampling"></a>2.5 Negative Sampling</h2><p>参考博客文章<a href="https://www.cnblogs.com/pinard/p/7249903.html" target="_blank" rel="noopener">word2vec原理(三) 基于Negative Sampling的模型</a>，总结如下。</p><p><strong>Negative Sampling，是代替H-softmax方法的另一种优化计算output vector的方法。</strong>如其名，这方法涉及采样（Sampling）。</p><ul><li><p>大致原理：现有训练样本,包括当前中心词$w$和C个上下文词$Context(w)$（上下文分别$\frac{2}{C}$个词），命名为<strong>正例</strong>。对词库进行负采样（Negative Sampling），得到<strong>非$w$的N个中心词$w_i(i=1,2,···,N)$</strong>，将N个样本$w_i、Context(w)(i=1,2,···,N)$（注意：$Context(w)$没变，只是中心词w变了）一起作为训练样本，命名为<strong>负例</strong>。正例 &amp; 负例 =&gt; loss function。</p></li><li><p>2个问题：如上原理介绍，有2个问题：</p><ul><li>Q1：如何Negative Sampling获得<strong>非$w$的N个中心词$w_i(i=1,2,···,N)$</strong>？</li><li>Q2：如何根据正负样例构造loss function？</li></ul></li><li><p>Q1：Negative Sampling</p><p>词库词语数量为V，引入长度为1的标准线L，将其分为V份，每一小段对应1个词语。Word2vec中，定义每个词语对应的长度为$len(w_{i})=\frac{count(w_{i})^{3/4}}{\sum_{a=1}^{V}{count(w_{i})^{3/4}}}$，且有$\sum_{a=1}^{V}{len(w_i)=1}$。</p><p>采样前，将标准线L等分为M份（M&gt;&gt;V，Word2vec中M取$10^{8}$），因此每个词长可以对应若干个M小份长度。如下图为博客图片：</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/Word2vec/%E5%9B%BE5.PNG" alt="图5- Negative Sampling"></p><p>采样时，随机在M个位置中采样N个$m_{i}$位置，则每一个位置肯定落入对应的1个词语。注意：采样词不要重复且不能和当前中心词$w$一样。</p></li><li><p>Q2：loss function</p><p>定义当前词$w$为$w_{0}$，正例为$[w_{0},Context(w_{0})]$,负例为$[w_{i},Context(w_{i})]（i=1,2,···,N）$。</p><p>根据逻辑函数有正例概率：</p><script type="math/tex; mode=display">P(context(w_0), w_i) = \sigma(x_{w_0}^T\theta^{w_i}) ,y_i=1, i=0</script><p>负例概率：</p><script type="math/tex; mode=display">P(context(w_0), w_i) =1-  \sigma(x_{w_0}^T\theta^{w_i}), y_i = 0, i=1,2,..N</script><p>最大化公式：</p><script type="math/tex; mode=display">\prod_{i=0}^{N}P(context(w_0), w_i) = \sigma(x_{w_0}^T\theta^{w_0})\prod_{i=1}^{N}(1-  \sigma(x_{w_0}^T\theta^{w_i}))</script><p>似然函数：</p><script type="math/tex; mode=display">Q=\prod_{i=0}^{N} \sigma(x_{w_0}^T\theta^{w_i})^{y_i}(1-  \sigma(x_{w_0}^T\theta^{w_i}))^{1-y_i}</script><p>log似然：</p><script type="math/tex; mode=display">L = \sum\limits_{i=0}^{N}y_i log(\sigma(x_{w_0}^T\theta^{w_i})) + (1-y_i) log(1-  \sigma(x_{w_0}^T\theta^{w_i}))</script><p><strong>参数更新：（SGD算法）</strong></p><p>类似前面操作，最终有参数$x_{w_0}, \theta^{w_i},  i=0,1,..N$更新公式。具体参考<a href="https://www.cnblogs.com/pinard/p/7249903.html" target="_blank" rel="noopener">word2vec原理(三) 基于Negative Sampling的模型</a>。</p></li></ul><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><ul><li><p><strong>Word2vec = CBOW + Skip-Gram（Hierarchical Softmax &amp; Negative Sampling）</strong></p><p>其中，CBOW：上下文词语 预测 中心词；Skip-Gram：中心词 预测 上下文词语</p></li><li><p><strong>Word2vec词向量仅是模型副产品，即输入向量矩阵W</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> Word2vec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eajack LeetCode Notes- Day3</title>
      <link href="/2019/06/12/Eajack%20LeetCode%20Notes-%20Day3/"/>
      <url>/2019/06/12/Eajack%20LeetCode%20Notes-%20Day3/</url>
      
        <content type="html"><![CDATA[<p><strong>PS：由于最近leetcode官网访问问题，暂改成leetcode-zh刷题。</strong></p><h2 id="1-题目解答"><a href="#1-题目解答" class="headerlink" title="1. 题目解答"></a>1. 题目解答</h2><h3 id="Q15"><a href="#Q15" class="headerlink" title="Q15"></a>Q15</h3><h4 id="1-题目信息"><a href="#1-题目信息" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：x 的平方根</li><li>编号&amp;难度：[69]，easy</li><li>Tags：binary-search | math</li><li>描述：实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</li><li>例子：</li></ul></blockquote><pre><code>输入: 4输出: 2输入: 8输出: 2说明: 8 的平方根是 2.82842...,      由于返回类型是整数，小数部分将被舍去。</code></pre><h4 id="2-个人Code"><a href="#2-个人Code" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=69 lang=cpp * * [69] Sqrt(x) */class Solution {public:    int mySqrt(int x) {        long low = 0, high = x, mid = x/2;        if(x == 1)        {            return 1;        }        else        {            //binary-search            while(low &lt; high)            {                if( (mid*mid == x) || ((mid*mid &lt; x) &amp;&amp; ((mid+1)*(mid+1) &gt; x)) )                {                    return mid;                }                else if(mid*mid &lt; x)                {                    low = mid;                    mid = (low+high)/2;                }                else                {                    high = mid;                    mid = (low+high)/2;                }            }            return mid;        }        return mid;    }};</code></pre><blockquote><ul><li>思路：二分法求开方，重点在于第一个if判断<code>if( (mid*mid == x) || ((mid*mid &lt; x) &amp;&amp; ((mid+1)*(mid+1) &gt; x)) )</code>。前半段<code>(mid*mid == x)</code>表明，mid刚好为sqrt数；后半段<code>((mid*mid &lt; x) &amp;&amp; ((mid+1)*(mid+1) &gt; x))</code>表明以下情况：</li></ul></blockquote><pre><code>mid = 2;x = 5;mid*mid = 4 &lt; 5;(mid+1)*(mid+1) = 9 &gt;5;5^0.5 =&gt; 2;</code></pre><h4 id="3-best-solution"><a href="#3-best-solution" class="headerlink" title="(3) best solution"></a>(3) best solution</h4><pre><code class="lang-cpp">//Newton method// holy shit, so short!/*任说1个整数x，我任猜它的平方根为y，如果不对或精度不够准确，那我令y = (y+x/y)/2。如此循环反复下去，y就会无限逼近x的平方根*/long r = x;while (r*r &gt; x)    r = (r + x/r) / 2;return r;</code></pre><blockquote><ul><li>思路：牛顿法求开方数。。算法很简单</li></ul></blockquote><h3 id="Q16"><a href="#Q16" class="headerlink" title="Q16"></a>Q16</h3><h4 id="1-题目信息-1"><a href="#1-题目信息-1" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：爬楼梯</li><li>编号&amp;难度：[70]，easy</li><li>Tags：dynamic-programming</li><li>描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。</li><li>例子：</li></ul></blockquote><pre><code>输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1.  1 阶 + 1 阶2.  2 阶输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1.  1 阶 + 1 阶 + 1 阶2.  1 阶 + 2 阶3.  2 阶 + 1 阶</code></pre><h4 id="2-个人Code-1"><a href="#2-个人Code-1" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=70 lang=cpp * * [70] Climbing Stairs */class Solution {public:    int climbStairs(int n) {        if(n==1)        {            return 1;        }        else if(n==2)        {            return 2;        }        //Fibonacci        int* fibonacci_array = new int[n];        fibonacci_array[0] = 1; fibonacci_array[1] = 2;        for(int i=2; i&lt;n; i++)        {            fibonacci_array[i] = fibonacci_array[i-2] + fibonacci_array[i-1];        }        return fibonacci_array[n-1];    }};</code></pre><blockquote><ul><li>思路：爬楼梯问题，高中数学竞赛课碰到过的题目。。明显是<strong>斐波那契数列</strong>：令F(n)为爬第n级楼梯方法数，则F(n) = F(n-1) + F(n-2)，<strong>因为爬到第n级的前一step，只有两个可能，脚在倒数第一个台阶&amp;倒数第二个台阶。</strong>斐波那契求解，明显不能用递归，要用顺序迭代。该题最佳思路一样，只不过不保存，没有O(n)的空间复杂度<code>fibonacci_array[n]</code></li></ul></blockquote><h3 id="Q17"><a href="#Q17" class="headerlink" title="Q17"></a>Q17</h3><h4 id="1-题目信息-2"><a href="#1-题目信息-2" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：删除排序链表中的重复元素</li><li>编号&amp;难度：[83]，easy</li><li>Tags：linked-list</li><li>描述：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</li><li>例子：</li></ul></blockquote><pre><code>输入: 1-&gt;1-&gt;2输出: 1-&gt;2输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3</code></pre><h4 id="2-个人Code-2"><a href="#2-个人Code-2" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=83 lang=cpp * * [83] Remove Duplicates from Sorted List *//** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode* deleteDuplicates(ListNode* head) {        //len == 0 or 1        if(head == nullptr || head-&gt;next==nullptr)        {            return head;        }        //len &gt; 1        ListNode *p=head, *k=head-&gt;next;         while(1)        {            int val_current = p-&gt;val;            ListNode* temp = nullptr;            while(k != nullptr &amp;&amp; k-&gt;val == val_current)            {                temp = k;                k = k-&gt;next;                p-&gt;next = k;                delete temp;            }            if(k == nullptr)            {                break;            }            else            {                p = k;                k = p-&gt;next;            }        }        return head;    }};</code></pre><blockquote><ul><li>思路：two-pointers思想，双指针。第二指针遍历和第一指针值对比，相等则delete掉。<strong>双指针方法重点在于边界检查。</strong></li></ul></blockquote><h4 id="2-个人Code-3"><a href="#2-个人Code-3" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">class Solution {public:    ListNode* deleteDuplicates(ListNode* head) {        return head &amp;&amp; (head-&gt;next = deleteDuplicates(head-&gt;next)) &amp;&amp; \            head-&gt;next-&gt;val == head-&gt;val ? head-&gt;next : head;    }};</code></pre><blockquote><ul><li>思路：无fa可说。。简洁代码要多练才能想到。。</li></ul></blockquote><h3 id="Q18"><a href="#Q18" class="headerlink" title="Q18"></a>Q18</h3><h4 id="1-题目信息-3"><a href="#1-题目信息-3" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：合并两个有序数组</li><li>编号&amp;难度：[88]，easy</li><li>Tags：array | two-pointers</li><li><p>描述：给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。<br>说明:<br>(1) 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>(2) 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p></li><li><p>例子：</p></li></ul></blockquote><pre><code>输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6],       n = 3输出: [1,2,2,3,5,6]</code></pre><h4 id="2-个人Code-4"><a href="#2-个人Code-4" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=88 lang=cpp * * [88] 合并两个有序数组 */class Solution {public:    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {        int i=m-1, j=n-1, k=m+n-1;        while(j &gt;= 0)        {            nums1[k--] = (i&gt;=0 &amp;&amp; nums1[i]&gt;nums2[j])?(nums1[i--]):(nums2[j--]);        }    }};</code></pre><blockquote><ul><li>思路：这里看了solution了。。这逆序思路很好。。</li></ul></blockquote><h3 id="Q19"><a href="#Q19" class="headerlink" title="Q19"></a>Q19</h3><h4 id="1-题目信息-4"><a href="#1-题目信息-4" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：相同的树</li><li>编号&amp;难度：[100]，easy</li><li>Tags：depth-first-search | tree</li><li>描述：给定两个二叉树，编写一个函数来检验它们是否相同。<br>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</li><li>例子：</li></ul></blockquote><pre><code>输入:       1         1          / \       / \         2   3     2   3        [1,2,3],   [1,2,3]输出: true输入:      1          1          /           \         2             2        [1,2],     [1,null,2]输出: false输入:       1         1          / \       / \         2   1     1   2        [1,2,1],   [1,1,2]输出: false</code></pre><h4 id="2-个人Code-5"><a href="#2-个人Code-5" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=100 lang=cpp * * [100] 相同的树 *//** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    bool isSameTree(TreeNode* p, TreeNode* q) {        if( (!p&amp;&amp;!q) ) return true;        if( (!p&amp;&amp;q) || (p&amp;&amp;!q) ) return false;        return (p-&gt;val == q-&gt;val) &amp;&amp; (isSameTree(p-&gt;left,q-&gt;left)) &amp;&amp; \            (isSameTree(p-&gt;right, q-&gt;right));    }};</code></pre><blockquote><ul><li>思路：巨坑在于要求中树的表示，右子树为NULL时，不表示出来。。不懂怎么弄的，看了solution，这思路很好理解。</li></ul></blockquote><h3 id="Q20"><a href="#Q20" class="headerlink" title="Q20"></a>Q20</h3><h4 id="1-题目信息-5"><a href="#1-题目信息-5" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：对称二叉树</li><li>编号&amp;难度：[101]，easy</li><li>Tags：breadth-first-search | depth-first-search | tree</li><li>描述：给定一个二叉树，检查它是否是镜像对称的。</li><li>例子：</li></ul></blockquote><pre><code>对称：    1   / \  2   2 / \ / \3  4 4  3不对称：    1   / \  2   2   \   \   3    3</code></pre><h4 id="2-个人Code-6"><a href="#2-个人Code-6" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=101 lang=cpp * * [101] 对称二叉树 *//** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    bool isSymmetric(TreeNode* root) {        if(!root) return true;        queue&lt;TreeNode*&gt; nodes_buffer;        vector&lt;TreeNode*&gt; nodes_currentLevel;        TreeNode* node;        nodes_buffer.push(root);        while(!nodes_buffer.empty())        {            int buffer_size = nodes_buffer.size();            for(int i=0; i&lt;buffer_size; i++)            {                node = nodes_buffer.front();                nodes_buffer.pop();                nodes_currentLevel.push_back(node);                if( node )                {                    nodes_buffer.push(node-&gt;left);                    nodes_buffer.push(node-&gt;right);                }            }            if(nodes_currentLevel.size() != 1)            {                int nodesNum = nodes_currentLevel.size();                for(int i=0; i&lt;nodesNum/2; i++)                {                    if(!nodes_currentLevel[i] &amp;&amp; !nodes_currentLevel[nodesNum-1-i])                        continue;                    if( (!nodes_currentLevel[i]&amp;&amp;nodes_currentLevel[nodesNum-1-i]) || \                        (nodes_currentLevel[i]&amp;&amp;!nodes_currentLevel[nodesNum-1-i]) )                        return false;                    if(nodes_currentLevel[i]-&gt;val != nodes_currentLevel[nodesNum-1-i]-&gt;val)                        return false;                }            }            nodes_currentLevel.clear();        }        return true;    }};</code></pre><blockquote><ul><li>思路：缓存nodes_currentLevel为树的每层节点，检查每层节点是否对称，树对称当且仅当所有层都对称，否则返回不对称。</li></ul></blockquote><h4 id="3-best-solution-1"><a href="#3-best-solution-1" class="headerlink" title="(3) best solution"></a>(3) best solution</h4><pre><code class="lang-cpp">class Solution {public:    bool isSymmetric(TreeNode* root) {        if (root == NULL)            return true;        return checkSymmetric(root-&gt;left, root-&gt;right);    }    //check the two nodes in symmetric position    bool checkSymmetric(TreeNode *leftSymmetricNode, TreeNode *rightSymmetricNode)    {        if (leftSymmetricNode == NULL &amp;&amp; rightSymmetricNode == NULL)            return true;        if (leftSymmetricNode == NULL || rightSymmetricNode == NULL)            return false;        if (leftSymmetricNode-&gt;val == rightSymmetricNode-&gt;val)            return checkSymmetric(leftSymmetricNode-&gt;left, rightSymmetricNode-&gt;right) &amp;&amp; checkSymmetric(leftSymmetricNode-&gt;right, rightSymmetricNode-&gt;left);        return false;    }};</code></pre><blockquote><ul><li>思路：<strong>递归调用，好思路！内置函数checkSymmetric，递归调用。</strong>重点在于<code>return checkSymmetric(leftSymmetricNode-&gt;left, rightSymmetricNode-&gt;right) &amp;&amp; checkSymmetric(leftSymmetricNode-&gt;right, rightSymmetricNode-&gt;left)</code>。自己体会。。。</li></ul></blockquote><h3 id="Q21"><a href="#Q21" class="headerlink" title="Q21"></a>Q21</h3><h4 id="1-题目信息-6"><a href="#1-题目信息-6" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：二叉树的最大深度</li><li>编号&amp;难度：[104]，easy</li><li>Tags：depth-first-search | tree</li><li>描述：给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。</li><li>例子：</li></ul></blockquote><pre><code>最大深度：3   3   / \  9  20    /  \   15   7</code></pre><h4 id="2-个人Code-7"><a href="#2-个人Code-7" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=104 lang=cpp * * [104] 二叉树的最大深度 *//** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    int maxDepth(TreeNode* root) {         if(root == NULL)            return 0;        else        {            int left_height = maxDepth(root-&gt;left);            int right_height = maxDepth(root-&gt;right);            return 1 + ((left_height&gt;right_height)?left_height:right_height);        }    }};</code></pre><blockquote><ul><li>思路：《数据结构与算法分析-C语言描述》有，思路简单易懂。。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eajack LeetCode Notes- Day2</title>
      <link href="/2019/06/06/Eajack%20LeetCode%20Notes-%20Day2/"/>
      <url>/2019/06/06/Eajack%20LeetCode%20Notes-%20Day2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目解答"><a href="#1-题目解答" class="headerlink" title="1. 题目解答"></a>1. 题目解答</h2><h3 id="Q6"><a href="#Q6" class="headerlink" title="Q6"></a>Q6</h3><h4 id="1-题目信息"><a href="#1-题目信息" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Valid Parentheses</li><li>编号&amp;难度：[20]，easy</li><li>Tags：stack | string</li><li>描述：Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.<br>An input string is valid if:<br>(1) Open brackets must be closed by the same type of brackets.<br>(2) Open brackets must be closed in the correct order.<br>Note that an empty string is also considered valid.</li><li>例子：</li></ul></blockquote><pre><code>Input: &quot;()&quot;Output: trueInput: &quot;()[]{}&quot;Output: trueInput: &quot;(]&quot;Output: falseInput: &quot;([)]&quot;Output: false</code></pre><h4 id="2-个人Code"><a href="#2-个人Code" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=20 lang=cpp * * [20] Valid Parentheses */class Solution {public:    bool isValid(string s) {        unordered_map&lt;char, char&gt; m = {            {&#39;(&#39;,&#39;)&#39;}, {&#39;[&#39;,&#39;]&#39;},{&#39;{&#39;,&#39;}&#39;}        };        vector&lt;char&gt; stack;        char ch;        for(int i=0; i&lt;s.size(); i++)        {            if(s[i] == &#39;(&#39; || s[i] == &#39;[&#39; || s[i] == &#39;{&#39;)            {                stack.push_back(s[i]);            }            else            {                if(stack.size() != 0)                {                    ch = stack.back();                    stack.pop_back();                    if(s[i] != m[ch])                    {                        return false;                    }                }                else                {                    return false;                }            }        }        return stack.empty();    }};</code></pre><blockquote><ul><li>思路：这题目在《数据结构与算法分析-C语言描述》中的“栈的应用”章节有提及。<strong>思路：遍历所有字符，碰到左边符A（包括：(、{、[），push入栈；碰到右边符号B（包括：)、}、]），则pop出栈中元素E，若E不是B对应的右边符，return false，否则继续遍历。当便利完成，检查是否空栈，空栈则返回true，否则返回false。</strong></li></ul></blockquote><h4 id="3-best-solution"><a href="#3-best-solution" class="headerlink" title="(3) best solution"></a>(3) best solution</h4><pre><code class="lang-cpp">/*Repetitive code but I guess this is clean, and easy to understand. This solution also accepts (and ignores) any characters other than parenthesis in the string. Hence, it can be used to check if the parenthesis matches in an equation for example.*/#include &lt;stack&gt;class Solution {public:    bool isValid(string s) {        stack&lt;char&gt; paren;        for (char&amp; c : s) {            switch (c) {                case &#39;(&#39;:                 case &#39;{&#39;:                 case &#39;[&#39;: paren.push(c); break;                case &#39;)&#39;: if (paren.empty() || paren.top()!=&#39;(&#39;) return false; else paren.pop(); break;                case &#39;}&#39;: if (paren.empty() || paren.top()!=&#39;{&#39;) return false; else paren.pop(); break;                case &#39;]&#39;: if (paren.empty() || paren.top()!=&#39;[&#39;) return false; else paren.pop(); break;                default: ; // pass            }        }        return paren.empty() ;    }};</code></pre><blockquote><ul><li>思路：思路其实一致的，<strong>需要学习的点：case判断char字符；写得真优雅！排版太好看了！</strong></li></ul></blockquote><h3 id="Q7"><a href="#Q7" class="headerlink" title="Q7"></a>Q7</h3><h4 id="1-题目信息-1"><a href="#1-题目信息-1" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Merge Two Sorted Lists</li><li>编号&amp;难度：[21]，easy</li><li>Tags：linked-list</li><li>描述：Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</li><li>例子：</li></ul></blockquote><pre><code>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><h4 id="2-个人Code-1"><a href="#2-个人Code-1" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=21 lang=cpp * * [21] Merge Two Sorted Lists *//** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {        //0-        if(l1 == nullptr || l2 == nullptr)        {            return (l1 == nullptr)?(l2):(l1);        }        ListNode* l3 = (l1-&gt;val &lt;= l2-&gt;val)?(l1):(l2);        ListNode* l4 = (l1-&gt;val &lt;= l2-&gt;val)?(l2):(l1);        //1-         ListNode *p2 = l4, *temp1 = nullptr, *temp2 = nullptr;        while(p2 != nullptr)        {            int p2_now_val = p2-&gt;val;            bool allPass_flag = true;            ListNode *p1_now = l3;            while(p1_now != nullptr)            {                int p1_next_val = (p1_now-&gt;next == nullptr)?(INT_MAX):(p1_now-&gt;next-&gt;val);                if(p1_now-&gt;val &lt;= p2_now_val &amp;&amp; p2_now_val &lt;= p1_next_val)                {                    temp1 = p1_now-&gt;next;                    p1_now-&gt;next = p2;                    temp2 = p2-&gt;next;                    p2-&gt;next = temp1;                    p2 = temp2;                    allPass_flag = false;                    break;                }                p1_now = p1_now-&gt;next;            }            if(allPass_flag)            {                l4-&gt;next = l3;                return l4;            }        }        return l3;    }};</code></pre><blockquote><ul><li>思路：伪代码如下（并不规范）</li></ul></blockquote><pre><code>BEGIN:    if(l1 == nullptr or l2 == nullptr):        return (l1 == nullptr)?(l2):(l1);    l3 = l1&amp;l2中首元素较小者; l4 = l1&amp;l2中首元素较大者;    for l4node in l4_nodes:        val_current = l4node-&gt;val;        val_next = next_node-&gt;val;        for l3node in l3_nodes:            val_l3node_now = l3node-&gt;val;            if(val_current &lt;= val_l3node_now &lt;= val_next):                insert l3node between l4node &amp; next_nodeEND</code></pre><h4 id="3-best-solution-1"><a href="#3-best-solution-1" class="headerlink" title="(3) best solution"></a>(3) best solution</h4><pre><code class="lang-cpp">/*C++The first line ensures that a is at least as good a list head as b, by swapping them if that’s not already the case. The second line merges the remaining lists behind a.*/ListNode* mergeTwoLists(ListNode* a, ListNode* b) {    if (!a || b &amp;&amp; a-&gt;val &gt; b-&gt;val) swap(a, b);    if (a) a-&gt;next = mergeTwoLists(a-&gt;next, b);    return a;}/*CSame solution, I just have to replace C++&#39;s swap. I’m not sure whether evaluation order is standardized, but it worked and got accepted this way.*/struct ListNode* mergeTwoLists(struct ListNode* a, struct ListNode* b) {    if (!a || b &amp;&amp; a-&gt;val &gt; b-&gt;val) a += b - (b = a);    if (a) a-&gt;next = mergeTwoLists(a-&gt;next, b);    return a;}</code></pre><blockquote><ul><li>思路：这个思路类似归并排序（merge-sort），但真的巧妙了，慢慢学习吧。。先记住。</li></ul></blockquote><h3 id="Q8"><a href="#Q8" class="headerlink" title="Q8"></a>Q8</h3><h4 id="1-题目信息-2"><a href="#1-题目信息-2" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Remove Duplicates from Sorted Array</li><li>编号&amp;难度：[26]，easy</li><li>Tags：array | two-pointers</li><li>描述：Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.<br>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</li><li>例子：</li></ul></blockquote><pre><code>Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&#39;t matter what you leave beyond the returned length.Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&#39;t matter what values are set beyond the returned length.</code></pre><h4 id="2-个人Code-2"><a href="#2-个人Code-2" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=26 lang=cpp * * [26] Remove Duplicates from Sorted Array */class Solution {public:    int removeDuplicates(vector&lt;int&gt;&amp; nums) {        //0- 0&amp;1 check        if(nums.empty() || nums.size() == 1)        {            return nums.size();        }        //1- begin        int i = 0, j = 1, cnt = 0;        while(i &lt; nums.size()-1 &amp;&amp; j &lt;= nums.size()-1)        {            while (j &lt;= nums.size()-1)            {                if(nums[j] == nums[i])                {                    j++;                }                else                {                    nums[cnt] = nums[i];                    i = j;                    j = i+1;                    cnt++;                    break;                }            }        }        nums[cnt] = nums[i];        return (cnt+1);    }};</code></pre><blockquote><ul><li>思路：two-pointers思想，双指针</li></ul></blockquote><pre><code>BEGIN    if(nums 为空 or nums 长度为1):        return nums.size()    int i=0, j=1 //双指针    int cnt=0 //更新后数组索引    while(i &lt; nums.size()-1 and j &lt;= nums.size()-1):#保证双指针均不越界        while (j &lt;= nums.size()-1):    #保证j指针不越界，以j指针遍历            if(nums[j] == nums[i]):                j++            else:                nums[cnt]更新，指针i=j, j=i+1, 索引cnt++                break    nums[cnt] = nums[i];    return(cnt+1)END</code></pre><h3 id="Q9"><a href="#Q9" class="headerlink" title="Q9"></a>Q9</h3><h4 id="1-题目信息-3"><a href="#1-题目信息-3" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Remove Element</li><li>编号&amp;难度：[27]，easy</li><li>Tags：array | two-pointers</li><li>描述：Given an array nums and a value val, remove all instances of that value in-place and return the new length.<br>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.<br>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</li><li>例子：</li></ul></blockquote><pre><code>Given nums = [3,2,2,3], val = 3,Your function should return length = 2, with the first two elements of nums being 2.It doesn&#39;t matter what you leave beyond the returned length.Given nums = [0,1,2,2,3,0,4,2], val = 2,Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.Note that the order of those five elements can be arbitrary.It doesn&#39;t matter what values are set beyond the returned length.</code></pre><h4 id="2-个人Code-3"><a href="#2-个人Code-3" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=27 lang=cpp * * [27] Remove Element */class Solution {public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) {        int new_index = 0;        for(int i=0; i&lt;nums.size(); i++)        {            if(nums[i] != val)            {                nums[new_index] = nums[i];                new_index++;            }        }        return new_index;    }};</code></pre><blockquote><ul><li>思路：two-pointers思想，双指针。思路其实很简单，然而最终还是要看答案。。<strong> 即初始化new_index = 0，遍历输入数组，若当前值 != val，则nums[new_index] = nums[i]，new_index++ </strong></li></ul></blockquote><h3 id="Q10"><a href="#Q10" class="headerlink" title="Q10"></a>Q10</h3><h4 id="1-题目信息-4"><a href="#1-题目信息-4" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Implement strStr</li><li>编号&amp;难度：[27]，easy</li><li>Tags：string | two-pointers</li><li>描述：Implement strStr().<br>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</li><li>例子：</li></ul></blockquote><pre><code>Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;Output: -1For the purpose of this problem, we will return 0 when needle is an empty string</code></pre><h4 id="2-个人Code-4"><a href="#2-个人Code-4" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=28 lang=cpp * * [28] Implement strStr() */class Solution {public:    int strStr(string haystack, string needle) {        if(needle.size() == 0)        {            return 0;        }        int find_index = -1;        for(int i=0; i&lt;haystack.size(); i++)        {            int same_cnt = 0;            if(haystack[i] == needle[0])            {                find_index = i;                same_cnt++;                // haystack 不包含 needle                if(haystack.size()-i+1 &lt; needle.size())                {                    return -1;                }                // haystack 包含 needle长度，遍历                for(int j=i+1, k=1; k&lt;needle.size(); j++, k++)                {                    if(haystack[j] == needle[k])                    {                        same_cnt++;                    }                }                if(same_cnt == needle.size())                {                    return find_index;                }            }        }        return -1;    }};</code></pre><blockquote><ul><li>思路：首先，遍历haystack字符串，寻找和needle字符串首个char相同的位置i， 记录find_index = i；然后，判断剩余的haystack字符串能否覆盖needle字符串，若不能，则return false，否则遍历同时遍历 haystack字符串 &amp; needle字符串，计算相同个数same_cnt；最后，判断same_cnt == needle.size()，return find_index，否则return -1。</li></ul></blockquote><h4 id="3-best-solution-2"><a href="#3-best-solution-2" class="headerlink" title="(3) best solution"></a>(3) best solution</h4><pre><code class="lang-cpp">// bruteclass Solution {public:    int strStr(string haystack, string needle) {        int m = haystack.size(), n = needle.size();        for (int i = 0; i &lt;= m - n; i++) {            int j = 0;            for (; j &lt; n; j++) {                if (haystack[i + j] != needle[j]) {                    break;                }            }            if (j == n) {                return i;            }        }        return -1;    }};//KMPclass Solution {public:    int strStr(string haystack, string needle) {        int m = haystack.size(), n = needle.size();        if (!n) {            return 0;        }        vector&lt;int&gt; lps = kmpProcess(needle);        for (int i = 0, j = 0; i &lt; m;) {            if (haystack[i] == needle[j]) {                 i++, j++;            }            if (j == n) {                return i - j;            }            if (i &lt; m &amp;&amp; haystack[i] != needle[j]) {                j ? j = lps[j - 1] : i++;            }        }        return -1;    }private:    vector&lt;int&gt; kmpProcess(string needle) {        int n = needle.size();        vector&lt;int&gt; lps(n, 0);        for (int i = 1, len = 0; i &lt; n;) {            if (needle[i] == needle[len]) {                lps[i++] = ++len;            } else if (len) {                len = lps[len - 1];            } else {                lps[i++] = 0;            }        }        return lps;    }};</code></pre><blockquote><ul><li>思路：brute暴力搜索类似我的解决方案，但更简略；KMP是有名的字符串搜索算法；</li></ul></blockquote><h3 id="Q11"><a href="#Q11" class="headerlink" title="Q11"></a>Q11</h3><h4 id="1-题目信息-5"><a href="#1-题目信息-5" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Search Insert Position</li><li>编号&amp;难度：[35]，easy</li><li>Tags：array | binary-search</li><li>描述：Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.<br>You may assume no duplicates in the array.</li><li>例子：</li></ul></blockquote><pre><code>Input: [1,3,5,6], 5Output: 2Input: [1,3,5,6], 2Output: 1Input: [1,3,5,6], 7Output: 4Input: [1,3,5,6], 0Output: 0</code></pre><h4 id="2-个人Code-5"><a href="#2-个人Code-5" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=35 lang=cpp * * [35] Search Insert Position */class Solution {public:    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {        int low = 0, high = nums.size()-1, mid = 0;        while(low &lt;= high)        {            mid = (low+high)/2;            if(nums[mid] &lt; target)            {                low = mid+1;            }            else if(nums[mid] &gt; target)            {                high = mid-1;            }            else            {                return mid;            }        }        //not found        return (low&gt;high)?(low):(high);    }};</code></pre><blockquote><ul><li>思路：这题就是binary-search变种，找返回位置，否则返回low &amp; high较大者。</li></ul></blockquote><h3 id="Q12"><a href="#Q12" class="headerlink" title="Q12"></a>Q12</h3><h4 id="1-题目信息-6"><a href="#1-题目信息-6" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Maximum Subarray</li><li>编号&amp;难度：[53]，easy</li><li>Tags：array | divide-and-conquer | dynamic-programming</li><li>描述：Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</li><li>例子：</li></ul></blockquote><pre><code>Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6.</code></pre><h4 id="2-个人Code-6"><a href="#2-个人Code-6" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=53 lang=cpp * * [53] Maximum Subarray */class Solution {public:    int maxSubArray(vector&lt;int&gt;&amp; nums) {        int thisSum, maxSum, i;        thisSum = maxSum = 0;        for(int i=0; i&lt;nums.size(); i++)        {            thisSum += nums[i];            if(thisSum &gt; maxSum)            {                maxSum = thisSum;            }            else if(thisSum &lt; 0)            {                thisSum = 0;            }        }        //all are minus        if(maxSum == 0)        {            maxSum = nums[0];            for(int i=1; i&lt;nums.size(); i++)            {                maxSum = (nums[i]&gt;maxSum)?(nums[i]):(maxSum);            }        }        return maxSum;    }};</code></pre><blockquote><ul><li>思路：最大子序列和，在《数据结构与算法分析-C语言描述》中有，此处也是用的书中代码改一下。思路很巧妙：<strong>除了全负数序列外，其他序列的最大子序列和一定大于等于0</strong>，因此设置maxSum = 0 ，遍历N次逐项累加thisSum，若thisSum &gt; maxSum，则更新maxSum，若thisSum &lt; 0，则令thisSum = 0继续遍历。遍历完后，判断maxSum == 0，若是则证明为全负数序列，取序列最大值return；否则return 原来的maxSum（&gt; 0）。<strong>best solution可以用分治，这里就不说了。。</strong></li></ul></blockquote><h3 id="Q13"><a href="#Q13" class="headerlink" title="Q13"></a>Q13</h3><h4 id="1-题目信息-7"><a href="#1-题目信息-7" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Length of Last Word</li><li>编号&amp;难度：[58]，easy</li><li>Tags：string</li><li>描述：Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.<br>If the last word does not exist, return 0.<br>Note: A word is defined as a character sequence consists of non-space characters only.</li><li>例子：</li></ul></blockquote><pre><code>Input: &quot;Hello World&quot;Output: 5</code></pre><h4 id="2-个人Code-7"><a href="#2-个人Code-7" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=58 lang=cpp * * [58] Length of Last Word */class Solution {public:    int lengthOfLastWord(string s) {        int last_blank_index = -1, word_len = 0;        int s_begin = 0, s_end = s.size()-1;        //1- cut head &amp; tail blanks(s.strip())        while(s_begin &lt; s.size() &amp;&amp; s[s_begin] == &#39; &#39;)        {            s_begin++;        }        while(s_end &gt;= 0 &amp;&amp; s[s_end] == &#39; &#39;)        {            s_end--;        }        //2- check if s.strip() == &#39;&#39;        if(s_begin == s.size() &amp;&amp; s_end == -1)        {            return 0;        }        //3- begin        for(int i=s_begin; i&lt;s_end+1; i++)//get the last_blank_index        {            if(s[i] == &#39; &#39;)            {                last_blank_index = i;            }        }        if(last_blank_index != -1)//has blank inside s.strip()        {            for(int i=last_blank_index+1; i&lt;s_end+1; i++)            {                word_len++;            }        }        else//no blank inside s.strip() &amp;&amp; s.strip() != &#39;&#39;        {            word_len = s_end-s_begin+1;        }        return word_len;    }};</code></pre><blockquote><ul><li>思路：1- s.strip()（类似python函数）；2- 判断s.strip() == ‘’，是则返回0；3-开始遍历获得最后一个空格，对应的后面word，计算len。</li></ul></blockquote><h4 id="3-best-solution-3"><a href="#3-best-solution-3" class="headerlink" title="(3) best solution"></a>(3) best solution</h4><pre><code class="lang-cpp">/* Well, the basic idea is very simple. Start from the tail of s and move backwards to find the first non-space character. Then from this character, move backwards and count the number of non-space characters until we pass over the head of s or meet a space character. The count will then be the length of the last word. *///从尾部开始找第一个非空格字符，开始len++，直到倒退找到第一个空格字符class Solution {public:    int lengthOfLastWord(string s) {         int len = 0, tail = s.length() - 1;        while (tail &gt;= 0 &amp;&amp; s[tail] == &#39; &#39;) tail--;        while (tail &gt;= 0 &amp;&amp; s[tail] != &#39; &#39;) {            len++;            tail--;        }        return len;    }};</code></pre><blockquote><ul><li>思路：如注释。。<strong>逆向思维，这才是好解答。</strong></li></ul></blockquote><h3 id="Q14"><a href="#Q14" class="headerlink" title="Q14"></a>Q14</h3><h4 id="1-题目信息-8"><a href="#1-题目信息-8" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Add Binary</li><li>编号&amp;难度：[67]，easy</li><li>Tags：math | string</li><li>描述：Given two binary strings, return their sum (also a binary string).<br>The input strings are both non-empty and contains only characters 1 or 0.</li><li>例子：</li></ul></blockquote><pre><code>Input: a = &quot;11&quot;, b = &quot;1&quot;Output: &quot;100&quot;Input: a = &quot;1010&quot;, b = &quot;1011&quot;Output: &quot;10101&quot;</code></pre><h4 id="2-个人Code-8"><a href="#2-个人Code-8" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=67 lang=cpp * * [67] Add Binary */class Solution {public:    string addBinary(string a, string b) {        string ab_sum, ab_sum_return;        char sum_now = &#39;0&#39;, carry = &#39;0&#39;;        bool a_bool, b_bool, carry_bool;        //1- 补0等长 + 1        int a_len = a.size(), b_len = b.size();        if(a_len != b_len)        {            int extraLen = abs(a_len-b_len)+1;            bool aorb = (a_len &lt; b_len);            for(int i=1; i&lt;=extraLen; i++)            {                if(aorb)                {                    a = &#39;0&#39; + a;                    if(i==1) b = &#39;0&#39; + b;                }                else                {                    b = &#39;0&#39; + b;                    if(i==1) a = &#39;0&#39; + a;                }            }        }        //2- begin        for(int i=a.size()-1; i&gt;=0; i--)        {            a_bool = (a[i] == &#39;1&#39;)?(true):(false);            b_bool = (b[i] == &#39;1&#39;)?(true):(false);            carry_bool = (carry == &#39;1&#39;)?(true):(false);            //真值表            sum_now = ( ((!a_bool)&amp;&amp;(!b_bool)&amp;&amp;(carry_bool)) || ((!a_bool)&amp;&amp;(b_bool)&amp;&amp;(!carry_bool)) || \                ((a_bool)&amp;&amp;(!b_bool)&amp;&amp;(!carry_bool)) || ((a_bool)&amp;&amp;(b_bool)&amp;&amp;(carry_bool)) )? (&#39;1&#39;):(&#39;0&#39;);            carry = ( ((!a_bool)&amp;&amp;(b_bool)&amp;&amp;(carry_bool)) || ((a_bool)&amp;&amp;(!b_bool)&amp;&amp;(carry_bool)) || \                ((a_bool)&amp;&amp;(b_bool)&amp;&amp;(!carry_bool)) || ((a_bool)&amp;&amp;(b_bool)&amp;&amp;(carry_bool)) )? (&#39;1&#39;):(&#39;0&#39;);            ab_sum = sum_now + ab_sum;        }        ab_sum = carry + ab_sum;        //3- ab_sum.lstrip()        int first_notZero_index = 0;        while(first_notZero_index &lt; ab_sum.size()-1 &amp;&amp; ab_sum[first_notZero_index] == &#39;0&#39;)        {            first_notZero_index++;        }        if (first_notZero_index == -1)        {            first_notZero_index = 1;        }        for(int i=first_notZero_index; i&lt;ab_sum.size(); i++)        {            ab_sum_return += ab_sum[i];        }        return ab_sum_return;    }};</code></pre><blockquote><ul><li>思路：二进制加法，个人代码采用典型的<strong>数字电路的真值表解法</strong>，我觉得这做法比best solution好。代码不难懂，需要一些基本数电基础即可。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eajack LeetCode Notes- Day1</title>
      <link href="/2019/05/31/Eajack%20LeetCode%20Notes-%20Day1/"/>
      <url>/2019/05/31/Eajack%20LeetCode%20Notes-%20Day1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目解答"><a href="#1-题目解答" class="headerlink" title="1. 题目解答"></a>1. 题目解答</h2><h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h3><h4 id="1-题目信息"><a href="#1-题目信息" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Two Sum</li><li>编号&amp;难度：[1]，easy</li><li>Tags：array，hash-table</li><li>描述：Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice.</li><li>例子：Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</li></ul></blockquote><h4 id="2-个人Code"><a href="#2-个人Code" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=1 lang=cpp * * [1] Two Sum *///O(N^2)class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;int&gt; indices;        for(int i=0; i&lt;nums.size(); i++)        {            int find_flag = 0;            for(int j=i+1; j&lt;nums.size(); j++)            {                if(nums[i]+nums[j] == target)                {                    find_flag = 1;                    indices.push_back(i);                    indices.push_back(j);                    break;                }            }            if(find_flag)            {                break;            }        }        return indices;    }};</code></pre><blockquote><ul><li>思路：相当简单，O(N^2)，由于题目限定只考虑2个不是同1个元素的sum，因此i、j遍历</li></ul></blockquote><h4 id="3-best-solution"><a href="#3-best-solution" class="headerlink" title="(3) best solution"></a>(3) best solution</h4><pre><code class="lang-cpp">/* The basic idea is to maintain a hash table for each element num in nums, using num as key and its index (0-based) as value. For each num, search for target - num in the hash table. If it is found and is not the same element as num, then we are done.The code is as follows. Note that each time before we add num to mp, we search for target - num first and so we will not hit the same element. *///O(N)class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        unordered_map&lt;int, int&gt; indices;        for (int i = 0; i &lt; nums.size(); i++) {            if (indices.find(target - nums[i]) != indices.end()) {                return {indices[target - nums[i]], i};            }            indices[nums[i]] = i;        }        return {};    }};</code></pre><blockquote><ul><li>思路：如注释所示，引入<code>unordered_map</code>（<strong>注意：LeetCode平台不能用map（也看情况，目前碰到的题目不能用），可以用标准库内置的unordered_map</strong>），即哈希表。如果map中没有另一半元素，则添加<code>key =nums[i] , value = i</code>，此处<code>value</code>没用。O(N)。</li></ul></blockquote><h3 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h3><h4 id="1-题目信息-1"><a href="#1-题目信息-1" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Reverse Integer</li><li>编号&amp;难度：[7]，easy</li><li>Tags：math</li><li>描述：Given a 32-bit signed integer, reverse digits of an integer.</li><li>例子：123 =&gt; 321，-123 =&gt; -321，120 =&gt; 21</li><li>备注：Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</li></ul></blockquote><h4 id="2-个人Code-1"><a href="#2-个人Code-1" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><p>这道题没AC，弄太久了…直接看solution了</p><pre><code class="lang-cpp">/* * @lc app=leetcode id=7 lang=cpp * * [7] Reverse Integer *///failed in 2019/5/30// using solution code ACclass Solution {public:    int reverse(int x) {        long result = 0;        while(x != 0)        {            result = result*10 + x%10;//key code!            x /= 10;        }        return ((result &gt; INT_MAX || result &lt; INT_MIN)?(0):(result));};};</code></pre><blockquote><ul><li>思路：可以说代码相当巧妙。。key code =&gt; <code>result = result*10 + x%10</code>，先记住吧。。还有另一种思路push &amp; pop，类似。</li></ul></blockquote><pre><code class="lang-cpp">//pop operation:pop = x % 10;x /= 10;//push operation:temp = rev * 10 + pop;rev = temp;</code></pre><h3 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h3><h4 id="1-题目信息-2"><a href="#1-题目信息-2" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Palindrome Number</li><li>编号&amp;难度：[9]，easy</li><li>Tags：math</li><li>描述：Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</li><li>备注：Coud you solve it without converting the integer to a string?</li></ul></blockquote><h4 id="2-个人Code-2"><a href="#2-个人Code-2" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=9 lang=cpp * * [9] Palindrome Number */class Solution {public:    bool isPalindrome(int x) {        if(x &lt; 0)        {            return false;        }        else if(x &gt;= 0 &amp;&amp; x &lt; 10)        {            return true;        }        else        {            //reverse_x            // using code in Problem[7]            long reverse_x = 0, x_buffer = x;            while(x != 0)            {                reverse_x = reverse_x*10 + x%10;                x /= 10;            }            if(x_buffer == reverse_x)            {                return true;            }            else            {                return false;            }        }    }};</code></pre><blockquote><ul><li>思路：相当简单，直接沿用Q2代码，只用考虑 <code>x &gt;= 10</code>数字（Q2代码）</li></ul></blockquote><h4 id="3-best-solution-1"><a href="#3-best-solution-1" class="headerlink" title="(3) best solution"></a>(3) best solution</h4><pre><code class="lang-cpp">class Solution {public:    bool isPalindrome(int x) {        if(x&lt;0|| (x!=0 &amp;&amp;x%10==0)) return false;        int sum=0;        while(x&gt;sum)        {            sum = sum*10+x%10;            x = x/10;        }        return (x==sum)||(x==sum/10);    }};</code></pre><blockquote><ul><li>思路：差别不大，也是先剔除明显的。最后对比，因为sum省去求后连续0的和，因此补上 <code>(x==sum/10)</code>。</li></ul></blockquote><h3 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h3><h4 id="1-题目信息-3"><a href="#1-题目信息-3" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Roman to Integer</li><li>编号&amp;难度：[13]，easy</li><li>Tags：math，string</li><li>描述：Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:（1） I can be placed before V (5) and X (10) to make 4 and 9. （2）X can be placed before L (50) and C (100) to make 40 and 90. （3）C can be placed before D (500) and M (1000) to make 400 and 900.</li><li>备注：Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</li></ul></blockquote><pre><code>Symbol       ValueI             1V             5X             10L             50C             100D             500M             1000</code></pre><h4 id="2-个人Code-3"><a href="#2-个人Code-3" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=13 lang=cpp * * [13] Roman to Integer */class Solution {public:    int romanToInt(string s) {        int result = 0;        for(int i=0; i&lt;s.size(); i++)        {            if(s[i] == &#39;I&#39;)            {                if(s[i+1] != &#39;V&#39; &amp;&amp; s[i+1] != &#39;X&#39;)                {                     result += 1;                }                else                {                    result += ( (s[i+1] == &#39;V&#39;)?(4):(9) );                    i++;                }            }            else if (s[i] == &#39;X&#39;)            {                if(s[i+1] != &#39;L&#39; &amp;&amp; s[i+1] != &#39;C&#39;)                {                     result += 10;                }                else                {                    result += ( (s[i+1] == &#39;L&#39;)?(40):(90) );                    i++;                }            }            else if(s[i] == &#39;C&#39;)            {                if(s[i+1] != &#39;D&#39; &amp;&amp; s[i+1] != &#39;M&#39;)                {                     result += 100;                }                else                {                    result += ( (s[i+1] == &#39;D&#39;)?(400):(900) );                    i++;                }            }            else if(s[i] == &#39;V&#39; || s[i] == &#39;L&#39;)            {                result += ( (s[i] == &#39;V&#39;)?(5):(50) );            }            else            {                result += ( (s[i] == &#39;D&#39;)?(500):(1000) );            }        }        return result;    }};</code></pre><blockquote><ul><li>思路：相当简单，先判断I、X、C，之后判断其他</li></ul></blockquote><h4 id="3-best-solution-2"><a href="#3-best-solution-2" class="headerlink" title="(3) best solution"></a>(3) best solution</h4><pre><code class="lang-cpp">// Points://  1- unordered_map cpp标准库，可以直接用，乱序map，用法与map一致//  2- right =&gt; left, easy to judge when to add or substractclass Solution {public:    int romanToInt(string s) {        if (s.empty()) { return 0; }        unordered_map&lt;char, int&gt; mp { {&#39;I&#39;, 1}, {&#39;V&#39;, 5}, {&#39;X&#39;, 10}, {&#39;L&#39;, 50}, {&#39;C&#39;, 100}, {&#39;D&#39;, 500}, {&#39;M&#39;, 1000} };        int sum = mp[s.back()];        for (int i = s.size() - 2; i &gt;= 0; --i) {            sum += mp[s[i]] &gt;= mp[s[i + 1]] ? mp[s[i]] : -mp[s[i]];        }        return sum;    }};</code></pre><blockquote><ul><li>思路：差别不大，用了 <code>unordered_map</code>（记住！）</li></ul></blockquote><h3 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h3><h4 id="1-题目信息-4"><a href="#1-题目信息-4" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Longest Common Prefix</li><li>编号&amp;难度：[14]，easy</li><li>Tags：string</li><li>描述：Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”.</li><li>例子：</li></ul></blockquote><pre><code>Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot;Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings.</code></pre><blockquote><ul><li>备注：All given inputs are in lowercase letters a-z.</li></ul></blockquote><h4 id="2-个人Code-4"><a href="#2-个人Code-4" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=14 lang=cpp * * [14] Longest Common Prefix *///Attention://  1- string内部是char字符组成//  2- string =&gt; char： const char* p_char = p_string.c_str()class Solution {public:    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {        int cnt = 0;        string prefix = &quot;&quot;;        char s_i;        //空strs        if(strs.size() == 0)        {            return prefix;        }        //begin        while(1)        {            if(cnt &lt; strs[0].size())            {                s_i = strs[0][cnt];            }            else            {                return prefix;            }            for(int i=0; i&lt;strs.size(); i++)            {                if(cnt &gt; strs[i].size() || strs[i][cnt] != s_i)                {                    return prefix;                }            }            prefix += s_i;            cnt++;        }    }};</code></pre><blockquote><ul><li>思路：由于是前缀，因此所有string等齐扫描即可，字符初始化为strs[0][cnt]，碰到 <code>越界 or 不等</code> 即可return。</li></ul></blockquote><h2 id="2-收获-amp-总结"><a href="#2-收获-amp-总结" class="headerlink" title="2. 收获&amp;总结"></a>2. 收获&amp;总结</h2><p>最大的不足就是：<strong>C++不熟练！！！写代码太慢了！！！</strong>，一道题能弄个半个钟 ~ 1个钟，我真的佛了自己。。太垃圾了。。。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据结构与算法分析-C语言描述》C++实现</title>
      <link href="/2019/05/28/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-C%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E3%80%8BC++%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/05/28/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-C%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E3%80%8BC++%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="data-structures-and-algorithm-analysis-in-C"><a href="#data-structures-and-algorithm-analysis-in-C" class="headerlink" title="data structures and algorithm analysis in C"></a>data structures and algorithm analysis in C</h1><h1 id="《数据结构与算法分析——C语言描述》"><a href="#《数据结构与算法分析——C语言描述》" class="headerlink" title="《数据结构与算法分析——C语言描述》"></a>《数据结构与算法分析——C语言描述》</h1><p><div align="center"><img src="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/blob/master/book.jpg"></div><br>GitHub: <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C" target="_blank" rel="noopener">data-structures-and-algorithm-analysis-in-C</a></p><h2 id="1、运行环境"><a href="#1、运行环境" class="headerlink" title="1、运行环境"></a>1、运行环境</h2><blockquote><ul><li>Windows</li><li>VS 2017</li><li>cpp</li></ul></blockquote><h2 id="2、参考资料"><a href="#2、参考资料" class="headerlink" title="2、参考资料"></a>2、参考资料</h2><blockquote><ul><li>《数据结构与算法分析——C语言描述》</li><li>Google</li></ul></blockquote><h2 id="3、代码说明"><a href="#3、代码说明" class="headerlink" title="3、代码说明"></a>3、代码说明</h2><p>cpp代码实现（cpp入门弱鸡，混C/cpp风格），每一章节的文件夹对应1个VS2017 cpp工程。实现进度如下：</p><blockquote><ul><li>实现：Chapter 2 ~ 9</li><li>基本实现：Chapter 10</li><li>未实现：Chapter 11-12、Chapter 4.4-4.5</li></ul></blockquote><p>book章节总结：</p><blockquote><ul><li>Chapter 1：数学基本知识、递归介绍</li><li>Chapter 2：大O分析、大Ω分析、大Θ分析、算法题例子</li><li>Chapter 3：链表、栈、队列</li><li>Chapter 4：基本树结构：二叉树、表达式树、二叉查找树、AVL树、伸展树、B树、树的遍历</li><li>Chapter 5：HashMap哈希表（散列）</li><li>Chapter 6：堆（优先队列）：二叉堆、d-堆、左式堆、斜堆、二项队列（森林forest）</li><li>Chapter 7：排序算法：插入、希尔、堆、归并、快排、桶式排序、基数排序；冒泡、选择</li><li>Chapter 8：并查集（不相交集）</li><li>Chapter 9：图论：拓扑排序、最短路算法（uW-uDAG、W-DAG、nw-DAG）、网络流问题、最小生成树、BFS &amp; DFS、NP问题介绍</li><li>Chapter 10：算法设计技巧：贪心、分治、动态规划、回溯</li><li>Chapter 11：摊还分析（M次总共再M平均），例子：二项队列、斜堆、斐波那契堆、伸展树</li><li>Chapter 12：高级DS：红黑树、treap树、k-d树、AA-树、配对堆、skip list etc.</li></ul></blockquote><p>以下总结已完成代码：</p><h3 id="1-Chapter-2"><a href="#1-Chapter-2" class="headerlink" title="1. Chapter_2"></a>1. <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/tree/master/chapter_2" target="_blank" rel="noopener">Chapter_2</a></h3><blockquote><ul><li>最大子序列和问题（3种算法）</li><li>二分法（binary search）</li><li>欧几里得算法gcd（求最大公因子）</li><li>取幂算法</li></ul></blockquote><h3 id="2-Chapter-3"><a href="#2-Chapter-3" class="headerlink" title="2. Chapter_3"></a>2. <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/tree/master/chapter_3" target="_blank" rel="noopener">Chapter_3</a></h3><h4 id="2-1-链表-linkedList"><a href="#2-1-链表-linkedList" class="headerlink" title="2.1 链表 linkedList"></a>2.1 链表 linkedList</h4><h5 id="2-1-1-链表（单链表-linkedList、双链表-linkedList-double、循环链表-linkedList-circle）（N为链表长度）"><a href="#2-1-1-链表（单链表-linkedList、双链表-linkedList-double、循环链表-linkedList-circle）（N为链表长度）" class="headerlink" title="2.1.1 链表（单链表 linkedList、双链表 linkedList_double、循环链表 linkedList_circle）（N为链表长度）"></a>2.1.1 链表（单链表 linkedList、双链表 linkedList_double、循环链表 linkedList_circle）<strong>（N为链表长度）</strong></h5><h6 id="1-共同功能（具体代码实现不同）"><a href="#1-共同功能（具体代码实现不同）" class="headerlink" title="(1) 共同功能（具体代码实现不同）"></a>(1) 共同功能（具体代码实现不同）</h6><blockquote><ul><li>linkedList produceEmptyList()：<strong>生成空单链表，O(1)</strong></li><li>linkedList produceList(const int A[], int N)：<strong>生成单链表，O(N)</strong></li><li>int isEmptyList(linkedList L)：<strong>判断L是否为空单链表，O(1)</strong></li><li>ptrToNode find_x(int x, linkedList L)：<strong>在单链表L中，查找x值位置（线性遍历，第一个碰到的节点），O(N)</strong></li><li>int getListLength(linkedList L)：<strong>获取单链表L的长度，O(N)</strong></li><li>ptrToNode findPrevious(int x, linkedList L)：<strong>在单链表L中，查找x值前一节点位置（线性遍历，第一个碰到的节点），O(N)</strong></li><li>void delete_x(int x, linkedList L)：<strong>在单链表L中，删除x值对应的节点（线性遍历，第一个碰到的节点），O(1)（不考虑findPrevious子函数复杂度）</strong></li><li>void delete_L(linkedList L)：<strong>删除链表，包括表头，O(N)</strong></li><li>void printList(linkedList L)：<strong>打印链表，O(N)</strong></li><li>ptrToNode insert_x(int x, linkedList L, ptrToNode p)：<strong>insert元素x，在p后面插入x, 返回插入x对应node地址，O(1)</strong><h6 id="2-独立功能：不同类型链表内部存在独立功能函数，此处不一一展示"><a href="#2-独立功能：不同类型链表内部存在独立功能函数，此处不一一展示" class="headerlink" title="(2) 独立功能：不同类型链表内部存在独立功能函数，此处不一一展示"></a>(2) 独立功能：不同类型链表内部存在独立功能函数，此处不一一展示</h6><h5 id="2-1-2-链表应用"><a href="#2-1-2-链表应用" class="headerlink" title="2.1.2 链表应用"></a>2.1.2 链表应用</h5></li><li>int<em> bucketSort(const int A[], int N, int M, bool reverseFlag)：<em>*桶式排序，O(N-M)，N个整数，取值范围为0~M-1</em></em></li><li>int get_digit(int num, int digit)：<strong>radixSort辅助函数，获取num的位digit处值，O(digit)</strong></li><li>void radixSort(int<em> A, int N, bool reverseFlag=false, int M=10)：<em>*基数排序，O(PNM)实现，然而书中是O(P(N-M))…</em></em><h4 id="2-2-栈-stack"><a href="#2-2-栈-stack" class="headerlink" title="2.2 栈 stack"></a>2.2 栈 stack</h4><h5 id="2-2-1-栈-（N为栈元素数量）"><a href="#2-2-1-栈-（N为栈元素数量）" class="headerlink" title="2.2.1 栈 （N为栈元素数量）"></a>2.2.1 栈 <strong>（N为栈元素数量）</strong></h5></li><li>int isEmptyStack(Stack S)：<strong>判断是否为空栈，O(1)</strong></li><li>Stack produceEmptyStack()：<strong>生成空栈，O(1)</strong></li><li>Stack produceStack(const int A[], int N)：<strong>生成栈，O(N)</strong></li><li>void push(int x, Stack S)：<strong>栈push，改变栈内容，O(1)</strong></li><li>void pop(Stack S)：<strong>栈pop，改变栈内容，O(1)</strong></li><li>int top(Stack S)：<strong>返回栈顶元素值，不栈内容，O(1)</strong></li><li>void deleteStack(Stack S)：<strong>删除栈，O(N)</strong></li><li>void printStack(Stack S)：<strong>打印栈，O(N)</strong><h5 id="2-2-2-栈应用"><a href="#2-2-2-栈应用" class="headerlink" title="2.2.2 栈应用"></a>2.2.2 栈应用</h5></li><li>int checkSymbols(string inputText)：<strong>平衡符号检测，编译器检查符号是否成对，O(|inputText|)</strong></li><li>int calculatePostfix(const char postfixExpression_array[], int N)：<strong>计算后缀表达式，O(N)</strong></li><li>char<em> transfer_Infix2Postfix(const char postfixExpression_array[], int N)：<em>*中缀表达式 =&gt; 后缀表达式，O(N)</em></em><h4 id="2-3-队列-queue-（N为队列元素数量）（基于链表）"><a href="#2-3-队列-queue-（N为队列元素数量）（基于链表）" class="headerlink" title="2.3 队列 queue （N为队列元素数量）（基于链表）"></a>2.3 队列 queue <strong>（N为队列元素数量）</strong>（基于链表）</h4></li><li>int isEmpty_queue(queue_header Q)：<strong>判断是否为空队列，O(1)</strong></li><li>int isFull_queue(queue_header Q)：<strong>判断是否为满队列，O(1)</strong></li><li>queue_header createEmptyQueue()：<strong>生成空队列，O(1)</strong></li><li>void deleteQueue(queue_header Q)：<strong>删除队列，O(N)</strong></li><li>void enqueue(int x, queue_header Q)：<strong>尾部入队，O(N)</strong></li><li>int dequeue(queue_header Q)：<strong>头部出队，O(1)</strong></li><li>queue_header createQueue(const int A[], int N)：<strong>生成队列，O(N)</strong></li><li>void print_queue(queue_header Q)：<strong>打印队列，O(N)</strong></li></ul></blockquote><h3 id="3-Chapter-4"><a href="#3-Chapter-4" class="headerlink" title="3. Chapter_4"></a>3. <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/tree/master/chapter_4" target="_blank" rel="noopener">Chapter_4</a></h3><h4 id="3-1-树-tree（部分基于栈）"><a href="#3-1-树-tree（部分基于栈）" class="headerlink" title="3.1 树 tree（部分基于栈）"></a>3.1 树 tree（部分基于栈）</h4><h5 id="3-1-1-二叉树binary-tree（表达式树、二叉查找树binary-search-tree【BST，左小右大】）（N为节点树数目）"><a href="#3-1-1-二叉树binary-tree（表达式树、二叉查找树binary-search-tree【BST，左小右大】）（N为节点树数目）" class="headerlink" title="3.1.1 二叉树binary tree（表达式树、二叉查找树binary search tree【BST，左小右大】）（N为节点树数目）"></a>3.1.1 二叉树binary tree（表达式树、二叉查找树binary search tree【BST，左小右大】）<strong>（N为节点树数目）</strong></h5><blockquote><ul><li>tree_bi createEmptyTree()：<strong>生成空树，O(1)</strong></li><li>tree_bi createRoot(int x)：<strong>生成根，O(1)</strong></li><li>int getHeight(searchTree T)：<strong>获取树高度，O(N)</strong></li><li>void delete_wholeST(searchTree T)：<strong>删除树，O(N)</strong></li><li>ptrToNode_bi find_x_ST(int x, searchTree T)：<strong>寻找值为x的节点，O(logN)</strong></li><li>ptrToNode_bi find_min_ST(searchTree T)：<strong>寻找最小值的节点，O(logN)</strong></li><li>ptrToNode_bi find_max_ST(searchTree T)：<strong>寻找最大值的节点，O(logN)</strong></li><li>searchTree insert_ST(int x, searchTree T)：<strong>插入x值的节点，O(logN)</strong></li><li>searchTree delete_ST(int x, searchTree T)：<strong>删除x值的节点，O(logN)</strong></li><li>searchTree create_ST(const int A[], int N)：<strong>生成BST，O(NlogN)</strong></li><li>void printValue_ST(int value, int depth)：<strong>print_ST辅助函数，O(1)</strong></li><li>void print_ST(searchTree T, int depth, int option)：<strong>树的遍历，先序preorder, 中序infix &amp; 后序post, O(N)</strong></li><li>tree_bi build_expressionTree(const int A[], int N)：<strong>构建表达式树， O(N)</strong><h5 id="3-1-2-其余树没实现。。。包括：B树、AVL树、伸展树；红黑树、treap树、k-d树、AA-树（Chapter-12，高级数据结构）"><a href="#3-1-2-其余树没实现。。。包括：B树、AVL树、伸展树；红黑树、treap树、k-d树、AA-树（Chapter-12，高级数据结构）" class="headerlink" title="3.1.2 其余树没实现。。。包括：B树、AVL树、伸展树；红黑树、treap树、k-d树、AA-树（Chapter 12，高级数据结构）"></a>3.1.2 其余树没实现。。。包括：B树、AVL树、伸展树；红黑树、treap树、k-d树、AA-树（Chapter 12，高级数据结构）</h5></li></ul></blockquote><h3 id="4-Chapter-5"><a href="#4-Chapter-5" class="headerlink" title="4. Chapter_5"></a>4. <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/tree/master/chapter_5" target="_blank" rel="noopener">Chapter_5</a></h3><h4 id="4-1-哈希表-HashMap（散列）"><a href="#4-1-哈希表-HashMap（散列）" class="headerlink" title="4.1 哈希表 HashMap（散列）"></a>4.1 哈希表 HashMap（散列）</h4><h5 id="4-1-1-方法1：分离链接法-separate-chainning-method（基于链表）（N为链表个数，tableSize）"><a href="#4-1-1-方法1：分离链接法-separate-chainning-method（基于链表）（N为链表个数，tableSize）" class="headerlink" title="4.1.1 方法1：分离链接法 separate chainning method（基于链表）（N为链表个数，tableSize）"></a>4.1.1 方法1：分离链接法 separate chainning method（基于链表）<strong>（N为链表个数，tableSize）</strong></h5><blockquote><ul><li>int nextPrime_seq(int N)：<strong>寻找大于N的第一个素数，O(N^1.5)</strong></li><li>int hashFuntion_seq(int key, int modValue)：<strong>哈希函数， O(1)</strong></li><li>ptrToHashTable_seq createEmptyHashTable_seq(int tableSize)：<strong>构建空哈希表， O(N)</strong></li><li>void deleteHashTable_seq(ptrToHashTable_seq H)：<strong>删除哈希表H， O(N)</strong></li><li>ptrToNode_seq find_seq(int key, ptrToHashTable_seq H)：<strong>查找H[key]， O(N)</strong></li><li>void insert_seq(int key, ptrToHashTable_seq H)：<strong>插入key， O(N)</strong></li><li>ptrToHashTable_seq createHashTable_seq(const int key[], int N, int tableSize)：<strong>构建哈希表， O(N * tableSize)</strong><h5 id="4-1-2-方法2：开放定址法-open-addressing-（N为链表个数，tableSize）"><a href="#4-1-2-方法2：开放定址法-open-addressing-（N为链表个数，tableSize）" class="headerlink" title="4.1.2 方法2：开放定址法 open addressing （N为链表个数，tableSize）"></a>4.1.2 方法2：开放定址法 open addressing <strong>（N为链表个数，tableSize）</strong></h5></li><li>int nextPrime_oa(int N)：<strong>同nextPrime_seq</strong></li><li>int hashFuntion_oa(int key, int modValue)：<strong>hashFuntion_seq</strong></li><li>ptrToHashTable_oa createEmptyHashTable_oa(int tableSize)：<strong>同createEmptyHashTable_seq</strong></li><li>void deleteHashTable_oa(ptrToHashTable_oa H)：<strong>同deleteHashTable_seq</strong></li><li>position detect_oa(int key, ptrToHashTable_oa H, position current_pos, int collisionNum, int detectFlag)：<strong>线性检测、平方检测，O(1)/O(N)</strong></li><li>position find_oa(int key, ptrToHashTable_oa H, int detectFlag)：<strong>查找key，detect_oa下，O(1)/O(N)</strong></li><li>void insert_oa(int key, ptrToHashTable_oa H, int detectFlag)：<strong>插入key，detect_oa下，O(1)/O(N)</strong></li><li>void delete_oa(int key, ptrToHashTable_oa H, int detectFlag)：<strong>删除key，O(1)/O(N)</strong></li><li>ptrToHashTable_oa createHashTable_oa(const int key[], int N, int tableSize, int detectFlag)：<strong>再散列，O(N)</strong></li><li>ptrToHashTable_oa rehash(ptrToHashTable_oa H, int detectFlag)：<strong>再散列，O(N)</strong><h5 id="4-1-3-Others：双散列（2个散列函数）未实现，可扩散列"><a href="#4-1-3-Others：双散列（2个散列函数）未实现，可扩散列" class="headerlink" title="4.1.3 Others：双散列（2个散列函数）未实现，可扩散列"></a>4.1.3 Others：双散列（2个散列函数）未实现，可扩散列</h5></li></ul></blockquote><h3 id="5-Chapter-6"><a href="#5-Chapter-6" class="headerlink" title="5. Chapter_6"></a>5. <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/tree/master/chapter_6" target="_blank" rel="noopener">Chapter_6</a></h3><h4 id="5-1-堆（优先队列）（N为元素个数）"><a href="#5-1-堆（优先队列）（N为元素个数）" class="headerlink" title="5.1 堆（优先队列）（N为元素个数）"></a>5.1 堆（优先队列）<strong>（N为元素个数）</strong></h4><h5 id="5-1-1-二叉堆-heap-bin（数组实现，上小下大）"><a href="#5-1-1-二叉堆-heap-bin（数组实现，上小下大）" class="headerlink" title="5.1.1 二叉堆 heap_bin（数组实现，上小下大）"></a>5.1.1 二叉堆 heap_bin（数组实现，上小下大）</h5><blockquote><ul><li>PQ_bin createEmptyPQ_bin(int capacity)：<strong>构建空二叉堆，O(1)</strong></li><li>void deletePQ_bin(PQ_bin q)：<strong>删除二叉堆，O(1)</strong></li><li>bool isEmpty_bin(PQ_bin q)：<strong>判断q是否为空，O(1)</strong></li><li>bool isFull_bin(PQ_bin q)：<strong>判断q是否为满，O(1)</strong></li><li>int findMin_bin(PQ_bin q)：<strong>查找最小值，O(1)</strong></li><li>void insert_bin(int x, PQ_bin q)：<strong>插入值x，O(logN)</strong></li><li>int deleteMin_bin(PQ_bin q)：<strong>删除最小值root，O(logN)</strong></li><li>PQ_bin buildHeap_bin(const int A[], int N)：<strong>构建二叉堆，O(NlogN)</strong></li><li>int select_k(const int A[], int N, int k)：<strong>选出数组第k大的数值，O(NlogN)</strong><h5 id="5-1-2-左式堆-heap-left"><a href="#5-1-2-左式堆-heap-left" class="headerlink" title="5.1.2 左式堆 heap_left"></a>5.1.2 左式堆 heap_left</h5></li><li>bool isEmpty_left(PQ_left q)：<strong>判断q是否为空，O(1)</strong></li><li>int findMin_left(PQ_left q)：<strong>查找最小值，O(1)</strong></li><li>PQ_left merge_left(PQ_left q1, PQ_left q2)：<strong>合并q1 &amp; q2，O(logN)</strong></li><li>static PQ_left subMerge_left(PQ_left q1, PQ_left q2)：<strong>merge_left辅助函数</strong></li><li>PQ_left insert_left(int x, PQ_left q)：<strong>插入x，O(logN)</strong></li><li>PQ_left deleteMin_left(PQ_left q)：<strong>删除最小值root，O(logN)</strong></li><li>PQ_left buildHeap_left(const int A[], int N)：<strong>构建左式堆，O(NlogN)</strong><h5 id="5-1-3-斜堆-heap-left-（属于左式堆，差别：交换Npl无条件）"><a href="#5-1-3-斜堆-heap-left-（属于左式堆，差别：交换Npl无条件）" class="headerlink" title="5.1.3 斜堆 heap_left （属于左式堆，差别：交换Npl无条件）"></a>5.1.3 斜堆 heap_left （属于左式堆，差别：交换Npl无条件）</h5></li><li>bool isEmpty_skew(PQ_skew q)：<strong>判断q是否为空，O(1)</strong></li><li>int findMin_skew(PQ_skew q)：<strong>查找最小值，O(1)</strong></li><li>PQ_skew merge_skew(PQ_skew q1, PQ_skew q2)：<strong>合并q1 &amp; q2，O(logN)</strong></li><li>static PQ_skew subMerge_skew(PQ_skew q1, PQ_skew q2)：<strong>merge_skew辅助函数</strong></li><li>PQ_skew insert_skew(int x, PQ_skew q)：<strong>插入x，O(logN)</strong></li><li>PQ_skew deleteMin_skew(PQ_skew q)：<strong>删除最小值root，O(logN)</strong></li><li>PQ_skew buildHeap_skew(const int A[], int N)：<strong>构建斜堆，O(NlogN)</strong></li></ul></blockquote><h3 id="6-Chapter-7"><a href="#6-Chapter-7" class="headerlink" title="6. Chapter_7"></a>6. <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/tree/master/chapter_7" target="_blank" rel="noopener">Chapter_7</a></h3><h4 id="6-1-排序算法-（N为元素个数）（平均大O）"><a href="#6-1-排序算法-（N为元素个数）（平均大O）" class="headerlink" title="6.1 排序算法 （N为元素个数）（平均大O）"></a>6.1 排序算法 <strong>（N为元素个数）</strong>（平均大O）</h4><blockquote><ul><li>void insert_sort(int A[], int N)：<strong>插入排序，O(N^2)</strong></li><li>void shell_sort(int A[], int N)：<strong>希尔排序，O(N^1.5-2)</strong></li><li>void heap_sort(int A[], int N)：<strong>堆排序，O(NlogN)</strong></li><li>void merge_sort(int A[], int N)：<strong>归并排序，O(NlogN)</strong></li><li>void quick_sort(int A[], int N)：<strong>快速排序，O(NlogN)</strong></li><li>void bubble_sort(int A[], int N)：<strong>冒泡排序，O(N^2)</strong></li><li>void selection_sort(int A[], int N)：<strong>选择排序，O(N^2)</strong></li></ul></blockquote><h3 id="7-Chapter-8"><a href="#7-Chapter-8" class="headerlink" title="7. Chapter_8"></a>7. <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/tree/master/chapter_8" target="_blank" rel="noopener">Chapter_8</a></h3><h4 id="7-1-并查集（不相交集）（N为NUMSETS，预设集合size）"><a href="#7-1-并查集（不相交集）（N为NUMSETS，预设集合size）" class="headerlink" title="7.1 并查集（不相交集）（N为NUMSETS，预设集合size）"></a>7.1 并查集（不相交集）<strong>（N为NUMSETS，预设集合size）</strong></h4><blockquote><ul><li>int<em> createEmptySet()：<em>*构建空集，O(N)</em></em></li><li>void union1_set(int<em> s, int root1, int root2)：<em>*union-any，O(1)</em></em></li><li>void union2_set(int<em> s, int root1, int root2)：<em>*union-by-size，O(1)</em></em></li><li>void union3_set(int<em> s, int root1, int root2)：<em>*union-by-height，O(1)</em></em></li><li>int find_set(int<em> s, int value)：<em>*查找value所在集合index，O(value)</em></em></li></ul></blockquote><h3 id="8-Chapter-9"><a href="#8-Chapter-9" class="headerlink" title="8. Chapter_9"></a>8. <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/tree/master/chapter_9" target="_blank" rel="noopener">Chapter_9</a></h3><h4 id="8-1-图论-（-V-为点数，-E-为边数）"><a href="#8-1-图论-（-V-为点数，-E-为边数）" class="headerlink" title="8.1 图论 （|V|为点数，|E|为边数）"></a>8.1 图论 <strong>（|V|为点数，|E|为边数）</strong></h4><blockquote><ul><li>ptrToAdjList_DAG createGraph_adjList(int option, int v_num)：<strong>建图，邻接表，O(|V|+|E|)</strong></li><li>ptrToAdjMatrix_DAG createGraph_adjMatrix(int option, int v_num)：<strong>建图，邻接矩阵，O(|V|^2)</strong></li><li>int<em> getIndegree_adjList(ptrToAdjList_DAG adj_list, int v_num)：<em>*获取入度数组，邻接表，O(|E|)</em></em></li><li>int<em> getIndegree_adjMatrix(ptrToAdjMatrix_DAG adj_matrix, int v_num)：<em>*获取入度数组，邻接矩阵，O(|V|^2)</em></em></li><li>Vertex findNewVertexOfIndegreeZero(IndegreeMap indegree_map)：<strong>找到第一个入度为0的点，O(|V|)</strong></li><li>TopSorted_name_vector topSort(ptrToAdjList_DAG adj_list)：<strong>拓扑排序，DAG，O(|E|)</strong></li><li>DistVector createDistVector(ptrToAdjList_DAG adj_list, int targetV)：<strong>构建距离表，O(|V|)</strong></li><li>DistVector findMinPath_unweighted_1(ptrToAdjList_DAG adj_list, int targetV)：<strong>最短路径算法（uW-DAG）版本1，O(|V|^2)</strong></li><li>DistVector findMinPath_unweighted_2(ptrToAdjList_DAG adj_list, int targetV)：<strong>最短路径算法（uW-DAG）版本2，O(|E| + |V|)，BFS</strong></li><li>DistVector findMinPath_weighted(ptrToAdjList_DAG adj_list, int targetV)：<strong>最短路径算法（W-DAG），Dijkstra，O(|V|^2 + |E|)</strong></li><li>DistVector findMinPath_weighted_negative(ptrToAdjList_DAG adj_list, int targetV)：<strong>最短路径算法（nW-DAG），Bellman-Ford，O(|V| * |E|)</strong></li><li>tree_MST_Prim buildMST_Prim(ptrToAdjList_uDAG adj_list, int targetV)：<strong>最小生成树算法Prim，O(|V|^2)</strong></li><li>tree_MST_Kruskal buildMST_Kruskal(ptrToAdjList_uDAG adj_list)：<strong>最小生成树算法Kruskal，O(|E|log|E|)</strong></li><li>Vertex_vector GraphTraversal_BFS(ptrToAdjList adj_list, int targetV)：<strong>广度优先遍历BFS，O(|E| + |V|)</strong></li><li>Vertex_vector GraphTraversal_DFS(ptrToAdjList adj_list, int targetV)：<strong>深度优先遍历DFS，O(|E| + |V|)</strong></li></ul></blockquote><h3 id="9-Chapter-10"><a href="#9-Chapter-10" class="headerlink" title="9. Chapter_10"></a>9. <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/tree/master/chapter_10" target="_blank" rel="noopener">Chapter_10</a></h3><h4 id="9-1-算法设计技巧"><a href="#9-1-算法设计技巧" class="headerlink" title="9.1 算法设计技巧"></a>9.1 算法设计技巧</h4><h5 id="9-1-1-Greedy-Algorithm-贪婪算法"><a href="#9-1-1-Greedy-Algorithm-贪婪算法" class="headerlink" title="9.1.1 Greedy Algorithm 贪婪算法"></a>9.1.1 Greedy Algorithm 贪婪算法</h5><h6 id="1-霍夫曼码"><a href="#1-霍夫曼码" class="headerlink" title="(1) 霍夫曼码"></a>(1) 霍夫曼码</h6><blockquote><ul><li>tree_Huffman buildHuffmanTree(SymbolTable T)：<strong>构建霍夫曼树，O(N)</strong></li><li>HuffmanCodeTable buildHuffmanCodeTable(tree_Huffman treeH)：<strong>构建霍夫曼编码表，O(logN)</strong><h6 id="2-近似装箱问题"><a href="#2-近似装箱问题" class="headerlink" title="(2) 近似装箱问题"></a>(2) 近似装箱问题</h6></li><li>Bins solveBMPOnline_nextFit(const double A[], int N)：<strong>下项适合算法，O(N)</strong></li><li>Bins solveBMPOnline_firstFit(const double A[], int N)：<strong>首次适合算法，O(N^2)</strong></li><li>Bins solveBMPOnline_bestFit(const double A[], int N)：<strong>最佳适合算法，O(N^2)</strong><h5 id="9-1-2-Divide-amp-Conquer-分治算法"><a href="#9-1-2-Divide-amp-Conquer-分治算法" class="headerlink" title="9.1.2 Divide &amp; Conquer 分治算法"></a>9.1.2 Divide &amp; Conquer 分治算法</h5><h6 id="1-最近点问题"><a href="#1-最近点问题" class="headerlink" title="(1) 最近点问题"></a>(1) 最近点问题</h6></li><li>double getMinimumPoints(Points points_vector, Point &amp;a, Point &amp;b)：<strong>原算法O(NlogN)，本代码getMinimumPoints_sub未进一步优化</strong><h6 id="2-矩阵乘法"><a href="#2-矩阵乘法" class="headerlink" title="(2) 矩阵乘法"></a>(2) 矩阵乘法</h6></li><li>Matrix matrix_mul_origin(Matrix A, Matrix B, int rowA, int colA, int rowB, int colB)：<strong>矩阵乘法定义，O(N^3)</strong><h6 id="3-随机化算法-Random-Algorithms"><a href="#3-随机化算法-Random-Algorithms" class="headerlink" title="(3) 随机化算法 Random Algorithms"></a>(3) 随机化算法 Random Algorithms</h6></li><li>double getRandom()：<strong>获取随机数，O(1)</strong></li></ul></blockquote><h2 id="4、ToDo-list-may-be…"><a href="#4、ToDo-list-may-be…" class="headerlink" title="4、ToDo list(may be…)"></a>4、ToDo list(may be…)</h2><p>基本的数据结构和算法实现都过了一遍，然而这东西不多看的话，肯定会忘。所以，刷leetcode也是必须的。考虑以后可能会，每一章按主题来写些总结回顾下，这样也能加深记忆，不过也要看时间吧。。。毕竟总结也十分耗时间，只不过重温的收获应该会多点罢了。</p><blockquote><ul><li>刷leetcode</li><li>每一章按主题写总结文</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构&amp;算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 数据结构&amp;算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我所喜欢的句子</title>
      <link href="/2019/05/05/%E6%88%91%E6%89%80%E5%96%9C%E6%AC%A2%E7%9A%84%E5%8F%A5%E5%AD%90/"/>
      <url>/2019/05/05/%E6%88%91%E6%89%80%E5%96%9C%E6%AC%A2%E7%9A%84%E5%8F%A5%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>收集个人喜欢的句子，不限于歌词、台词 etc.</p><blockquote><p>Keep updating…</p><ul><li>1 =&gt; 歌词</li><li>2 =&gt; 电影台词</li><li>3 =&gt; 书籍</li><li>4 …</li></ul><h4 id="2017-10-19"><a href="#2017-10-19" class="headerlink" title="2017/10/19"></a>2017/10/19</h4><blockquote><p>谁也讲气候回暖，原来是冷在情天——<em>张敬轩《摄氏零度》 <1></1></em></p><p>何解初初都是漂亮，何解初初双眼善良——<em>周柏豪《还记得》 <1></1></em></p><p>谁都辛酸过，哪个没有——<em>陈奕迅《葡萄成熟时》 <1></1></em></p><p>那动人时光，不用常会看；最动人时光，未必地老天荒——<em>麦浚龙/谢安琪《罗生门》 <1></1></em></p><p>为何旧知己，在最后变不到老友；来年陌生的，是昨日最亲的某某——<em>陈奕迅《最佳损友》 <1></1></em></p><p>其实，人生并非虚耗，何来尘埃飞舞——<em>陈奕迅《沙龙》 <1></1></em></p><p>任何密友任何伴侣和谐互斗投缘互信尊重退缩生疏挂心忽近又远跟世态摇摆，见惯不会怪——<em>张敬轩《不吐不快》 <1></1></em></p><p>行前行后只差一线；回头学会珍惜今天，无暇停下表演幽怨——<em>Swing《那边见》 <1></1></em></p><p>我未似从前幼稚，我在找天生意义——<em>周柏豪《小白》 <1></1></em></p><p>无聊时欢喜在忙时忘记，生命沉闷亦玩过游戏——<em>陈奕迅《失忆蝴蝶》 <1></1></em></p></blockquote><h4 id="2017-10-20"><a href="#2017-10-20" class="headerlink" title="2017/10/20"></a>2017/10/20</h4><blockquote><p>谁料你，谁料我，能合作到爱死对方；应该不止一次幻想怎么逃亡——<em>陈奕迅《斯德哥尔摩情人》 <1></1></em></p></blockquote><h4 id="2017-10-21"><a href="#2017-10-21" class="headerlink" title="2017/10/21"></a>2017/10/21</h4><blockquote><p>年轻人，就应该多听音乐，才不会胡思乱想。他们不听音乐，抽烟，是坏人——<em>黄秋生（片中是叶湘伦&lt;周杰伦饰演&gt;的父亲）《不能说的秘密》 <2></2></em></p></blockquote><h4 id="2017-10-22"><a href="#2017-10-22" class="headerlink" title="2017/10/22"></a>2017/10/22</h4><blockquote><p>我说自尊啊，看起来或许可笑，但它至少撑着我不让我跌倒；活着，如果只是不甘寂寞的喧嚣，那就咆哮吧，让每个人都能听得到——<em>周杰伦《逆鳞》 <1></1></em></p></blockquote><h4 id="2017-10-28"><a href="#2017-10-28" class="headerlink" title="2017/10/28"></a>2017/10/28</h4><blockquote><p>一起这种艺术，若果只是漫长忍让，应感激忠心的伴侣——<em>陈奕迅《远在咫尺》 <1></1></em></p></blockquote><h4 id="2017-11-12"><a href="#2017-11-12" class="headerlink" title="2017/11/12"></a>2017/11/12</h4><blockquote><p>死亡迟早来找你，切勿凭自己——<em>陈奕迅《黑择明》 <1></1></em></p></blockquote><h4 id="2017-11-16"><a href="#2017-11-16" class="headerlink" title="2017/11/16"></a>2017/11/16</h4><blockquote><p>在有生的瞬间能遇到你，竟花光所有运气——<em>陈奕迅《明年今日》 <1></1></em></p></blockquote><h4 id="2017-11-18"><a href="#2017-11-18" class="headerlink" title="2017/11/18"></a>2017/11/18</h4><blockquote><p>得飘，得飘，得咿的飘——<em>周杰伦《漂移》 <1></1></em></p></blockquote><h4 id="2017-11-24"><a href="#2017-11-24" class="headerlink" title="2017/11/24"></a>2017/11/24</h4><blockquote><p>最可笑的，喊亦正常；最悲壮的，笑亦正常；哪一个可，发育正常——<em>陈奕迅《六月飞霜》 <1></1></em></p></blockquote><h4 id="2019-1-2"><a href="#2019-1-2" class="headerlink" title="2019/1/2"></a>2019/1/2</h4><blockquote><p>感谢你，仍然热爱广东歌——<em>年粤日记 2018 <3></3></em></p></blockquote><h4 id="2019-3-7"><a href="#2019-3-7" class="headerlink" title="2019/3/7"></a>2019/3/7</h4><blockquote><p>谈恋爱，游天地，做喜欢的工作和享受游戏——<em>陈奕迅《怕死》 <1></1></em></p><p>活得精彩结尾切勿流眼泪；开心的派对，散后无法聚——<em>陈奕迅《最后派对》 <1></1></em></p><p>有事钟无艳，无事夏迎春——<em>《钟无艳》 <2></2></em></p></blockquote><h4 id="2019-5-5"><a href="#2019-5-5" class="headerlink" title="2019/5/5"></a>2019/5/5</h4><blockquote><p>紅色藍色白色霧色月色 還有粉紅色——<em>《美孚新村上春树》 <1></1></em></p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> Songs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《统计学习方法-李航》Python实现</title>
      <link href="/2019/02/14/%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%9D%8E%E8%88%AA%E3%80%8BPython%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/02/14/%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%9D%8E%E8%88%AA%E3%80%8BPython%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Statical-Learning-Method-LiHang-py-Eajack"><a href="#Statical-Learning-Method-LiHang-py-Eajack" class="headerlink" title="Statical-Learning-Method-LiHang_py_Eajack"></a>Statical-Learning-Method-LiHang_py_Eajack</h1><h2 id="1、运行环境"><a href="#1、运行环境" class="headerlink" title="1、运行环境"></a>1、运行环境</h2><blockquote><ul><li>Windows or Linux</li><li>Python3.5.2(Python 3.x.x)</li></ul></blockquote><h2 id="2、第三方库汇总"><a href="#2、第三方库汇总" class="headerlink" title="2、第三方库汇总"></a>2、第三方库汇总</h2><blockquote><ul><li>matplotlib</li><li>numpy</li><li>sklearn</li><li>pandas</li></ul></blockquote><h2 id="3、参考资料"><a href="#3、参考资料" class="headerlink" title="3、参考资料"></a>3、参考资料</h2><blockquote><ul><li>《统计学习方法-李航》</li><li>《机器学习实战》</li><li>Google</li></ul></blockquote><h2 id="4、代码说明"><a href="#4、代码说明" class="headerlink" title="4、代码说明"></a>4、代码说明</h2><p>只用py实现第1章-第8章，第9章-第11章，由于个人时间、章节难度&amp;意志（说白了，就是看到第8章时，刚好隔了一段时间玩了，重新捡起时不想看了…）原因，未完成py实现（之前想的C/C++版就…算了吧）</p><p>大致介绍下每章节代码（部分章节的部分内容，未实现）</p><ol><li><a href="https://github.com/Eajack/-Statical-Learning-Method-LiHang-_py_Eajack/tree/master/Chapter_1" target="_blank" rel="noopener">Chapter_1</a><blockquote><ul><li>最小二乘法（Least Square Method）的单变量&amp;多变量版本</li><li>正则化L2</li><li>PS：正则化L1未实现</li></ul></blockquote></li><li><a href="https://github.com/Eajack/-Statical-Learning-Method-LiHang-_py_Eajack/tree/master/Chapter_2" target="_blank" rel="noopener">Chapter_2</a><blockquote><ul><li>感知机（Perceptron）的原始形式&amp;对偶形式</li></ul></blockquote></li><li><a href="https://github.com/Eajack/-Statical-Learning-Method-LiHang-_py_Eajack/tree/master/Chapter_3" target="_blank" rel="noopener">Chapter_3</a><blockquote><ul><li>KNN（线性扫描&amp;kd树版本）</li></ul></blockquote></li><li><a href="https://github.com/Eajack/-Statical-Learning-Method-LiHang-_py_Eajack/tree/master/Chapter_4" target="_blank" rel="noopener">Chapter_4</a><blockquote><ul><li>朴素贝叶斯（Naive Bayes）</li><li>贝叶斯估计（lambda = 1，又称“拉普拉斯平滑”，Laplace Smoothing）</li></ul></blockquote></li><li><a href="https://github.com/Eajack/-Statical-Learning-Method-LiHang-_py_Eajack/tree/master/Chapter_5" target="_blank" rel="noopener">Chapter_5</a><blockquote><ul><li>ID3决策树，生成、分类</li><li>C4.5决策树，生成、分类</li><li>CART决策树，生成、分类、剪枝</li></ul></blockquote></li><li><a href="https://github.com/Eajack/-Statical-Learning-Method-LiHang-_py_Eajack/tree/master/Chapter_6" target="_blank" rel="noopener">Chapter_6</a><blockquote><ul><li>Logistic回归</li><li>梯度下降法（Gradient Descent,GD）：随机GD（stochastic，SGD）、批量GD（Batch GD）、小批量GD（mini-batch，MBGD）</li><li>PS：本章还有最大熵模型、拟牛顿法&amp;改进的迭代尺度法（imporoved iterative scaling，IIS）未实现</li></ul></blockquote></li><li><a href="https://github.com/Eajack/-Statical-Learning-Method-LiHang-_py_Eajack/tree/master/Chapter_7" target="_blank" rel="noopener">Chapter_7</a><blockquote><ul><li>线性可分SVM（Linear Support Vector Machine in Linearly Separable Case，LSVML）</li><li>序列最小最优化算法（Sequence Minimal Optimization，SMO）</li><li>PS：SVM还包括线性SVM、非线性SVM，未实现。与LSVML思路大致相同，不同于前二者分别引入惩罚系数C、惩罚系数C&amp;核函数</li></ul></blockquote></li><li><a href="https://github.com/Eajack/-Statical-Learning-Method-LiHang-_py_Eajack/tree/master/Chapter_8" target="_blank" rel="noopener">Chapter_8</a><blockquote><ul><li>Adaboost</li><li>PS：未实现提升树</li></ul></blockquote></li><li>Chapter_9 ~ Chapter_11：<blockquote><ul><li>EM&amp;GEM</li><li>隐马尔科夫模型（只略看数学原理）</li><li>条件随机场（未看）</li></ul></blockquote></li><li><a href="https://github.com/Eajack/-Statical-Learning-Method-LiHang-_py_Eajack/tree/master/Extra-MLinAction" target="_blank" rel="noopener">Extra-MLinAction</a><blockquote><ul><li>Kmeans（《机器学习方法》挑的实现章节）</li></ul></blockquote></li></ol><h2 id="5、最后一点"><a href="#5、最后一点" class="headerlink" title="5、最后一点"></a>5、最后一点</h2><p>代码仅供参考，质量一般。这书若每天腾空专心看，大致需耗时2个月可看完，并py代码实现。（C/C++就不一定了，矩阵运算等库可能没py方便）</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
            <tag> 机器学习算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018结束了</title>
      <link href="/2019/01/03/2018%E7%BB%93%E6%9D%9F%E4%BA%86/"/>
      <url>/2019/01/03/2018%E7%BB%93%E6%9D%9F%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>18年终于过了，本想迟点再写总结的，发现去年是19号写的。但是，为什么要延迟呢？其实不是因为实在没空，我知道的，是因为我不想再重新面对2018。因为这一年发生了太多太多事，无论是自己经历，还是家里的事。总之，2018，可以说，不是一个好年。</p><p>想起去年，是用了这个引子</p><blockquote><ul><li>Everyone is struggling everyday.</li></ul></blockquote><p>今年的引子是啥，现在一时没想出来。经过了这1年经历，多少有点感慨和遗憾，当然也有开心的。那就用个沙雕的引子吧，也是最近的签名，也是希望19年多点开心，可以做更多自己想做的事情。</p><p>虽然18年的某些成果勉强算是我希望的，但是这段时间付出的一些东西、做过的一些东西都不是我本意想做的。所以，十分希望，19年能做更多自己内心本身想做的东西，而不是为了某些目的而活得不开心。</p><p>有时候，沙雕快乐点比奋斗逼还要好很多。</p><blockquote><ul><li>早晨起来😀，拥抱太阳🌞</li></ul></blockquote><p>就用去年的模板好了，开始总结下这个所谓的2018。</p><h3 id="1-2018任务清单"><a href="#1-2018任务清单" class="headerlink" title="1- 2018任务清单"></a>1- 2018任务清单</h3><p>作为典型的“积极废人”（指爱给自己立flag，但永远做不到的人），2018年头，我当然是有一堆的Flags的，是延续17未完成的Flags继续做的。现在发现，去年写这总结的时候，还没总结出18年Flags，刚好最近立完19年Flags，这次就顺便把19的也放上来。</p><p>此处不把2018中后期，即10月之后才加入list的任务，放进来了，因为基本没完成，直接纳入19年Flags。</p><ul><li>2018任务清单<ol><li>书单<ul><li>《数据结构与算法分析（C语言描述）》</li><li>《大辞海-哲学卷》</li><li><del>《C++ Primer》</del></li><li><del>《Python学习手册》</del></li></ul></li><li>项目<ul><li>无人机 + 三维建模 项目</li><li>无人机基于GPS路径导航规划</li><li>利用树莓派做狗型机器人</li><li>DSP音频模拟器。将自己的声音处理转换为Eason的声音（Eason项目的一部分）</li><li>自动接垃圾的垃圾桶</li></ul></li><li>日常<ul><li>用自己的钱，淘宝买一架无人机（仅用于拍照，可附加实时传送图片功能，目的在于个人项目：无人机 + 三维重建）</li></ul></li><li>学业计划<ul><li><del>以二作发表一篇B类论文（now：3篇b类1作）</del></li><li><del>争取发一篇EI论文（A类）（now：1篇SCIE/SSCI论文，1篇EI论文）</del></li><li><del>争取申请一项专利</del></li></ul></li><li>锻炼计划<ul><li><del>稳定体重55 - 60kg（目前61.2kg，一般维持在62 - 64kg，2018/1/19）</del></li><li>瘦小腿，到30cm，大腿到45cm</li><li>跑步打卡 &gt; 200天（132天）</li></ul></li></ol></li></ul><p>可以看出2018清单里面还有很多都没完成，原因的话很大程度是因为18年一直在准备保研的事情，自然地，像项目、锻炼跑步等在后面基本都是抛弃了。这也算正常，当初可能18年年初立Flag太过匆忙，而且是寒假，当时也在忙项目什么的，Flag也是匆匆立完算了。</p><p>2019的Flag，这次要吸取17、18年教训了。例如，以下是延迟了2年都没完成的Flag</p><ul><li>2017&amp;2018 拖延任务清单<ol><li>书单<ul><li>《数据结构与算法分析（C语言描述）》 <strong><em>（19年重点完成）</em></strong></li><li>《大辞海-哲学卷》 <strong><em>（抛弃任务）</em></strong></li></ul></li><li>项目 <strong><em>（明显的，1个项目都够1年份了…当初Flags立的时候，就是一想到有idea，就加进来，明显是错误的，根本完成不了这么多。所以，先完成1个就很好了）</em></strong><ul><li>无人机 + 三维建模 项目</li><li>无人机基于GPS路径导航规划</li><li>利用树莓派做狗型机器人</li><li>DSP音频模拟器。将自己的声音处理转换为Eason的声音（Eason项目的一部分）</li><li>自动接垃圾的垃圾桶</li></ul></li><li>日常 <strong><em>（抛弃任务。该任务纳入项目里面了，因为项目idea有无人机项目，所以肯定要买机子）</em></strong><ul><li>用自己的钱，淘宝买一架无人机（仅用于拍照，可附加实时传送图片功能，目的在于个人项目：无人机 + 三维重建）</li></ul></li><li>锻炼计划 <strong><em>（对锻炼计划简单化，变成跑步）</em></strong><ul><li>瘦小腿，到30cm，大腿到45cm</li><li>跑步打卡 &gt; 200天（132天）</li></ul></li></ol></li></ul><p>现在放下19年Flags吧，图片是2018/12/29网易Flags图</p><p><div align="center"><img width="300" height="620" src="https://raw.githubusercontent.com/Eajack/Eajack.github.io/master/img/2019.1.3/2019-Flags.png" alt="2018/12/29网易Flags图"></div></p><center>图1. 2018/12/29网易Flags图</center><ul><li>🌞2019任务清单<ol><li>愿望<ul><li>2019，脱单</li><li>2019，身体健康</li></ul></li><li>日常<ul><li>跑步打卡，100 days以上</li><li>12:30 前早睡打卡，150 days以上</li></ul></li><li>书单<ul><li>《数据结构与算法分析（C语言描述）》（&amp;C/C++算法代码实现）</li><li>《统计学习方法-李航》（&amp;Python，C/C++算法代码实现）</li><li>《机器学习实战》</li><li>5本 非计算机类书籍</li></ul></li><li>代码<ul><li>刷leetcode题目</li><li>入门DL &amp; NLP，常用神经网络模型，算法，框架工具</li></ul></li><li>项目<em>（2019目标：完整完成1项）</em><ul><li>无人机基于GPS导航路径规划</li><li>无人机 + 三维建模</li><li>DSP音频模拟器：将自己声音转变成Eason声音</li><li>做一个室内能自动接垃圾的垃圾桶</li><li>NLP：生成丧话、情话</li></ul></li></ol></li></ul><h3 id="2-2018年月份总结"><a href="#2-2018年月份总结" class="headerlink" title="2- 2018年月份总结"></a>2- 2018年月份总结</h3><p>回想2018，像去年一样，想到多少写多少，但也会刻意把一些东西抹去吧。现在大致回看17年总结，大概17年阴影就是12月妈大病那次事了，其余的话，全年还是不算特别多风波，17年过得还是挺充实的。同样，18年也有阴影，但感觉是不止1个。或许，每一年都有出乎意料的几个阴影和几个月份，今年也要做好心理准备才行。毕竟，人生无常。</p><p><strong>1月</strong>延续17年12月妈的大病，1月我记得是考试周吧。考试是崩了，转的鲤鱼一点屁用都没有，崩了2科，通信原理+马哲（上午马哲，下午通信，中午没睡），搞笑的是，通信比马哲还要垃圾。我猜，应该是四年最垃圾绩点一学期，好像记得3.2来着。1月的回忆寥寥无几，应该就只是考试吧，还有就是18年美赛，美赛做完后，体验不错。第二次美赛，不是自夸，做完后我们都觉得自己做得真的好，无论是论文写作，还是模型构建等。还觉得可以冲F奖的，M奖简直是胸有成竹的自信…当然，最后也就只是个M奖，但是已经很开心了，满足了。美赛完后回家，也好彩，妈身体后来也问题不大。</p><p><strong>2月</strong>2月份寒假，我好像忘了做了什么。应该是在忙垃圾桶项目大创结题吧，然后应该是学了下Python什么的，其余还真没印象了。</p><p><strong>3~6月</strong>大三下开始，估计会是大学四年最痛苦的一个学期。这几个月做的东西，想想，可以是以下集合：准备简历 + 疯狂找&amp;投夏令营信息 + 写&amp;投论文 + 大创结项 + 日常看看课内。然而夏令营结果呵呵，只有pkusz过了，唉，说到这就是泪，这是今年的1个阴影。说到这里，到现在都还是一肚子气，真的忍不住想开骂。这段时间，我联系了那里的1位z老师，呵呵，就不说明是哪位了。当然，当时联系老师肯定是选中几个喜欢的，海投，所有学校都是这样。在所有投的老师中，只有2个老师我个人感觉比较有戏的，一个是中大电院的，另一个就是那个z老师。中大电院老师想我考试周约我见面，我当时拒绝了，因为那时候我开始立了Flag，想去z那里。和z邮件聊了几回，满心欢喜，感觉老师给的回应还算积极，也联系了往届那里的师兄和他室友（z的学生，现在wechat删了），求面经和夏令营套路。那段时间，感觉自己很顺利，就打算赌这一把，不知何时有一种：一定要去到那里的心态。之前想的是，有个不错的就行了，那时突然可能转念开始自负起来，一定要去这个（后来才觉得确实一般，有看到的，不喜勿喷。至于师资力量&amp;人品…不予置评，xzdm）。我想去那里，主要就是2个原因：牌子&amp;城市。确实，这2个因素都很喜欢，但校区很小。</p><p><strong>7月</strong>大三下期末结束，考得还算可以，没什么意外。一考完，马上飞去sz夏令营，隔天开始。夏令营碰到了一堆大佬，不，是巨佬。夏令营是辩论队形式，队里其他4个人，都是刚参加完其他夏令营过来的（唉，怪自己学校考试周这么鬼迟，真的没什么夏令营可以参加了。。）。其他4人分别是，2个天大、1个大工、1个武大，就我一个菜鸡211，2个天大分别参加完上交&amp;中科院电子所、中科院电子所夏令营；大工巨佬，参加完THU汽车学院&amp;计算法学、北大叉院，一来到滔滔不绝，虽说很牛逼，但这人人品不喜欢，就不细说了，有些人就这样，见第一面就不喜欢他了；武大妹子，中科院信工所好像，已有本校offer。今年夏令营生源还是挺不错的，都是大佬，应该救我弱鸡了。后来糊里糊涂当上队长，我们是正方，反方的人也很牛逼，中科大、大工、南理、哈工大、川大的，反正都是大佬。夏令营最值得回忆的应该是，通宵10个人，写辩论剧本，3点睡7点起，说实话，很棒的一次回忆，很久没试过这种头脑风暴了。夏令营除了辩论赛，我第一天去到下午就和z“面试”，说了想做CV，碰到ta博士生（后来加了wechat，又删了），“面试”还行，最终ta还信誓旦旦说约定好要跟ta哦，不能反悔哦，而且ta还和颜悦色。（说到这，真tm又想锤爆，疯狂骂人，wr&lt;&gt;ng不谢。因为直到最后ta才反悔，我真的rlg的运气啊。）面谈完，我真的高兴得不得了，又和好友说，又和家人说，z说9月会有个推免，但是基本没问题，往年推上去的都过了,呵x140…夏令营除了面谈、辩论，还有去鹅厂总部、深圳湾逛了一下，碰到同校2个大佬（1个最后跟z，呵呵，就叫做h吧；1个去复旦），还有就是和几个辩论队的大佬加了个q，也算是这次的一个很好的收获了，空间都有时还有互动。夏令营走的那天，下雨，但那时的我很开心，拿了老师offer，可能那雨是上天的表态，我都还不知后面发生的什么事，蒙在鼓里。</p><p><strong>8月</strong>暑假开始。暑假出现了一件很伤心的事，奶奶走了。唉，很突然，真的很突然的一次，就不细说了，保留在记忆里吧。剩下的暑假 = 科2再次挂科+ 人脸分割大创 + 部分pytorch入门 + 玩 + 准备9月校内答辩&amp;9推。</p><p><strong>9月</strong>另一件伤心事，就是在9月。我被z鸽了。9月，去北京面试，的确面的一般般，数学题做得不好，但问问题我觉得做得还是不错的…然后，我也没想啥，毕竟第一次来北京，面试也算是玩了2，3天。去了人大&amp;颐和园（人大同学带）、王府井（和h、其余面试的一起去）、逛了圈p大（的确很清朝，很适合拍照）。伤心是在我坐飞机回来的那晚，我一下飞机，打开微信，z的博士生和我说我面试有点悬，让我有可能要找下家。我当时在机场快哭出来了，和h在一起，他也在安慰我，说结果还没出啊，也可能不是的。一下飞机，我就打电话给z的博士生，聊了很久，明显地，我是被鸽了，我一直被他安慰。更可恶的是，我q上问z，一直没回复我！！！所以，直到现在，我都还十分厌恶那所学校。然而，恐怖的是，那时我根本没准备其他offer啊，有了这个其他我都没投了啊（tm现在觉得，自己当时心真的大，怕是当时被自己很想去那里的念头，一时自负&amp;高兴冲晕了头脑）。当晚住了招待所，我当晚和我妈聊了下，就和1个好友一直聊，聊到2点。躺在床上，我想着，sl，一切都重头来过了，快6个月的努力白费了。好友和我妈一直安慰我，我不知为什么哭不出来，我当时很困，记得聊了很多，一直在骂一直在骂，好友也是一直骂。但是，都成事实了。没办法，我还是睡了。本来第二天中秋，和另一班好友聚会的，然而哪有什么心情，7点起床马上坐早班车回学校，因为我还要忍痛准备其他学校9推，也就是最后机会。回了校，当我和好友提起，终于忍不住了，我哭了，稀里糊涂，哭了好久，好友陪我去吃饭。真心感谢sl、sz那两天的帮助。sz说，别哭，想下我，被10几个学校拒夏令营的人；要做的是，抓紧机会，还有9推。他说的很平淡，我努力抑制情绪波动，那时真的很佩服他。之后几天23-30号一周，看着别人都拿了offer，我仍在继续投学校，十分幸运保研群有人说hust有导师还有名额，这消息还是我另一个同学和我说的。我当时只是抱着试一下的心态投，电话面试，谁知最后过了。9推，报了3个志愿，都中了，hust计院（最早offer，最终选择）、中大电院（比hust迟一点，拒了offer，因为这个院做硬件、通信多，不喜欢这个）、中大智能工程（拒了复试，但是面试官还催我去，怕是今年竞争不激烈，加上这是新院），其实还有中大电通（新院，后来催我，我说有了offer就没下文）。其实吧，选择也不多，当时还以为还可以选下华工的，但系统只有3个选项，也就那样了，满足吧。只是，z给我留下的阴影，是18年一大阴影。</p><p><div align="center"><img width="400" height="470" src="https://raw.githubusercontent.com/Eajack/Eajack.github.io/master/img/2019.1.3/2018-保研.jpg" alt="2018-保研"></div></p><center>图2. 2018-保研</center><p><strong>10月</strong>10月国庆，总算尘埃落定。玩了1个国庆，师兄说让我国庆过后尽早过去搬砖，我也知道的，所有研究生导师都这样，廉价劳动力…但学校这边还有课，就把这个推到了11月。10月基本都是玩，咸鱼，不再去想z那件破事，开始刷火影（昨天刚刷到300集，阿斯玛走了，唉）。</p><p><strong>11月</strong>11月，是属于华科的。一整个月去武汉搬砖，认识了师姐，初次接触同级的2个（原来他们早来搬砖了）。第一天去到是周五，周六实验室聚餐，被迫喝了2罐黑啤，跟师兄师姐看夜场电影《无双》，当晚2点才睡…这个月，搬砖之余，和师兄师姐去浪了一共3次，第二遍看完《机器学习-周志华》前10章。开始从CVer =&gt; NLPer。</p><center class="half">    <img width="320" height="190" src="https://raw.githubusercontent.com/Eajack/Eajack.github.io/master/img/2019.1.3/2018-11-hust-1.jpg" alt="2018-11-hust-1" hspace="10"><img width="320" height="190" src="https://raw.githubusercontent.com/Eajack/Eajack.github.io/master/img/2019.1.3/2018-11-hust-2.jpg" alt="2018-11-hust-2"></center><center>图3. 2018-11月HUST</center><p><strong>12月</strong>12月，搬砖回来了。继续上课，好像就没啥大事了。刷完《统计学习方法-李航》前5章&amp;Python代码算法实现，接着就是和考完研的好友吃喝玩乐，跨年饭。</p><p>2018完了，这年过得比17年更曲折、惊心动魄。也不想多去想18年的事，最重要是把握现在。过去固然是要回顾，但回顾的作用是以史为鉴，不要再去重新犯错，回顾完之后就继续前行吧，不能一直停留在过去，不管是悲痛的过去还是欢笑的过去。</p><h3 id="3-2019-amp-遐想"><a href="#3-2019-amp-遐想" class="headerlink" title="3- 2019 &amp; 遐想"></a>3- 2019 &amp; 遐想</h3><p>2019来了，我希望这一年能有所变化，能做更多自己本心想做的事。</p><p>去年这段话</p><blockquote><p>这一年，应该是大学最艰难的一年了吧。既然你选择了想要保研这条路，那这一年的所有将会是你大学期间另一个最有怀念价值的拼搏时期。尽我全力，破釜沉舟，背水一战，只求今年9月笑逐颜开。2018年，希望，你做好充分准备，心理准备。</p></blockquote><p>17年的自己，真不好意思，18年多少是有遗憾的。但，这一年的努力、坚持的收获永远都值得回忆。</p><ul><li>遐想</li></ul><p>也是保研过了后，会想得越来越宽，想以后能做更多自己原本就想做的事，例如想第一次去录音棚录歌；想开始规划毕业后先搬砖几年攒钱，之后考虑出国读个博（?，当然时间短是第一要求），或者尝试换一种生活方式，可不想一直上班搬砖到老吧，但要看自己有没有这种勇气了；想工作攒钱，以后能有个自己喜欢的人，一起环游世界（hhh）。</p><p>所以说，还是要先搬砖、攒钱，当然也要考虑房子、人生大事等一堆事。现实就是，万事都离不开💴。与其说是抛弃理想主义，不如说是拥抱实用主义。至少在我目前阅历来说，这句话准确度是很高的，毕竟我也不是什么富二代。在社会，生存是首位。</p><p>不过，我想自己是不会走学术这条路的，之前是这样想，现在也是。这也是为什么我前面说“但是这段时间付出的一些东西、做过的一些东西都不是我本意想做的”，说的其实有一部分就是在为保研弄的东西，沾染了功利性和被迫于现实的一些东西，不是说道德意义上的东西（这个是没有涉及到的…），只是有时感觉，有些东西太过功利了吧。说是这样说，但也不担保以后的自己会不会还是这样，只是目的换成了另一个。</p><p>正如Eason一首歌《然后怎样》的歌词</p><blockquote><p>我最初只贪玩，为何变负担</p></blockquote><p>讲多无谓，加油！</p>]]></content>
      
      
      <categories>
          
          <category> 鸡汤 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸡汤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub-repo收藏（updating）</title>
      <link href="/2019/01/01/GitHub-repo%E6%94%B6%E8%97%8F%EF%BC%88updating%EF%BC%89/"/>
      <url>/2019/01/01/GitHub-repo%E6%94%B6%E8%97%8F%EF%BC%88updating%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>个人在GitHub上面，发现感觉有用的repo分类集合<br>keep updating~<br> <strong>updated on 2019/1/1</strong></p><h2 id="1-Python爬虫"><a href="#1-Python爬虫" class="headerlink" title="1- Python爬虫"></a>1- Python爬虫</h2><blockquote><ul><li><a href="https://github.com/facert/awesome-spider" target="_blank" rel="noopener">各类爬虫代码收集（awesome-spider）</a></li><li><a href="https://github.com/yhangf/PythonCrawler" target="_blank" rel="noopener">Python爬虫集合（PythonCrawler）</a></li></ul></blockquote><h2 id="2-CS竞赛"><a href="#2-CS竞赛" class="headerlink" title="2- CS竞赛"></a>2- CS竞赛</h2><blockquote><ul><li><a href="https://github.com/iphysresearch/DataSciComp" target="_blank" rel="noopener">数据科学竞赛-整理（Data Science Competitions）</a></li></ul></blockquote><h2 id="3-数据集"><a href="#3-数据集" class="headerlink" title="3- 数据集"></a>3- 数据集</h2><h3 id="3-1-杂乱数据集"><a href="#3-1-杂乱数据集" class="headerlink" title="3.1- 杂乱数据集"></a>3.1- 杂乱数据集</h3><blockquote><ul><li><a href="https://github.com/awesomedata/awesome-public-datasets" target="_blank" rel="noopener">各领域公开数据集（Awesome Public Datasets）</a></li></ul></blockquote><h2 id="4-DL-大杂烩"><a href="#4-DL-大杂烩" class="headerlink" title="4- DL 大杂烩"></a>4- DL 大杂烩</h2><h3 id="4-1-大杂烩"><a href="#4-1-大杂烩" class="headerlink" title="4.1- 大杂烩"></a>4.1- 大杂烩</h3><blockquote><ul><li><a href="https://github.com/ChristosChristofidis/awesome-deep-learning" target="_blank" rel="noopener">深度学习各类书籍、教程、项目、数据集&amp;论文 etc.（Awesome Deep Learning）</a></li></ul></blockquote><h3 id="4-2-教程"><a href="#4-2-教程" class="headerlink" title="4.2- 教程"></a>4.2- 教程</h3><blockquote><ul><li><a href="https://github.com/fengdu78/deeplearning_ai_books" target="_blank" rel="noopener">吴恩达DL课程笔记&amp;资源（deeplearning_ai_books）</a></li></ul></blockquote><h2 id="5-ML-大杂烩"><a href="#5-ML-大杂烩" class="headerlink" title="5- ML 大杂烩"></a>5- ML 大杂烩</h2><h3 id="5-1-ML学术"><a href="#5-1-ML学术" class="headerlink" title="5.1- ML学术"></a>5.1- ML学术</h3><blockquote><ul><li><a href="https://github.com/RedditSota/state-of-the-art-result-for-machine-learning-problems" target="_blank" rel="noopener">ML学术前沿进展（state-of-the-art-result-for-machine-learning-problems）</a></li></ul></blockquote><h3 id="5-2-教程"><a href="#5-2-教程" class="headerlink" title="5.2- 教程"></a>5.2- 教程</h3><blockquote><ul><li><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener">斯坦福大学2014（吴恩达）机器学习教程中文笔记</a></li><li><a href="https://github.com/wzyonggege/statistical-learning-method" target="_blank" rel="noopener">《统计学习方法》笔记-基于Python算法实现 </a></li></ul></blockquote><h2 id="6-自然语言处理NLP"><a href="#6-自然语言处理NLP" class="headerlink" title="6- 自然语言处理NLP"></a>6- 自然语言处理NLP</h2><h3 id="6-1-NLP大杂烩"><a href="#6-1-NLP大杂烩" class="headerlink" title="6.1- NLP大杂烩"></a>6.1- NLP大杂烩</h3><blockquote><ul><li><a href="https://github.com/fighting41love/funNLP" target="_blank" rel="noopener">各类NLP算法、数据库etc.</a></li><li><a href="https://github.com/crownpku/Awesome-Chinese-NLP" target="_blank" rel="noopener">中文NLP资源：Awesome-Chinese-NLP</a></li></ul></blockquote><h3 id="6-2-NLP学术"><a href="#6-2-NLP学术" class="headerlink" title="6.2- NLP学术"></a>6.2- NLP学术</h3><blockquote><ul><li><a href="https://github.com/sebastianruder/NLP-progress" target="_blank" rel="noopener">NLP-progress</a></li></ul></blockquote><h3 id="6-3-NLP工程"><a href="#6-3-NLP工程" class="headerlink" title="6.3- NLP工程"></a>6.3- NLP工程</h3><blockquote><ul><li><a href="https://github.com/google-research/bert" target="_blank" rel="noopener">谷歌bert</a></li><li><a href="https://github.com/HIT-SCIR/ltp" target="_blank" rel="noopener">哈工大LTP</a></li><li><a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">SnowNLP库，中文电商情感分析库</a></li><li><a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">jieba库，中文分词库</a></li></ul></blockquote><h3 id="6-4-NLP-情感分析"><a href="#6-4-NLP-情感分析" class="headerlink" title="6.4- NLP-情感分析"></a>6.4- NLP-情感分析</h3><blockquote><ul><li><a href="https://github.com/rainarch/SentiBridge" target="_blank" rel="noopener">SentiBridge: 中文实体情感知识库</a></li></ul></blockquote><h2 id="7-编程语言"><a href="#7-编程语言" class="headerlink" title="7- 编程语言"></a>7- 编程语言</h2><h3 id="7-1-C语言"><a href="#7-1-C语言" class="headerlink" title="7.1- C语言"></a>7.1- C语言</h3><blockquote><ul><li><a href="https://github.com/jobbole/awesome-c-cn" target="_blank" rel="noopener">C 语言资源大全中文版</a></li></ul></blockquote><h2 id="8-工作"><a href="#8-工作" class="headerlink" title="8- 工作"></a>8- 工作</h2><blockquote><ul><li><a href="https://github.com/kdn251/interviews" target="_blank" rel="noopener">CS工作面试所需知识（interviews）</a></li></ul></blockquote><h2 id="9-书籍、教程-etc"><a href="#9-书籍、教程-etc" class="headerlink" title="9- 书籍、教程 etc."></a>9- 书籍、教程 etc.</h2><blockquote><ul><li><a href="https://github.com/yuanliangding/books" target="_blank" rel="noopener">各类书籍（books）</a></li><li><a href="https://github.com/tuteng/Best-websites-a-programmer-should-visit-zh" target="_blank" rel="noopener">程序员应该访问的最佳网站（中文版）</a></li><li><a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">免费的编程中文书籍索引</a></li><li><a href="https://github.com/prakhar1989/awesome-courses" target="_blank" rel="noopener">Awesome CS Courses</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub-repo收藏分类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>py3爬虫项目</title>
      <link href="/2018/06/20/py3%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE/"/>
      <url>/2018/06/20/py3%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>Github repo地址：<a href="https://github.com/Eajack/py_spider" target="_blank" rel="noopener">py_spider</a><br>欢迎各路大神在issues里面提供ideas，欢迎fork &amp; star</p><h2 id="1、运行环境"><a href="#1、运行环境" class="headerlink" title="1、运行环境"></a>1、运行环境</h2><blockquote><ul><li>Windows or Linux</li><li>Python3.5.2(Python 3.x.x)</li></ul></blockquote><h2 id="2、内置库汇总"><a href="#2、内置库汇总" class="headerlink" title="2、内置库汇总"></a>2、内置库汇总</h2><blockquote><ul><li>urllib</li><li>re,os,time</li><li>json</li></ul></blockquote><h2 id="3、第三方库汇总"><a href="#3、第三方库汇总" class="headerlink" title="3、第三方库汇总"></a>3、第三方库汇总</h2><blockquote><ul><li>bs4(BeautifulSoup)</li><li>requests</li><li>selenium</li><li>jieba</li><li>wordcloud</li><li>matplotlib</li><li>scipy</li><li>snownlp</li><li>xlwt</li><li>xlrd</li><li>[updating…]</li></ul></blockquote><h2 id="4、爬虫说明"><a href="#4、爬虫说明" class="headerlink" title="4、爬虫说明"></a>4、爬虫说明</h2><blockquote><ul><li><a href="https://github.com/Eajack/py_spider/blob/master/%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB/computer_books.py" target="_blank" rel="noopener">computer_books.py</a>：豆瓣”世界著名计算机教材节选”爬虫</li><li><a href="https://github.com/Eajack/py_spider/blob/master/%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB/Eason_Film.py" target="_blank" rel="noopener">Eason_Film.py</a>：豆瓣”Eason电影”爬虫（收到知乎网友反映“无法爬取”，经检查发现豆瓣网页HTML结构改版…该代码已不能爬取，考虑有空再重写……）</li><li><a href="https://github.com/Eajack/py_spider/blob/master/%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB/emojiCrawler.py" target="_blank" rel="noopener">emojiCrawler.py</a>：<a href="http://emojipedia.org/" target="_blank" rel="noopener">emoji官网</a>爬虫，按官网分类爬取所有不同版本的emoji.png图片（eg:Apple,Samsung.Google etc.)</li><li><a href="https://github.com/Eajack/py_spider/blob/master/%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB/wiki_6DegreeSeperation.py" target="_blank" rel="noopener">wiki_6DegreeSeperation.py</a>：wiki爬虫，广度优先遍历，为证明“六度分割理论”，暂时只能尝试，并非完全证明</li><li><a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/EasonLyrics_README.md" target="_blank" rel="noopener">music163_EasonLyrics</a>：网易云Eason所有歌词爬虫 + 文本分析，详见<a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/EasonLyrics_README.md" target="_blank" rel="noopener">EasonLyrics_README</a></li><li><a href="https://github.com/Eajack/py_spider/blob/master/%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB/getCity.py" target="_blank" rel="noopener">getCity.py</a>：基于谷歌地图API简单爬虫，通过经纬度查询该地点所属城市</li><li><a href="https://github.com/Eajack/py_spider/tree/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments" target="_blank" rel="noopener">music163_EasonComments</a>：网易云Eason所有单曲评论数排行、最新10条评论抓取 &amp; 热门评论文本分析,详见<a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/EasonComments_README.md" target="_blank" rel="noopener">EasonComments_README</a></li><li><a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_autoSignIn.py" target="_blank" rel="noopener">music163_autoSignIn.py</a>：网易云音乐网页端，每天定时自动签到（windows）</li><li><a href="https://github.com/Eajack/py_spider/blob/master/%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB/getShares163.py" target="_blank" rel="noopener">getShares163.py</a>：网易股票数据小爬虫</li><li>[updating…]</li></ul></blockquote><h2 id="5、留坑"><a href="#5、留坑" class="headerlink" title="5、留坑"></a>5、留坑</h2><blockquote><ul><li>多线程/进程（解决爬虫太慢）</li><li>Python编程技巧</li><li>[updating…]</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog修复Flag</title>
      <link href="/2018/06/13/Blog%E4%BF%AE%E5%A4%8DFlag/"/>
      <url>/2018/06/13/Blog%E4%BF%AE%E5%A4%8DFlag/</url>
      
        <content type="html"><![CDATA[<p>老早之前就发现blog存在问题了，侧栏文章不知怎得点开后看不了全文……</p><ul><li>eg: <a href="https://eajack.github.io/2018/03/17/FCM%E6%A8%A1%E7%B3%8A%E8%81%9A%E7%B1%BBM%E7%A0%81/">FCM模糊聚类M码</a></li></ul><p>还有，对比其他主题发现这主题不是很人性化，文章不存在折叠功能，要看其他文章滚动条要滚很久…</p><p>先这样吧……</p><p>反正这破站没人看……</p><p>等到暑假再修复下想到得所有问题……</p><p>最近肯定没空了，也不会发什么东西。个人项目&amp;Blog维护只能暑假再说，絮絮叨叨……</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FCM模糊聚类M码</title>
      <link href="/2018/03/17/FCM%E6%A8%A1%E7%B3%8A%E8%81%9A%E7%B1%BBM%E7%A0%81/"/>
      <url>/2018/03/17/FCM%E6%A8%A1%E7%B3%8A%E8%81%9A%E7%B1%BBM%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>源代码，本来用于数模题目中的电网设计</p><pre><code class="lang-matlab">function [clusterResult,U,iter_n] = FCM(upPresureSite, windMachineSites, clusterNum, m)    % 输入：    % clusterNum：聚类个数，1 &lt; K &lt; N（点个数）    % m：模糊指数，1 &lt; m &lt; +无穷    % upPresureSite：升压站坐标，1 x 2 矩阵    % windMachineSites：风机坐标，N x 2 矩阵    % maxWMNum：一串最大风机数，缺省时为5    % minWMNum：一串最小风机数，缺省时为3    %% 1- 初始化 U0 以及 初始化变量    %     maxWMNum = 5;    %     minWMNum = 3;    [dataNum,dimention] = size(windMachineSites) ;    upPresureSiteMatrix = repmat(upPresureSite,[dataNum,1]);    windMachineSites = windMachineSites - upPresureSiteMatrix;  % 以升电站为原点    epsilon = 1e-40; % 收敛精度，epsilon &gt; 0    iters = 10000 ;  % 模糊聚类迭代次数    Uexpo = 2 ;  % 隶属度指数    % 随机初始化 模糊划分矩阵：U0，使U0满足列上相加为1    U0 = rand(clusterNum,dataNum);    U0=U0./(ones(clusterNum,1)*sum(U0));    U = U0 ;    % 初始化聚类中心    centerMatrix = zeros(clusterNum,dimention);    % 初始化价值函数矩阵    valueFunctionMatrix = zeros(iters,1);    % FCM 循环开始    for iterCount = 1:iters        %% 2- 计算clusterNum 个聚类中心        Uout = U .* Uexpo;  % 隶属度指数相乘        centerMatrix = (Uout * windMachineSites) ./ sum(U(clusterNum,:));        %% 3- 计算 价值函数        % 3.1- 计算 距离矩阵        distMatrix = zeros(clusterNum, dataNum);        % 遍历clusterNum个聚类中心        for clusterCount = 1:clusterNum            % 求当前聚类中心求与所有样本点距离            for dataCount = 1:dataNum                distMatrix(clusterCount,dataCount) = ...                norm( centerMatrix(clusterCount,:) - windMachineSites(dataCount,:) );            end        end        % 3.2- 计算价值函数 值        distMatrix2 = distMatrix .^ 2;  % 平方        valueFunctionMatrix(iterCount) = sum(sum(distMatrix2 .* Uout));        %% 4- 计算新的 模糊划分矩阵U        for i = 1:clusterNum            for j = 1:dataNum                DijVector = distMatrix(i,j) * ones(clusterNum,1);                DNjVector = distMatrix(:,j);                temp = (DijVector ./ DNjVector).^(2/(Uexpo-1));                temp = sum(temp);                valueFunctionMatrix(i,j) = 1 / temp;            end        end        %% 5- 算法终止条件判断        if iterCount &gt; 1 &amp;&amp; abs(valueFunctionMatrix(iterCount) - valueFunctionMatrix(iterCount-1)) &lt;= epsilon            break;        end    end    iter_n = iterCount; % 实际迭代次数    [max_U,clusterAns]=max(U);    clusterResult = [ windMachineSites+upPresureSiteMatrix , clusterAns&#39; ] ;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《2018年刑侦科推理试题》Python版求解⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄</title>
      <link href="/2018/03/07/%E3%80%8A2018%E5%B9%B4%E5%88%91%E4%BE%A6%E7%A7%91%E6%8E%A8%E7%90%86%E8%AF%95%E9%A2%98%E3%80%8BPython%E7%89%88%E6%B1%82%E8%A7%A3%E2%81%84(%E2%81%84%20%E2%81%84%E2%80%A2%E2%81%84%CF%89%E2%81%84%E2%80%A2%E2%81%84%20%E2%81%84)%E2%81%84/"/>
      <url>/2018/03/07/%E3%80%8A2018%E5%B9%B4%E5%88%91%E4%BE%A6%E7%A7%91%E6%8E%A8%E7%90%86%E8%AF%95%E9%A2%98%E3%80%8BPython%E7%89%88%E6%B1%82%E8%A7%A3%E2%81%84(%E2%81%84%20%E2%81%84%E2%80%A2%E2%81%84%CF%89%E2%81%84%E2%80%A2%E2%81%84%20%E2%81%84)%E2%81%84/</url>
      
        <content type="html"><![CDATA[<p>昨天刷知乎想法，看到Milo Yip的<a href="https://www.zhihu.com/pin/954541989945905152" target="_blank" rel="noopener">深夜暴力編程</a>，感觉有点意思，所有尝试用py写了下…思路没什么，就是暴力遍历而已，纯粹一时兴起~先抛结果：BCACACDABA</p><p>Python代码如下：</p><pre><code class="lang-python"># !/usr/bin/env python3# -*- coding : utf-8 -*-# ==================================================================================================================# Author: Eajack# date:2018/3/7# ==================================================================================================================# Function：#   2018年刑侦科推理试题，暴力遍历……# ==================================================================================================================# Results：#   [&#39;B&#39;, &#39;C&#39;, &#39;A&#39;, &#39;C&#39;, &#39;A&#39;, &#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;B&#39;, &#39;A&#39;]#   [Finished in 5.7s]#   经过检验，答案都是对的（如果没眼花的话……）# ==================================================================================================================def preparation(answers):    global maxCount,maxOption,minCount,minOption    numCountsDict = {i:answers.count(i) for i in set(answers)}    numCountsList = []    for key,value in numCountsDict.items():        numCountsList.append([value,key])    numCountsList = sorted(numCountsList,reverse = True)    maxCount = numCountsList[0][0]    maxOption = numCountsList[0][1]    minCount = numCountsList[-1][0]    minOption = numCountsList[-1][1]def Q3Test(answers):    if(answers[2] == 1):        return (answers[5]==answers[1]==answers[3] and answers[2]!=answers[5])    else:        if(answers[2]==2):            return (answers[2]==answers[1]==answers[3] and answers[5]!=answers[2])        else:            if(answers[2]==3):                return (answers[2]==answers[5]==answers[3] and answers[1]!=answers[2])            else:                return (answers[2]==answers[5]==answers[1] and answers[3]!=answers[2])def Q4Test(answers):    trueList = [int(answers[0]==answers[4]),int(answers[1]==answers[6]),int(answers[0]==answers[8]),int(answers[5]==answers[9])]    if(sum(trueList)==1 and trueList[answers[3]-1]==1):        return True    else:        return Falsedef Q6Test(answers):    if(answers[5] == 1):        return (answers[1]==answers[3]==answers[7])    else:        if(answers[5]==2):            return (answers[0]==answers[5]==answers[7])        else:            if(answers[5]==3):                return (answers[2]==answers[9]==answers[7])            else:                return (answers[4]==answers[8]==answers[7])def Q8Test(answers):    if(answers[7] == 1):        return (abs(answers[6]-answers[0])!=1)    else:        if(answers[7]==2):            return (abs(answers[4]-answers[0])!=1)        else:            if(answers[7]==3):                return (abs(answers[1]-answers[0])!=1)            else:                return (abs(answers[9]-answers[0])!=1)if __name__ == &#39;__main__&#39;:#    # globals    Q2toQ5 = {1:3,2:4,3:1,4:2}    Q4toQDouble = {1:[1,5],2:[2,7],3:[1,9],4:[6,10]}    Q5toQX = {1:8,2:4,3:9,4:7}    Q7toQY = {1:3,2:2,3:1,4:4}    Q9toQZ = {1:6,2:10,3:2,4:9}    Q10toQ = {1:3,2:2,3:4,4:1}    answers2ADs = {1:&#39;A&#39;,2:&#39;B&#39;,3:&#39;C&#39;,4:&#39;D&#39;}    maxCount = []    maxOption = []    minCount = []    minOption = []#    for Q1 in range(1,5):        for Q2 in range(1,5):            for Q3 in range(1,5):                for Q4 in range(1,5):                    for Q5 in range(1,5):                        for Q6 in range(1,5):                            for Q7 in range(1,5):                                for Q8 in range(1,5):                                    for Q9 in range(1,5):                                        for Q10 in range(1,5):                                            answers = [Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q8,Q9,Q10]                                            preparation(answers)                                            # 2题 检验                                            if(Q2toQ5[Q2] != Q5):                                                continue;                                            else:                                                # 3题 检验                                                if(Q3Test(answers) != True):                                                    continue;                                                else:                                                    # 4题 检验                                                    if(Q4Test(answers) != True):                                                        continue;                                                    else:                                                        # 5题 检验                                                        if(Q5 != answers[Q5toQX[Q5]-1]):                                                            continue;                                                        else:                                                            # 6题 检验                                                            if(Q6Test(answers) != True):                                                                continue;                                                            else:                                                                # 7题 检验                                                                if(minOption != Q7toQY[Q7]):                                                                    continue;                                                                else:                                                                    # 8题 检验                                                                    if(Q8Test(answers) != True):                                                                        continue;                                                                    else:                                                                        # 9题 检验                                                                        if((Q1==Q6) == (answers[Q9toQZ[Q9]-1] == Q5)):                                                                            continue;                                                                        else:                                                                            # 10题 检验                                                                            if(maxCount - minCount != Q10toQ[Q10]):                                                                                continue;                                                                            else:                                                                                answersADs = [answers2ADs[answer] for answer in answers ]                                                                                print(answersADs)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV零碎点笔记</title>
      <link href="/2018/02/20/OpenCV%E9%9B%B6%E7%A2%8E%E7%82%B9%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/02/20/OpenCV%E9%9B%B6%E7%A2%8E%E7%82%B9%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>Series:<strong>OpenCV学习笔记</strong></p><h3 id="updating"><a href="#updating" class="headerlink" title="updating"></a><em>updating</em></h3><h3 id="1-OpenCV常用常数"><a href="#1-OpenCV常用常数" class="headerlink" title="1. OpenCV常用常数"></a>1. OpenCV常用常数</h3><ul><li>矩阵数据类型：<code>CV_&lt;bit_depth&gt;(S|U|F)C&lt;number_of_channels&gt;</code></li></ul><blockquote><p>S = 符号整型  U = 无符号整型  F = 浮点型</p><p>E.g.:<br>CV_8UC1 是指一个8位无符号整型单通道矩阵<br>CV_32FC2是指一个32位浮点型双通道矩阵</p></blockquote><p>列出如下：</p><div class="table-container"><table><thead><tr><th>数</th><th>据</th><th>类</th><th>型</th></tr></thead><tbody><tr><td>CV_8UC1</td><td>CV_8SC1</td><td>CV_16U C1</td><td>CV_16SC1</td></tr><tr><td>CV_8UC2</td><td>CV_8SC2</td><td>CV_16U C2</td><td>CV_16SC2</td></tr><tr><td>CV_8UC3</td><td>CV_8SC3</td><td>CV_16U C3</td><td>CV_16SC3</td></tr><tr><td>CV_8UC4</td><td>CV_8SC4</td><td>CV_16U C4</td><td>CV_16SC4</td></tr><tr><td>CV_32SC1</td><td>CV_32FC1</td><td>CV_64FC1</td><td>NULL</td></tr><tr><td>CV_32SC2</td><td>CV_32FC2</td><td>CV_64FC2</td><td>NULL</td></tr><tr><td>CV_32SC3</td><td>CV_32FC3</td><td>CV_64FC3</td><td>NULL</td></tr><tr><td>CV_32SC4</td><td>CV_32FC4</td><td>CV_64FC4</td><td>NULL</td></tr></tbody></table></div><h3 id="2-OpenCV平台配置汇总"><a href="#2-OpenCV平台配置汇总" class="headerlink" title="2.OpenCV平台配置汇总"></a>2.OpenCV平台配置汇总</h3><ul><li><a href="http://blog.csdn.net/wx7788250/article/details/54970903" target="_blank" rel="noopener">【OpenCV】CodeBlocks+OpenCV3.2环境搭建</a></li><li><a href="https://robocoderhan.github.io/2016/12/13/Raspberry%20Pi%203%20+%20Raspbian%20Jessie%20+%20OpenCV%203/" target="_blank" rel="noopener">Raspberry Pi 3 + Raspbian Jessie + OpenCV 3</a></li><li><a href="http://www.srccodes.com/p/article/56/uninstall-remove-opencv-raspberry-pi-jessie-debain-make-uninstall-open-source-computer-vision-opencvlib" target="_blank" rel="noopener">How to uninstall OpenCV (Open Source Computer Vision) from Raspberry Pi - Raspbian Jessie?</a>(需翻墙)</li><li><a href="http://blog.csdn.net/xukai871105/article/details/40988101" target="_blank" rel="noopener">树莓派学习笔记—— 源代码方式安装opencv</a> &amp; <a href="http://blog.csdn.net/xukai871105/article/details/41084949" target="_blank" rel="noopener">树莓派学习笔记——apt方式安装opencv</a></li><li><a href="http://blog.csdn.net/dango_miracle/article/details/78681131" target="_blank" rel="noopener">【OpenCV】VS2017配置OpenCV2.4.13.4（其余高版本同理）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>侧栏音乐</title>
      <link href="/2018/02/18/%E4%BE%A7%E6%A0%8F%E9%9F%B3%E4%B9%90/"/>
      <url>/2018/02/18/%E4%BE%A7%E6%A0%8F%E9%9F%B3%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<p>以下为目前侧栏音乐备选音乐列表：</p><blockquote><ul><li><a href="http://music.163.com/#/song?id=734287" target="_blank" rel="noopener">GARNET CROW - 《夢みたあとで》</a></li><li><a href="http://music.163.com/#/song?id=34852492" target="_blank" rel="noopener">nero - 《831143》</a></li><li><a href="http://music.163.com/#/song?id=677804" target="_blank" rel="noopener">ZARD - 《運命のルーレット廻して》</a></li><li><a href="http://music.163.com/#/song?id=28996833" target="_blank" rel="noopener">软木 - 《secret base》</a></li><li><a href="http://music.163.com/#/song?id=28940048" target="_blank" rel="noopener"> Supper Moment - 《无尽》</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017年我到底都做了什么？</title>
      <link href="/2018/01/19/2017%E6%88%91%E5%88%B0%E5%BA%95%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2018/01/19/2017%E6%88%91%E5%88%B0%E5%BA%95%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>习惯地，从大学开始，每一年结束后，也就是期末完了之后的寒假期间，都会多多少少写点年度总结，不然都不知自己这一年浑浑噩噩怎么度过的……</p><blockquote><ul><li>Everyone is struggling everyday.</li></ul></blockquote><h3 id="1-2017任务清单"><a href="#1-2017任务清单" class="headerlink" title="1- 2017任务清单"></a>1- 2017任务清单</h3><p>从16年开始，在每年的开始，都会初步列出下一年的任务清单。当然，清单也会在下一年期间更新。</p><ul><li>2017任务清单<ol><li>书单<ul><li>《数据结构与算法分析（C语言描述）》</li><li>《一站式C编程》</li><li>《大辞海-哲学卷》</li><li><del>《Python编程入门与实践》</del></li><li><del>《Python简明教程》</del></li><li><del>《OpenCV3编程入门》</del></li><li><strong>以下为小说，喜马拉雅听书</strong></li><li><del>《只有你听到-乙一》</del></li><li><del>《zoo-乙一》</del></li><li><del>《献给死者的音乐-乙一》</del></li><li><del>《全部成为F-森博嗣》</del></li><li><del>《寂寞的频率-乙一》</del></li><li><del>《夏日，烟火，我的尸体-乙一》</del></li><li><del>《平面狗-乙一》</del></li></ul></li><li>项目idea（至少完成5项）<ul><li><del>Eason网易云歌曲爬虫。1- 爬取网易云音乐Eason歌曲歌词文本，以及热门评论&amp;最新评论，文本分析得到词云图、词频图&amp;情绪分析图。2- 爬取网易云音乐Eason所有歌曲对应的评论数，并进行排名。</del></li><li><del>emoji官网图片爬虫。爬取emoji官网所有emoji图片，并按原官网分类进行归类。</del></li><li><del>QQ空间爬虫。1- 爬取个人空间所有说说，文本分析得到Top30词频词语、年度关键词&amp;年度关键标点符号，说说数量时间分析。2- 爬取好友QQ空间说说，分析同上。</del></li><li>无人机 + 三维建模 项目</li><li>无人机基于GPS路径导航规划</li><li>利用树莓派做狗型机器人</li><li>DSP音频模拟器。将自己的声音处理转换为Eason的声音（Eason项目的一部分）</li><li>自动接垃圾的垃圾桶</li></ul></li><li>日常计划<ul><li><del>用自己的钱买一部新电脑，配置：i5+GTX960以上，适合计算机方面编程工作。（奖学金+兼职，暗影2pro）</del></li><li><del>自己搭建个人blog网站（Eajack Blog）</del></li><li>用自己的钱，淘宝买一架无人机（仅用于拍照，可附加实时传送图片功能，目的在于个人项目：无人机 + 三维重建）</li></ul></li><li>学业计划<ul><li><del>以一作发表1篇B类论文（目前：B类1作2篇，B类6作一篇）</del></li><li>以二作发表一篇B类论文</li><li>争取发一篇EI论文（A类）</li><li>争取申请一项专利</li></ul></li><li>锻炼计划<ul><li>稳定体重55 - 60kg（目前61.2kg，一般维持在62 - 64kg，2018/1/19）</li><li>瘦小腿，到30cm，大腿到45cm</li><li>跑步打卡 &gt; 200天（132天）</li></ul></li></ol></li></ul><p>以上为2017年的任务清单（包括了一开始的任务以及后来添加的任务），画删除线的为已经完成的。发现，有很多任务都还没完成啊。的确，flag真的是个永远都有的东西。</p><blockquote><ul><li>Flags are endless.</li></ul></blockquote><p>2018年任务清单计划将会延续17年未完成任务，2018任务清单也要开始整理了…</p><h3 id="2-2017年此外的收获"><a href="#2-2017年此外的收获" class="headerlink" title="2- 2017年此外的收获"></a>2- 2017年此外的收获</h3><p>回想2017，有什么值得回忆的呢？此刻能想到多少就写多少回忆吧。</p><p><strong>1月</strong>大二上考完期末，到了大二下寒假，数模美赛。最终拿了国际二等奖（Honorable Mention)，队友们都觉得都能拿一等的（M奖），谁知结果也就那样，多少有些失望，但是也就那样吧。还记得当时刷美赛表情包，很好玩。美赛完，第二天刚好赶上高三班聚，最后一个到场，2年不见，大家都变了很多，还拍照留念。</p><p><strong>2月</strong>大二上寒假。记得是在玩了很久？具体忘了。也在自学数据结构&amp;算法，看C语言书籍好像。<br>寒假，大学冬宣（自己没参与）回高中看了一次学校。</p><p><strong>3~6月</strong>大二下开始，日常开始注意课内平时学习（因为大二上感觉平时看书时间变少了，现在想想，这学期大三上看书也少了很多，也就导致考得这么渣吧……）。申了个大创（后来通过是国创）和挑战杯（三等奖立项）。开始泡基地，一直至今。这段时间 = 日常复习课内知识 + 学习Python（爬虫）+  M道出游、活动。</p><p><strong>7月</strong>大二下期末考完，记得挺吃力，虽然平时有看书。但最后绩点成绩有点出乎意料又符合自己意愿，心里很满足，现在想想，大概大二下的绩点应该会是大学4年最高的一次了，想想这学期，是真的呵呵，超级无语，超级无奈。都过去了，就那样吧，只能祈祷了，转鲤鱼hhh。</p><p><strong>8月</strong>暑假开始，基本整个暑假都在做大创项目（那时候知道是国创和挑战杯3等奖了）。还有学车，科目2竟然没过，就来学校了，大概我大学毕业才能拿得到驾照吧。。hhh。此外，还进一步学了Python。</p><p><strong>9月</strong>大三上开始。我也知道，这是最关键的一个学期，可是我真的没想到，这学期期末崩了，虽然成绩还没出全，但我感觉会崩的比较厉害，有可能是大学期间最崩的一次吗？（仅猜测，但还是继续祈祷啊啊啊啊啊）。9月，相当忙。9月 = 数模国赛（这次终于拿了国二，虽然没有国一，也满足了） + 大创中期答辩准备（包括报销等）。基本这2件事就已经充斥了整个9月份，真的相当忙，记得当时一开学那个月真的超累。还有一件小事，也是这次比赛开始，我喜欢上了一位女生，国赛后约出去玩，刚好那时碰上我生日，她约我出去吃饭算是过了生日。一开始很开心，虽然我觉得她好像不喜欢我，但又有点疑惑。但最后还是决定了，表白吧。</p><p><strong>10月</strong>9月份，基本没看过课内课本。10月份开始学习课内，但这不是最主要的回忆。10月初，国庆，刚好她生日也是国庆期间。本来打算国庆前约她出来玩帮她提前过生日，表白好了，但说推迟到国庆之后。国庆回来后，虽然我也发现了她开始躲避我的样子，但还是决定表白吧，可不可以都算了。约了出来吃饭、看电影，她拉了个师妹，我知道是尴尬吧。师妹也知道我的心思，后来一天晚上，还是表白了。一起学习完回去路上，傻乎乎的我硬塞了个写了一晚上的信给她，说了几句就匆匆走了。当然，那晚12:30，她微信拒了我，好人牌，说了很多话。那晚的聊天都截图保存了。幸亏现在也还算朋友。那晚本来以为3点都睡不着，谁知，1点多睡着了。后来，和好友倾诉，缓了好一段时间。那段时间，学习都被耽搁了啊，哎，真的不该。</p><p><strong>11月</strong>继续缓和心情，又一定程度上影响学习，这学期的课内学习真的被耽搁了。也开始了大创进度。这个月，主要都是在学课内，课外基本很少碰了。</p><p><strong>12月</strong>复习周，史上最恐怖复习考试周，真的是相当恐怖，不单止是因为考试，还有其他事情。2017.12 ~ 2018.1的考试复习周，也就是到现在为止的时间，我经历了什么呢？12月初，还在搞着郭老师的车厢异常检测项目，全面复习还没开始，想想是真的可怕。之后开始复习，逐科复习，特别最恐怖的马哲（马哲恐怖之处不仅在于老师改卷，更在于它对其他科目复习进度&amp;考试精力的影响，这门课应该是我大学4年最恐怖的一门课了吧）。之后，一件令我哭了好几次的事发生了。平安夜开始，我妈重病一场，去医院打点滴、一两天内不能诊断出是什么病，就全身无力劳累、无法下床、头痛等，那一周刚好复习周，这一次导致我复习周都没心思了，一天和爸、外婆、爷爷、妈妈通话好几次，哭了好几次，我知道爸也哭了，十分记得爸爸说“医生说可能病毒入侵了，有病毒入脑了，什么淋巴病毒”，那天下午，我刚上完马哲重点课，报完项目经费，听到后在日月湖忍不住哭了，也听到了爸在抽泣，我说“没事的，很快就知道什么病了，这样就好了”。终于，后来幸亏检测出什么病了，一种很罕见的病，名字是英文名，我知道病名后马上百度，也真的幸亏网上说可以治愈，当时马上松了口气。之后复习周，都和家里人通话，哭了好几次，幸亏现在妈也好了很多。那段时间真的，身心煎熬，在最恐怖的一个复习考试周发生这种事情。还有一件糟心事，也是在复习周后期，她突然脱单了，我当时也没有很大冲击，就一两天缓缓就过去了，当时在复习根本理不了这些小事（算是小事吧…）。</p><p>总的来说，这个大三上期末期间，真的是相当身心煎熬的一次。家里的突然，一周哭了好几次，心情相当低落；爆炸的复习，连续3天2、3点睡觉（之前复习周都没有试过）；她的突然脱单。。可以说，这个狗血剧情，真的电视剧才有吧，这段时间，太恐怖了，大概是老天爷给我的考验，也是最糟心的一次年末了，记忆深刻的一次年末。</p><h3 id="3-2018来了"><a href="#3-2018来了" class="headerlink" title="3- 2018来了"></a>3- 2018来了</h3><p>2018，来了。这一年，应该要比2017更艰难。</p><p>这一年，应该是大学最艰难的一年了吧。既然你选择了想要保研这条路，那这一年的所有将会是你大学期间另一个最有怀念价值的拼搏时期。尽我全力，破釜沉舟，背水一战，只求今年9月笑逐颜开。2018年，希望，你做好充分准备，心理准备。</p><p>2018的清单，也要腾时间出来整理了……</p>]]></content>
      
      
      <categories>
          
          <category> 鸡汤 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸡汤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C++ Primer（第五版）》中文版学习笔记（1）</title>
      <link href="/2017/10/10/%E3%80%8AC++%20Primer%EF%BC%88%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%89%E3%80%8B%E4%B8%AD%E6%96%87%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/10/10/%E3%80%8AC++%20Primer%EF%BC%88%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%89%E3%80%8B%E4%B8%AD%E6%96%87%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong> Series ：《C++ Primer（第五版）》中文版学习笔记 </strong></p><h3 id="第1章-开始"><a href="#第1章-开始" class="headerlink" title="第1章 开始"></a>第1章 开始</h3><ul><li>C++ 标准输入输出流库：<code>iostream</code><ul><li>cin：标准输入</li><li>cout：标准输出</li><li>cerr：输出警告&amp;错误消息</li><li>clog：输出程序运行时一般信息</li></ul></li></ul><pre><code class="lang-cpp">// 示例代码：#include &lt;iostream&gt;int main(){    std::cout &lt;&lt; &quot;Enter 2 numbers:&quot; &lt;&lt; std::endl;    int v1 = 0, v2 = 0;    std::cin &gt;&gt; v1 &gt;&gt; v2;    std::cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; v1 &lt;&lt; &quot;and&quot; &lt;&lt; v2              &lt;&lt; &quot; is &quot; &lt;&lt; v1 + v2 &lt;&lt; std::endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eason Projects</title>
      <link href="/2017/10/05/Eason%20Projects/"/>
      <url>/2017/10/05/Eason%20Projects/</url>
      
        <content type="html"><![CDATA[<p>作为一个Eason Fan，连写代码、做项目也是喜欢在Eason上面花心思的……</p><h3 id="1-intro"><a href="#1-intro" class="headerlink" title="1.intro"></a>1.intro</h3><p>汇总目前我做过的关于Eason（陈奕迅）的项目，包括以下几个</p><blockquote><ul><li><a href="https://github.com/Eajack/py_spider/blob/master/%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB/Eason_Film.py" target="_blank" rel="noopener">Eason_Film.py</a>：爬取豆瓣所有Eason电影列表</li><li><a href="https://github.com/Eajack/py_spider/tree/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics" target="_blank" rel="noopener">music163_EasonLyrics</a>：网易云平台Eason所有单曲歌词爬虫，文本分析</li><li><a href="https://github.com/Eajack/py_spider/tree/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments" target="_blank" rel="noopener">music163_EasonComments</a>：网易云平台Eason所有单曲评论数、热门评论&amp;最新10条评论爬虫，文本分析</li></ul></blockquote><h3 id="2-结果分析"><a href="#2-结果分析" class="headerlink" title="2.结果分析"></a>2.结果分析</h3><h4 id="2-1-Eason-Film"><a href="#2-1-Eason-Film" class="headerlink" title="2.1 Eason_Film"></a>2.1 Eason_Film</h4><p>一共爬取到<strong>67</strong>部电影，详见<a href="https://github.com/Eajack/py_spider/blob/master/%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB/Eason%E7%94%B5%E5%BD%B1.txt" target="_blank" rel="noopener">Eason电影.txt</a></p><h4 id="2-2-music163-EasonLyrics"><a href="#2-2-music163-EasonLyrics" class="headerlink" title="2.2 music163_EasonLyrics"></a>2.2 music163_EasonLyrics</h4><h5 id="2-2-1-歌词"><a href="#2-2-1-歌词" class="headerlink" title="2.2.1 歌词"></a>2.2.1 歌词</h5><p>一共爬取到<strong>536</strong>首歌歌词（去重），歌词txt文件详见<a href="https://github.com/Eajack/py_spider/tree/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/Lyrics" target="_blank" rel="noopener">Lyrics</a></p><h5 id="2-2-2-结果图片"><a href="#2-2-2-结果图片" class="headerlink" title="2.2.2 结果图片"></a>2.2.2 结果图片</h5><p>图片结果如下：</p><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/resultsPNGs/EasonLyricsCloud.png" alt="Eason歌词词云图" title="Eason歌词词云图"></p><p>上图为歌词词云图</p><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/resultsPNGs/%E5%89%8D30%E8%AF%8D%E9%A2%91%E6%9F%B1%E5%BD%A2%E5%9B%BE.png" alt="TOP 30词频柱形图" title="TOP 30词频柱形图"></p><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/resultsPNGs/%E5%89%8D30%E8%AF%8D%E9%A2%91%E9%A5%BC%E7%8A%B6%E5%9B%BE.png" alt="TOP 30词频饼状图" title="TOP 30词频饼状图"></p><p>由上述二图分析可知，词频最高的词语为<strong>“没有”</strong>，其次为“一个”、“我们”等</p><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/resultsPNGs/%E6%83%85%E7%BB%AA%E5%88%86%E6%9E%90%E6%8A%98%E7%BA%BF%E5%9B%BE.png" alt="情绪分析折线图.png" title="情绪分析折线图"></p><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/resultsPNGs/%E6%83%85%E7%BB%AA%E5%88%86%E6%9E%90%E6%AF%94%E4%BE%8B%E9%A5%BC%E7%8A%B6%E5%9B%BE.png" alt="情绪分析比例饼状图.png" title="情绪分析比例饼状图.png"></p><p>上述二图为情绪分析指数结果图，由于运用的是snownlp库，但该库是主要针对商品评论做的情感分析库……未免与实际情况有所偏差。结果分析得知歌词情绪分析指数呈“两边低，中间高”分布，评分多集中在0.5~0.8，评分越高，说明歌曲的积极程度越高。同时，取情绪指数 &gt;= 0.6的作为正面情绪，统计出比例，并做出饼状图，发现Eason的歌<strong>正面情绪歌曲竟然占比67%</strong>……看来Eason唱的歌还是挺积极的啊……</p><h4 id="2-3-music163-EasonComments"><a href="#2-3-music163-EasonComments" class="headerlink" title="2.3 music163_EasonComments"></a>2.3 music163_EasonComments</h4><h5 id="2-3-1-评论数据分析"><a href="#2-3-1-评论数据分析" class="headerlink" title="2.3.1 评论数据分析"></a>2.3.1 评论数据分析</h5><p><strong>截止2017.10.3凌晨</strong>（具体忘了时间），一共爬取到<strong>5451</strong>条热门评论，详见<a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/resultXLS/hotComments.xls" target="_blank" rel="noopener">hotComments.xls</a>；爬取最新10条评论，共<strong>8492</strong>条，详见<a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/resultXLS/Newcomments.xls" target="_blank" rel="noopener">Newcomments.xls</a>；爬取到<strong>858</strong>首单曲以及对应的网易云单曲ID，详见<a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/resultXLS/songName2ID.xls" target="_blank" rel="noopener">songName2ID.xls</a>；爬取到所有单曲评论数，详见<a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/resultXLS/songName2commentsNum.xls" target="_blank" rel="noopener">songName2commentsNum.xls</a>取前10排行如下：</p><div class="table-container"><table><thead><tr><th>歌名</th><th>评论数</th></tr></thead><tbody><tr><td>陪你度过漫长岁月 - (电影《陪安东尼度过漫长岁月》主题曲)</td><td>79350</td></tr><tr><td>好久不见</td><td>67875</td></tr><tr><td>十年</td><td>60062</td></tr><tr><td>不要说话</td><td>56746</td></tr><tr><td>阴天快乐</td><td>50840</td></tr><tr><td>可以了</td><td>40998</td></tr><tr><td>让我留在你身边 - (电影《摆渡人》爱情版主题曲)</td><td>38108</td></tr><tr><td>淘汰</td><td>36806</td></tr><tr><td>富士山下</td><td>36433</td></tr><tr><td>最佳损友</td><td>34811</td></tr></tbody></table></div><p><strong>评论过1w的歌曲数量仅有38首</strong>，<strong>999+歌曲有241首</strong>，感觉比周董的百万《晴天》以及很多的过万歌差别很远啊……最低评论（去除最新专辑《C’mon in~》的需收费，未公开的《未知track》0评论）歌曲是《美丽有罪 (James Ting Remix)》，仅<strong>1</strong>条评论（应该是版权也没了）</p><h5 id="2-3-2-评论文本分析"><a href="#2-3-2-评论文本分析" class="headerlink" title="2.3.2 评论文本分析"></a>2.3.2 评论文本分析</h5><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/resultsPNGs/%E7%83%AD%E9%97%A8%E8%AF%84%E8%AE%BA%E8%AF%8D%E4%BA%91.png" alt="热门评论词云.png" title="热门评论词云.png"></p><p>上图为热门评论词云图</p><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/resultsPNGs/%E5%89%8D30%E8%AF%8D%E9%A2%91%E6%9F%B1%E5%BD%A2%E5%9B%BE.png" alt="TOP 30词频柱形图.png" title="TOP 30词频柱形图.png"></p><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/resultsPNGs/%E5%89%8D30%E8%AF%8D%E9%A2%91%E9%A5%BC%E7%8A%B6%E5%9B%BE.png" alt="TOP 30词频饼状图.png" title="TOP 30词频饼状图.png"></p><p>上述二图为热门评论词频分析图，可知词频最高的是“首歌”（这里jieba分词可能有点问题），之后是“一个”（其实该词属于常用词，照理可以剔除）。因此，在我心目中，词频最高的是“喜欢”，第二是“陈奕迅”，也符合常理啦~~</p><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/resultsPNGs/%E6%83%85%E7%BB%AA%E6%8C%87%E6%95%B0%E6%9B%B2%E7%BA%BF.png" alt="情绪指数曲线.png" title="情绪指数曲线.png"></p><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/resultsPNGs/%E6%83%85%E7%BB%AA%E5%88%86%E6%9E%90%E9%A5%BC%E7%8A%B6%E6%AF%94%E4%BE%8B%E5%9B%BE.png" alt="情绪分析饼状比例图.png" title="情绪分析饼状比例图.png"></p><p>情绪分析套路与前面类似，只是在处理文本方面有些许不同。在这里，我们也可以看到snownlp库的不足了……（虽然也不知道是不是对的，但感觉上不是十分靠谱）。此处情感曲线呈类似指数函数趋势（这结果也是厉害……），正面情绪评论比重为76%，此处不多做分析。</p><h3 id="3-New-Ideas"><a href="#3-New-Ideas" class="headerlink" title="3.New Ideas"></a>3.New Ideas</h3><p>以上是目前关于做过的关于Eason的项目，比较偏软件方面，均为Python爬虫。此外，作为Eason Fan，我是十分羡慕Eason的歌喉的。个人有一个长远Project：做一个DSP音频处理器（软件 or 硬件），将自己的声音处理变成Eason的声音。由于个人认为该项目难度相当大，所以作为一个长期Project，或许几年之后才能做出了，但希望自己能坚持做。具体项目细节、所需技术&amp;目标等还没细想，之后开工后会继续慢慢想着</p><h3 id="4-More"><a href="#4-More" class="headerlink" title="4.More"></a>4.More</h3><p>Python爬虫项目玩了有一阵子了，从暑假开始玩，现在也该不玩了。个人所有Py3爬虫项目以及思路、结果等在GitHub：<a href="https://github.com/Eajack/py_spider" target="_blank" rel="noopener">py_spider</a>，也不是很牛逼的东西，纯属娱乐~~</p><p>现在要开坑CV + 算法了……希望，如果有人看到这文章，有点子或者想讨论的可以多多评论留言~~</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
            <tag> Eason </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>あの顷～ジンジンバオヂュオニ～- whiteeeen歌词（罗马音）</title>
      <link href="/2017/10/05/%E3%81%82%E3%81%AE%E9%A1%B7%EF%BD%9E%E3%82%B8%E3%83%B3%E3%82%B8%E3%83%B3%E3%83%90%E3%82%AA%E3%83%82%E3%83%A5%E3%82%AA%E3%83%8B%EF%BD%9E-%20whiteeeen%E6%AD%8C%E8%AF%8D%EF%BC%88%E7%BD%97%E9%A9%AC%E9%9F%B3%EF%BC%89/"/>
      <url>/2017/10/05/%E3%81%82%E3%81%AE%E9%A1%B7%EF%BD%9E%E3%82%B8%E3%83%B3%E3%82%B8%E3%83%B3%E3%83%90%E3%82%AA%E3%83%82%E3%83%A5%E3%82%AA%E3%83%8B%EF%BD%9E-%20whiteeeen%E6%AD%8C%E8%AF%8D%EF%BC%88%E7%BD%97%E9%A9%AC%E9%9F%B3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>网易云评论：</li><li>summer海芋：2012年1月电影《那些年》的主题曲，由木村充利作曲，九把刀作词，胡夏演唱，收录在《那些年，我们一起追的女孩》电影原声带以及胡夏第二张个人专辑《燃点》中。2015年10月被日本歌手whiteeeen翻唱 </li></ul></blockquote><h4 id="来源：百度知道"><a href="#来源：百度知道" class="headerlink" title="来源：百度知道"></a>来源：<a href="https://zhidao.baidu.com/question/1240473122105477739.html" target="_blank" rel="noopener">百度知道</a></h4><pre><code>** あの顷～ジンジンバオヂュオニ～ **** 歌：whiteeeen **** 词：Jiu Ba Dao, Ayume Yamashita, JIN **** 曲：Chong Li Mu Cun **** part 1 **月日が流れて  溢れたす思いてtsukihi ga nagarete ahuredasu omoite无邪気な君の笑颜mujakina kimi no egao少年は今日ネクタイしてshounen ha kyoo nekutai shite少女との誓いを立てるshoujyo to no chikai wo tateru镜を见つめて　落ち着きなくしてkagami wo mitsumete ochitsuki nakushite着饰る君はきっとkikazaru kimi ha kittoこれまでで一番　绮丽な姿をkoremade de ichiban kirei na sugata wo仆に见せてくれるんだろうboku ni misetekure rundarouあの顷に戻れるならanokoro ni modorerunaiまた君の前の席に座るんだmatakimi no mae no sekini suwarundaもう一度君に恋をしてmou ichido kimini koiwoshiteいだずらをしかってitazura wo shigatte风が吹く季节　すれ违った恋kazega fuku kisetsu sure chigatta koi言い出せず　思い闭じ込めたiidasezu  omoitojikometa君はいつだってそう仆のすべてkimi ha itsu tatte sou boku no subeteこの世界中にただ一人kono sekaijyu ni tada hitoriできるだけ强く　ああ抱きしめたいdekiru dake tsuyoku aa dakishimedai辉く満天の夜空にkagayaku manten no yozora ni汚れなき仆ら二人で交わしたkegarenaki boku ra futari de kawashitaあの约束を忘れないano yakusoku wo wasurenaiジンジンバオヂュオニjin jin bao zhe ni** part 2 **なれない手つきで　髪を整えてnarinai te tsukise kami wo totonoete背伸びした立ち姿senobishi tadachi sugata君は笑うのかな？　笑ってくれるかな？kimi ha warau no ganawaratte kureru kana喜ぶ颜がみたいのyorokobu kao ga mitaino黒板の数式すら　kokuban no suushiki suraそっちのけで　ふざけあっていたよねsocchi no kedefuzakeatteitayone隣に座る谁もが皆tonari ni suwaru daremoga mina君に恋してたよkimi ni koite tayoいつも思い出す君が离れないitsumo omoidasu kimiga hanare nai何も手につかないくらいにdaremo teni tsukanaiku naini仆も呼ぶ声も弾ける笑颜もbokumo yobu koemo hajikeru egaomoいますぐ君にただ会いたいimasugu kimini tada aitai儚く散りゆくあの流れ星にhakanaku chiriyuku ano nagare hoshi ni何度も何度も愿ったよnandomo nandomo negatta yo小さな幸せ届け未来までchi i sana shiawase tedoke mirai made止まった记忆そのままにああずっとtomatta kioku sono mamaniaa zutto风が吹く季节　すれ违った恋kazega fuku kisetsu sure chigatta koi言い出せず　思い闭じ込めたiidasezu  omoitojikometa君はいつだってそう仆のすべてkimi ha itsu tatte sou boku no subeteこの世界中にただ一人kono sekaijyu ni tada hitoriできるだけ强く　ああ抱きしめたいdekiru dake tsuyoku aa dakishimedai辉く満天の夜空にkagayaku manten no yozora ni汚れなき仆ら二人で交わしたkegarenaki boku ra futari de kawashitaあの约束を忘れないano yakusoku wo wasurenaiジンジンバオヂュオニjin jin bao zhe ni</code></pre>]]></content>
      
      
      <categories>
          
          <category> Songs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>知乎语录</title>
      <link href="/2017/09/24/%E7%9F%A5%E4%B9%8E%E8%AF%AD%E5%BD%95/"/>
      <url>/2017/09/24/%E7%9F%A5%E4%B9%8E%E8%AF%AD%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>收录在知乎上感触的语句<br>keep updating……</p><h5 id="怎样才算真正喜欢一个人？"><a href="#怎样才算真正喜欢一个人？" class="headerlink" title="怎样才算真正喜欢一个人？"></a><a href="https://www.zhihu.com/question/60916632/answer/182975309" target="_blank" rel="noopener">怎样才算真正喜欢一个人？</a></h5><blockquote><ul><li>作者：阆苑仙葩林带鱼</li><li>那天我在巷口看到一棵长得怪异的榕树，<br>当我的第一反应是拍给你看的时候，<br>我就知道大事不妙了。<br>（出处不明）</li></ul></blockquote><h5 id="清华电子信息或者北大信息科学技术学院应该怎么选？"><a href="#清华电子信息或者北大信息科学技术学院应该怎么选？" class="headerlink" title="清华电子信息或者北大信息科学技术学院应该怎么选？"></a><a href="https://www.zhihu.com/question/61645207/answer/191380481" target="_blank" rel="noopener">清华电子信息或者北大信息科学技术学院应该怎么选？</a></h5><blockquote><ul><li>作者：吴辰晔</li><li>电子系的老师，喜欢聊信号，把图像看成信号，把语音看成信号，把文字也看成信号，希望把整个世界都变成信号，然后用滤波器一类的手段，从时域频域开始分析，处理。</li></ul></blockquote><h5 id="大学里面究竟是学习重要还是人际关系重要？大学到底是学习什么？"><a href="#大学里面究竟是学习重要还是人际关系重要？大学到底是学习什么？" class="headerlink" title="大学里面究竟是学习重要还是人际关系重要？大学到底是学习什么？"></a><a href="https://www.zhihu.com/question/26125708/answer/68279043" target="_blank" rel="noopener">大学里面究竟是学习重要还是人际关系重要？大学到底是学习什么？</a></h5><blockquote><ul><li>作者：徐佳鑫</li><li>总有一天，我们会走出校园，我们会把所有课堂上学到的知识忘光。通识教育也不例外，但学习的意义不在于记住和没记住，恰在于知道和不知道</li></ul></blockquote><h5 id="你是什么时候发现自己老了？"><a href="#你是什么时候发现自己老了？" class="headerlink" title="你是什么时候发现自己老了？"></a><a href="https://www.zhihu.com/question/28227804/answer/135325847" target="_blank" rel="noopener">你是什么时候发现自己老了？</a></h5><blockquote><ul><li>作者：曾加</li><li>在决定放弃的那一刻，我突然发现，自己和以前不一样了：<br>过去的我，在遇到自己最感兴趣的问题（比如好玩的数学题）时，一定会打破砂锅问到底，无论自己有多忙，或是多么没思路，我一直会对它念念不忘，最终让自己逼近真相：要么亲自解决这个问题，要么知道有人解决了它，或是人类还没有解决它但现在，在我最喜欢的东西面前，我竟然也开始退却了：我开始为自己「放弃」寻找各种各样的理由——工作太忙、问题太难，或是问题的解决对我而言并无意义……我渐渐地开始不再因为「好奇心」而去做一件事情，却开始在乎所谓的「效率」和「意义」。<br>我知道，知难而退、懂得取舍、不钻牛角尖的我更像一个普通人或正常人，但却也明白，在我决定放弃的那一刻，我便不再是原来的我了。当我们说一个人老了的时候，有时并不是指他在身体机能上的老去，而是指，他不再拥有年轻人的心气。也许，我的老去，就发生在我放弃自己最喜欢事物的一瞬间。</li></ul></blockquote><h5 id="北京邮电大学是一所怎样的学校？"><a href="#北京邮电大学是一所怎样的学校？" class="headerlink" title="北京邮电大学是一所怎样的学校？"></a><a href="https://www.zhihu.com/question/53256995/answer/134241965" target="_blank" rel="noopener">北京邮电大学是一所怎样的学校？</a></h5><blockquote><ul><li>作者：晟气凌人</li><li>计科这个专业，放眼全世界，都是一个很靠自学的专业，说实在的，教师和教材在这个专业中起到的作用并没有那么大，入门了之后，你最后的高度，取决于你的意念、努力程度和在写代码上花的时间。</li></ul></blockquote><h5 id="你做过的最能反映你应试能力的一件事是什么？"><a href="#你做过的最能反映你应试能力的一件事是什么？" class="headerlink" title="你做过的最能反映你应试能力的一件事是什么？"></a><a href="https://www.zhihu.com/question/63531778/answer/210148962" target="_blank" rel="noopener">你做过的最能反映你应试能力的一件事是什么？</a></h5><blockquote><ul><li>作者：鬼谷弈邪</li><li>平时则放荡冶游，考试则熟读讲义，不问学问之有无，惟争分数之多寡；试验既终，书籍束之高阁，毫不过问，敷衍三四年，潦草塞责，文凭到手，即可借此活动于社会，岂非与求学初衷大相背驰乎？光阴虚度，学问毫无，是自误也。<br>——蔡元培</li></ul></blockquote><h5 id="恋人之间的最好状态是怎样的？"><a href="#恋人之间的最好状态是怎样的？" class="headerlink" title="恋人之间的最好状态是怎样的？"></a><a href="https://www.zhihu.com/question/31997695/answer/192428185" target="_blank" rel="noopener">恋人之间的最好状态是怎样的？</a></h5><blockquote><ul><li>作者：Charles Wang</li><li>1、伴侣是自己最好的朋友</li><li>2、聊得来</li><li>3、和对方在一起可以有效的降低焦虑</li><li>4、共处一室各自做事情，不会感到被打扰，也不会感到冷场</li><li>5、对方能引起自己强烈的性欲</li><li>6、双方可以坦诚自己的性癖好</li><li>7、三观相合，遇到不同见解时，能够求同存异</li><li>8、双方均财务独立</li><li>9、双方都不是因为想恋爱才和对方在一起</li><li>10、互相欣赏、共同学习进步</li><li>传说中的 第11条</li><li>——因为爱，你想要成为一个更好的人。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 心情 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>831143-nero 歌词（罗马音）</title>
      <link href="/2017/09/22/831143-nero%20%E6%AD%8C%E8%AF%8D%EF%BC%88%E7%BD%97%E9%A9%AC%E9%9F%B3%EF%BC%89/"/>
      <url>/2017/09/22/831143-nero%20%E6%AD%8C%E8%AF%8D%EF%BC%88%E7%BD%97%E9%A9%AC%E9%9F%B3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>网易云评论：</li><li>貝諾馬尼亞公爵丶:一共8个字母，3个单词，表达同1个含义。<br>那就是<br>I（1个字母）<br>LOVE（4个字母） YOU（3个字母） 我爱你。 ——831143 </li></ul></blockquote><h4 id="来源：百度知道"><a href="#来源：百度知道" class="headerlink" title="来源：百度知道"></a>来源：<a href="https://zhidao.baidu.com/question/492188440949911092.html" target="_blank" rel="noopener">百度知道</a></h4><pre><code>**831143 - nero****Part 1 :**初めて仆と出会った日を君は覚えてる？hajimete boku to deatta hi wo kimi wa oboeteru? 偶然がもたらした小さな奇迹だguuzen ga motarashita chiisana kiseki da 君にはちょっと照れくさくって话してないけどkimi ni wa chotto terekusaku tte hanashite nai kedo 今覚えば仆の一目惚れだったなima omoeba boku no hitomebore datta na いろんな事があってironna koto ga atte 二人で笑って泣いてfutari de waratte naite その全てが大切な宝物なんだsono subete ga taisetsu na takaramono nanda 何にも言わないで黙って闻いて仆がする话をnannimo iwanaide damatte kiite boku ga suru hanashi wo 背中越しの手に隠しているこの包みと共にsenakagoshi no te ni kakushiteiru kono tsutsumi to tomo ni 君が喜んでくれるかどうか少し不安だけどkimi ga yorokonde kureru ka dou ka sukoshi fuan dakedo これからも爱を捧げてたいのはやっぱり君なんだkorekara mo ai wo sasagetetai no wa yappari kimi nanda **Part 2 :**待ちきれなくて少し早く目が覚めた朝はmachikire nakute sukoshi hayaku me ga sameta asa wa なんとなくいつもと违う気がしたよnantonaku itsumo to chigau ki ga shita yo 憧れだった梦のような君との未来がakogare datta yume no you na kimi to no mirai ga 现実味を帯びて迎えに来るんだろうgenjitsumi wo obite mukae ni kurun darou ロマンチストなんてromanchisuto nante 性に合わないみたいでshou ni awanai mitai de 洒落た言叶は一つも言えないけれどshareta kotoba wa hitotsu mo ienai keredo 君を呼び出して空に叫んだあの日を思い出すよkimi wo yobidashite sora ni sakenda ano hi wo omoidasu yo はにかむ笑颜で耻ずかしそうに颔いていたっけなhanikamu egae de hazukashisou ni unazuiteita kke na 震える手をぎゅっと握り缔めてもう一度伝えようfurueru te wo gyutto nigirishimete mouichido tsutaeyou 今でも変わらない仆の想いを同じ台词でima demo kawaranai boku no omoi wo onaji serifu de **Part 3 :**ついにその瞬间がtsui ni sono shunkan ga 近づいてきたようですchikazuite kita you desu 此処まで来れたのはそう、君のお阴だkoko made koreta no wa sou, kimi no okage da 扉が开いて仆に向かって歩く君の姿tobira ga hiraite boku ni mukatte aruku kimi no sugata どんな颜したら良いのかさえも分からなくなる程donna kao shitara ii no ka sae mo wakaranaku naru hodo 仆の知る限り今日の君が一番绮丽だよboku no shiru kagiri kyou no kimi ga ichiban kirei da yo 涙を堪えて爱を示すように君にキスをしようnamida wo koraete ai wo shimesu you ni kimi ni kisu wo shiyou誓いのキスをchikai no kisu wo</code></pre>]]></content>
      
      
      <categories>
          
          <category> Songs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设置树莓派开机自启动程序</title>
      <link href="/2017/09/01/%E8%AE%BE%E7%BD%AE%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
      <url>/2017/09/01/%E8%AE%BE%E7%BD%AE%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>关于如何设置树莓派开机自启动程序的资料如下：</p><blockquote><ul><li><a href="http://www.jianshu.com/p/1a160067d8fd" target="_blank" rel="noopener">几种设置树莓派开机自启的方法</a></li><li><a href="http://blog.csdn.net/qq_31669419/article/details/53331560" target="_blank" rel="noopener">妙算（树莓派等linux系统）程序开机自启动</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>music163_EasonLyrics项目</title>
      <link href="/2017/09/01/music163_EasonLyrics%E9%A1%B9%E7%9B%AE/"/>
      <url>/2017/09/01/music163_EasonLyrics%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="1、intro"><a href="#1、intro" class="headerlink" title="1、intro"></a>1、intro</h3><blockquote><p>1)-<a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/EasonLyrics.py" target="_blank" rel="noopener">EasonLyrics.py</a>：Eason网易云歌词爬虫</p><p>2)-<a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/wordsAnalysis.py" target="_blank" rel="noopener">wordsAnalysis.py</a>:</p><ul><li>歌词文本分析，包括jieba分词统计词汇（去单字）</li><li>根据词频生成词云</li><li>词频统计，做柱形图 &amp; 饼状图</li><li>歌词情绪分析简易版demo (饼状图 &amp; 曲线图)</li></ul><p>3)-<a href="https://github.com/Eajack/py_spider/tree/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/Lyrics" target="_blank" rel="noopener">Lyrics</a>:下载的歌词txt文档</p><p>4)-<a href="https://github.com/Eajack/py_spider/tree/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/resultsPNGs" target="_blank" rel="noopener">resultsPNGs</a>:所有分析结果图片汇总</p><p>5)-<a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/Eason.jpg" target="_blank" rel="noopener">Eason</a>:Eason图片词云背景图</p></blockquote><h3 id="2、思路"><a href="#2、思路" class="headerlink" title="2、思路"></a>2、思路</h3><h4 id="1）EasonLyrics思路"><a href="#1）EasonLyrics思路" class="headerlink" title="1）EasonLyrics思路"></a>1）EasonLyrics思路</h4><p>获取所有Eason专辑ID =&gt; 遍历专辑得到单曲ID并过滤同名歌曲 =&gt; 通过api<code>http://music.163.com/api/song/lyric?id=[IDNUM]</code>获得歌词，并储存为txt文件</p><h4 id="2）文本分析思路"><a href="#2）文本分析思路" class="headerlink" title="2）文本分析思路"></a>2）文本分析思路</h4><p>jieba库、wordcloud库、matplotlib库、snownlp库的使用。多百度、google&amp;github。</p><h3 id="3、遇到的问题以及解决思路"><a href="#3、遇到的问题以及解决思路" class="headerlink" title="3、遇到的问题以及解决思路"></a>3、遇到的问题以及解决思路</h3><h4 id="1）爬取歌词思路选择"><a href="#1）爬取歌词思路选择" class="headerlink" title="1）爬取歌词思路选择"></a>1）爬取歌词思路选择</h4><ol><li><strong>bs+urllib</strong>：一开始的时候，原本想通过网站<code>http://music.163.com/#/search/m/?s=陈奕迅</code>翻页遍历。但是发现用bs无法爬取，因为翻页网址没变，但在chrome里面的检查源码变了，但直接用bs+urllib爬不了html源码，只可以得到首页源码（而且后来发现bs爬的源码和chrome端不一样，因为html里面嵌入了frame，需要selenium库转换frame）</li><li><strong>selenium模拟翻页</strong>：转变思路后，但我还是想通过搜索页翻页爬取。百度发现说，可能是<code>Ajax</code>、js渲染或者的问题（还没学过前端，又不懂），说selenium库可以渲染js，用了下还是想模拟翻页，然而发现<code>set_to_iframe</code>（转换html框架）后还是不行（find到“下一页”的key，但模拟按键<code>click()</code>报错“该地方unclickable”）。因此,又放弃selenium模拟翻页思路。</li><li><strong>破解params&amp;encSecKey</strong>：随后在chrome端的Neteworks发现XHR有该页歌曲的歌名、ID等所有信息，因此觉得只要爬取这个XHR就行了。然而，之后在百度时发现说网易云api参数param有ASE加密，看一下这个XHR的Headers下部果然有<br>Form data请求参数params&amp;encSecKey，不过明显看出是加密的动态密码。搜了知乎有人破解过，github上也有人破解。不过想了下感觉好难就放弃了。</li><li><strong>专辑ID =&gt; 单曲ID =&gt; api获取歌词</strong>：最后，还是选择了另一种思路，就是现在的思路，结合了selenium库的<code>set_to_iframe</code>。</li></ol><h4 id="2）其余"><a href="#2）其余" class="headerlink" title="2）其余"></a>2）其余</h4><ol><li>文本分析方面，多google、github、看文档等就行了。有常见的歌词文本分析方向可以搜索。</li><li>经典的 utf-8(unicode) =&gt; gbk 编码问题（代码里有注释笔记）</li><li>其余剩下就是Python编程的一些技巧了。主要耗时在爬虫思路的确定以及实现。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python零碎点笔记</title>
      <link href="/2017/08/27/Python%E9%9B%B6%E7%A2%8E%E7%82%B9%E7%AC%94%E8%AE%B0%20/"/>
      <url>/2017/08/27/Python%E9%9B%B6%E7%A2%8E%E7%82%B9%E7%AC%94%E8%AE%B0%20/</url>
      
        <content type="html"><![CDATA[<h3 id="updating-on-2017-8-27"><a href="#updating-on-2017-8-27" class="headerlink" title="updating on 2017/8/27"></a><em>updating on 2017/8/27</em></h3><p><code>整理个人用过的Python零碎的资料</code></p><h3 id="1-Python-windows平台配置汇总"><a href="#1-Python-windows平台配置汇总" class="headerlink" title="1.Python windows平台配置汇总"></a>1.Python windows平台配置汇总</h3><ul><li><a href="http://blog.csdn.net/fx677588/article/details/58164902" target="_blank" rel="noopener">pyCharm最新2017激活码</a></li><li><a href="http://www.cnblogs.com/jesselzj/p/7086521.html" target="_blank" rel="noopener">Windows10+Python3下安装NumPy+SciPy+Matplotlib</a></li></ul><h3 id="2-Python-常用库文档汇总"><a href="#2-Python-常用库文档汇总" class="headerlink" title="2.Python 常用库文档汇总"></a>2.Python 常用库文档汇总</h3><ul><li><a href="http://beautifulsoup.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">Beautiful Soup 4.4.0中文文档</a></li><li><a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="noopener">Requests 2.18.1中文文档</a></li><li><a href="http://www.cnblogs.com/Lands-ljk/p/5447127.html" target="_blank" rel="noopener">Python3学习笔记（urllib模块的使用）</a></li><li><a href="https://python-selenium-zh.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">selenium + python 中文文档</a></li></ul><h3 id="3-Python-常用库安装"><a href="#3-Python-常用库安装" class="headerlink" title="3.Python 常用库安装"></a>3.Python 常用库安装</h3><ul><li><a href="https://github.com/amueller/word_cloud" target="_blank" rel="noopener">wordcloud</a></li></ul><blockquote><p>PS:无VS2015的windows下pip安装wordcloud报错<br><code>Unable to find vcvarsall.bat</code>，不用去装SDK/VS那些，下载对应Python版本的<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud" target="_blank" rel="noopener">whl文件</a>。之后，pip install [whl文件名]</p></blockquote><ul><li><a href="http://www.cnblogs.com/jesselzj/p/7086521.html" target="_blank" rel="noopener">Windows10+Python3下安装NumPy+SciPy+Matplotlib</a></li></ul><h3 id="3-正则表达式"><a href="#3-正则表达式" class="headerlink" title="3.正则表达式"></a>3.正则表达式</h3><ul><li><a href="http://tool.oschina.net/regex/" target="_blank" rel="noopener">在线正则表达式测试</a></li><li><a href="https://www.w3cschool.cn/regexp/tfua1pq5.html" target="_blank" rel="noopener">W3Cschool 正则表达式</a></li></ul><h3 id="4-Python相关教程"><a href="#4-Python相关教程" class="headerlink" title="4.Python相关教程"></a>4.Python相关教程</h3><ul><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰Python3教程</a></li><li><a href="http://cuiqingcai.com/1052.html" target="_blank" rel="noopener">Python爬虫学习系列教程-静觅</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常小技巧总结</title>
      <link href="/2017/08/16/%E6%97%A5%E5%B8%B8%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
      <url>/2017/08/16/%E6%97%A5%E5%B8%B8%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="updating"><a href="#updating" class="headerlink" title="updating"></a><em>updating</em></h3><h3 id="1-windows批量重命名去括号"><a href="#1-windows批量重命名去括号" class="headerlink" title="1. windows批量重命名去括号"></a>1. windows批量重命名去括号</h3><p>2017/8/16，最近在忙着OpenCV物体识别的项目，需要收集训练图片，因此要重命名，谁知生成XML文件时，报错XML的key不可以有”()”符号，因此百度了以下技巧，做下笔记。</p><pre><code class="lang-.bat">@Echo Off&amp;SetLocal ENABLEDELAYEDEXPANSIONFOR %%a in (*) do (set &quot;name=%%a&quot;set &quot;name=!name: (=!&quot;set &quot;name=!name:)=!&quot;ren &quot;%%a&quot; &quot;!name!&quot;)exit</code></pre><p>服用方式：先用windows传统批量重命名方式得到一系列带括号文件名，然后把该脚本放在文件夹里，运行。</p>]]></content>
      
      
      <categories>
          
          <category> 杂乱 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV边缘检测</title>
      <link href="/2017/08/09/OpenCV%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/"/>
      <url>/2017/08/09/OpenCV%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<p>Series:<strong>OpenCV学习笔记</strong><br><em>边缘检测</em></p><pre><code class="lang-cpp">/*Author:EajackDate:2017/8/9Series:OpenCV笔记Function:OpenCV边缘检测Key Points:    1、Canny边缘检测步骤:原图转成灰度图 =&gt; blur降噪 =&gt; Canny边缘检测 =&gt; edge作为掩码        Canny(srcImg,edgeImg,double threshlod1,double threshold2)    2、Sobel算子边缘提取步骤: X方向梯度 =&gt; X方向梯度 =&gt; 整体方向梯度                                       [x,y]        X : Sobel(srcImg,sobel_x,CV_16S,1,0,3,1,1,BORDER_DEFAULT);        Y : Sobel(srcImg,sobel_y,CV_16S,0,1,3,1,1,BORDER_DEFAULT);        addWeighted(abs_sobel_x,0.5,abs_sobel_y,0.5,0,sobel_dst);*/#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;opencv2/opencv.hpp&gt;#include&lt;opencv2/highgui/highgui.hpp&gt;#include&lt;opencv2/imgproc/imgproc.hpp&gt;using namespace cv;using namespace std;int main(){    Mat srcImg = imread(&quot;photo.jpg&quot;);    /*1 Canny边缘检测 */    Mat srcClone = srcImg.clone();    Mat dst,edge,gray;    /*原图转成灰度图 =&gt; blur降噪 =&gt; Canny边缘检测 =&gt; edge作为掩码*/    // 创建与src同类型和大小的矩阵(dst)    dst.create(srcClone.size(),srcClone.type());    // 将原图转化为灰度图    cvtColor(srcClone,gray,CV_BGR2GRAY);    //先用3x3 内核降噪    blur(gray,edge,Size(3,3));    //运行Canny算子    Canny(edge,edge,150,50,3);    //设置dst所有元素为0    dst = Scalar::all(0);    // 使用Canny输出edge作为掩码,来将原图srcClone复制到dst    srcClone.copyTo(dst,edge);    imshow(&quot;Canny 边缘检测&quot;,dst);    imwrite(&quot;canny.jpg&quot;,dst);    /*2 sobel边缘检测 */    Mat sobel_x,sobel_y;    Mat abs_sobel_x,abs_sobel_y,sobel_dst;    // X方向梯度    Sobel(srcImg,sobel_x,CV_16S,1,0,3,1,1,BORDER_DEFAULT);    convertScaleAbs(sobel_x,abs_sobel_x);    imshow(&quot;X方向sobel&quot;,abs_sobel_x);    imwrite(&quot;sobel_x.jpg&quot;,abs_sobel_x);    // Y方向梯度    Sobel(srcImg,sobel_y,CV_16S,0,1,3,1,1,BORDER_DEFAULT);    convertScaleAbs(sobel_y,abs_sobel_y);    imshow(&quot;Y方向sobel&quot;,abs_sobel_y);    imwrite(&quot;sobel_y.jpg&quot;,abs_sobel_y);    //合并梯度（近似）    addWeighted(abs_sobel_x,0.5,abs_sobel_y,0.5,0,sobel_dst);    imshow(&quot;整体方向sobel&quot;,sobel_dst);    imwrite(&quot;sobel.jpg&quot;,sobel_dst);    waitKey(0);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV数学形态学</title>
      <link href="/2017/08/08/OpenCV%E6%95%B0%E5%AD%A6%E5%BD%A2%E6%80%81%E5%AD%A6/"/>
      <url>/2017/08/08/OpenCV%E6%95%B0%E5%AD%A6%E5%BD%A2%E6%80%81%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>Series:<strong>OpenCV学习笔记</strong><br><em>数学形态学</em></p><pre><code class="lang-cpp">/*Author:EajackDate:2017/8/8Series:OpenCV笔记Function:OpenCV数学形态学KeyPoints:    dilate(srcImg,dstImg,element);    erode(srcImg,dstImg,element);    morphologyEx(srcImg,dstImg,MORPH_OPEN,element);    // MORPH_CLOSE,MORPH_GRADIENT,MORPH_TOPHAT,MORPH_BLACKHAT //*/# include &lt;stdio.h&gt;# include &lt;iostream&gt;# include &lt;vector&gt;# include &lt;opencv2/opencv.hpp&gt;# include &lt;opencv2/highgui/highgui.hpp&gt;# include &lt;opencv2/imgproc/imgproc.hpp&gt;using namespace cv;using namespace std;int main(){    Mat frame =imread(&quot;photo.jpg&quot;);    Mat dilate_frame,erode_frame;    Mat open_frame,close_frame,grad_frame,top_frame,black_frame;    Mat flood_frame;    Mat element = getStructuringElement(MORPH_RECT,Size(10,10));    imshow(&quot;原图&quot;,frame);    // start    dilate(frame,dilate_frame,element);    imshow(&quot;膨胀操作&quot;,dilate_frame);    erode(frame,erode_frame,element);    imshow(&quot;腐蚀操作&quot;,erode_frame);    morphologyEx(frame,open_frame,MORPH_OPEN,element);    imshow(&quot;开运算&quot;,open_frame);    morphologyEx(frame,close_frame,MORPH_CLOSE,element);    imshow(&quot;闭运算&quot;,close_frame);    morphologyEx(frame,grad_frame,MORPH_GRADIENT,element);    imshow(&quot;梯度运算&quot;,grad_frame);    morphologyEx(frame,top_frame,MORPH_TOPHAT,element);    imshow(&quot;顶帽运算&quot;,top_frame);    morphologyEx(frame,black_frame,MORPH_BLACKHAT,element);    imshow(&quot;黑帽运算&quot;,black_frame);    Rect buffer;    floodFill(frame,Point(50,300),Scalar(155,255,55),                    &amp;buffer,Scalar(20,20,20),Scalar(20,20,20));    imshow(&quot;漫水填充&quot;,frame);    imwrite(&quot;dilate.jpg&quot;,dilate_frame);    imwrite(&quot;erode.jpg&quot;,erode_frame);    imwrite(&quot;open.jpg&quot;,open_frame);    imwrite(&quot;close.jpg&quot;,close_frame);    imwrite(&quot;grad.jpg&quot;,grad_frame);    imwrite(&quot;top.jpg&quot;,top_frame);    imwrite(&quot;black.jpg&quot;,black_frame);    imwrite(&quot;floodfill.jpg&quot;,frame);    waitKey(0);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>沃·兹季硕德 名言汇总</title>
      <link href="/2017/07/31/%E6%B2%83%C2%B7%E5%85%B9%E5%AD%A3%E7%A1%95%E5%BE%B7%20%E5%90%8D%E8%A8%80%E6%B1%87%E6%80%BB/"/>
      <url>/2017/07/31/%E6%B2%83%C2%B7%E5%85%B9%E5%AD%A3%E7%A1%95%E5%BE%B7%20%E5%90%8D%E8%A8%80%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>Keep updating……</p><p>从前，有个人叫——沃·兹季硕德，曾留下如下名言感悟：</p><blockquote><ul><li>既然在过去输掉了现在，那就要在现在赢得未来。</li><li>每一个不甘心的现在，都有一个从前作为理由。</li><li>Just be yourself and then you will be a giant someday.</li><li>Everyone is struggling everyday.</li><li>……</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 心情 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 简明教程</title>
      <link href="/2017/07/20/Markdown%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
      <url>/2017/07/20/Markdown%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>PS:来源于<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">作业部落</a>在线Markdown编辑器的Markdown语法说明</p><p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p><blockquote><ul><li>整理知识，学习笔记</li><li>发布日记，杂文，所见所想</li><li>撰写发布技术文稿（代码支持）</li><li>撰写发布学术论文（LaTeX 公式支持）</li></ul></blockquote><p><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"></p><p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p><h3 id="Windows-Mac-Linux-全平台客户端"><a href="#Windows-Mac-Linux-全平台客户端" class="headerlink" title="Windows/Mac/Linux 全平台客户端"></a><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="noopener">Windows/Mac/Linux 全平台客户端</a></h3><blockquote><p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class="icon-file"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p></blockquote><hr><h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p><h3 id="1-制作一份待办事宜-Todo-列表"><a href="#1-制作一份待办事宜-Todo-列表" class="headerlink" title="1. 制作一份待办事宜 Todo 列表"></a>1. 制作一份待办事宜 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表" target="_blank" rel="noopener">Todo 列表</a></h3><ul><li>[ ] 支持以 PDF 格式导出文稿</li><li>[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li>[x] 新增 Todo 列表功能</li><li>[x] 修复 LaTex 公式渲染问题</li><li>[x] 新增 LaTex 公式编号功能</li></ul><h3 id="2-书写一个质能守恒公式LaTeX"><a href="#2-书写一个质能守恒公式LaTeX" class="headerlink" title="2. 书写一个质能守恒公式LaTeX"></a>2. 书写一个质能守恒公式<sup><a href="#fn_LaTeX" id="reffn_LaTeX">LaTeX</a></sup></h3><script type="math/tex; mode=display">E=mc^2</script><h3 id="3-高亮一段代码code"><a href="#3-高亮一段代码code" class="headerlink" title="3. 高亮一段代码code"></a>3. 高亮一段代码<sup><a href="#fn_code" id="reffn_code">code</a></sup></h3><pre><code class="lang-python">@requires_authorizationclass SomeClass:    passif __name__ == &#39;__main__&#39;:    # A comment    print &#39;hello world&#39;</code></pre><h3 id="4-高效绘制-流程图"><a href="#4-高效绘制-流程图" class="headerlink" title="4. 高效绘制 流程图"></a>4. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图" target="_blank" rel="noopener">流程图</a></h3><pre><code class="lang-flow">st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op</code></pre><h3 id="5-高效绘制-序列图"><a href="#5-高效绘制-序列图" class="headerlink" title="5. 高效绘制 序列图"></a>5. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图" target="_blank" rel="noopener">序列图</a></h3><pre><code class="lang-seq">Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!</code></pre><h3 id="6-高效绘制-甘特图"><a href="#6-高效绘制-甘特图" class="headerlink" title="6. 高效绘制 甘特图"></a>6. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图" target="_blank" rel="noopener">甘特图</a></h3><pre><code class="lang-gantt">    title 项目开发流程    section 项目确定        需求分析       :a1, 2016-06-22, 3d        可行性报告     :after a1, 5d        概念验证       : 5d    section 项目实施        概要设计      :2016-07-05  , 5d        详细设计      :2016-07-08, 10d        编码          :2016-07-15, 10d        测试          :2016-07-22, 5d    section 发布验收        发布: 2d        验收: 3d</code></pre><h3 id="7-绘制表格"><a href="#7-绘制表格" class="headerlink" title="7. 绘制表格"></a>7. 绘制表格</h3><div class="table-container"><table><thead><tr><th>项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>计算机</td><td style="text-align:right">$1600</td><td style="text-align:center">5</td></tr><tr><td>手机</td><td style="text-align:right">$12</td><td style="text-align:center">12</td></tr><tr><td>管线</td><td style="text-align:right">$1</td><td style="text-align:center">234</td></tr></tbody></table></div><h3 id="8-更详细语法说明"><a href="#8-更详细语法说明" class="headerlink" title="8. 更详细语法说明"></a>8. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown" target="_blank" rel="noopener">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册" target="_blank" rel="noopener">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p><p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p><hr><h2 id="什么是-Cmd-Markdown"><a href="#什么是-Cmd-Markdown" class="headerlink" title="什么是 Cmd Markdown"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p><h3 id="1-实时同步预览"><a href="#1-实时同步预览" class="headerlink" title="1. 实时同步预览"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p><h3 id="2-编辑工具栏"><a href="#2-编辑工具栏" class="headerlink" title="2. 编辑工具栏"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p><p><img src="https://www.zybuluo.com/static/img/toolbar-editor.png" alt="tool-editor"></p><h3 id="3-编辑模式"><a href="#3-编辑模式" class="headerlink" title="3. 编辑模式"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右侧的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p><h3 id="4-实时的云端文稿"><a href="#4-实时的云端文稿" class="headerlink" title="4. 实时的云端文稿"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p><h3 id="5-离线模式"><a href="#5-离线模式" class="headerlink" title="5. 离线模式"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p><h3 id="6-管理工具栏"><a href="#6-管理工具栏" class="headerlink" title="6. 管理工具栏"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p><p><img src="https://www.zybuluo.com/static/img/toolbar-manager.jpg" alt="tool-manager"></p><p>通过管理工具栏可以：</p><p><i class="icon-share">&lt;/i&gt; 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class="icon-file"></i> 新建：开始撰写一篇新的文稿<br><i class="icon-trash">&lt;/i&gt; 删除：删除当前的文稿<br><i class="icon-cloud"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class="icon-reorder">&lt;/i&gt; 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class="icon-pencil"></i> 模式：切换 普通/Vim/Emacs 编辑模式</i></i></i></p><h3 id="7-阅读工具栏"><a href="#7-阅读工具栏" class="headerlink" title="7. 阅读工具栏"></a>7. 阅读工具栏</h3><p><img src="https://www.zybuluo.com/static/img/toolbar-reader.jpg" alt="tool-manager"></p><p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p><p>工具栏上的五个图标依次为：</p><p><i class="icon-list">&lt;/i&gt; 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class="icon-chevron-sign-left"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class="icon-adjust">&lt;/i&gt; 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class="icon-desktop"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class="icon-fullscreen"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</i></i></p><h3 id="8-阅读模式"><a href="#8-阅读模式" class="headerlink" title="8. 阅读模式"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class="icon-desktop"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p><h3 id="9-标签、分类和搜索"><a href="#9-标签、分类和搜索" class="headerlink" title="9. 标签、分类和搜索"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p><p>标签： 未分类</p><p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p><p><img src="https://www.zybuluo.com/static/img/file-list.png" alt="file-list"></p><h3 id="10-文稿发布和分享"><a href="#10-文稿发布和分享" class="headerlink" title="10. 文稿发布和分享"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p><hr><p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p><p>作者 <a href="http://weibo.com/ghosert" target="_blank" rel="noopener">@ghosert</a><br>2016 年 07月 07日    </p><blockquote id="fn_LaTeX"><sup>LaTeX</sup>. 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a> 参考更多使用方法。<a href="#reffn_LaTeX" title="Jump back to footnote [LaTeX] in the text."> &#8617;</a></blockquote><blockquote id="fn_code"><sup>code</sup>. 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。<a href="#reffn_code" title="Jump back to footnote [code] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Resume</title>
      <link href="/aboutMe/index.html"/>
      <url>/aboutMe/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="Eajack-Lau"><a href="#Eajack-Lau" class="headerlink" title="Eajack Lau"></a>Eajack Lau</h1><p><em>updated on 2019/1/6</em></p><p><em>As for the Chinese version, please use the translation function in Chrome</em></p><h2 id="Contacts"><a href="#Contacts" class="headerlink" title="Contacts"></a>Contacts</h2><ul><li>Email: EajackLR@gmail.com</li><li>Personal Website: <a href="https://eajack.github.io/">https://eajack.github.io/</a></li></ul><h2 id="Education"><a href="#Education" class="headerlink" title="Education"></a>Education</h2><ul><li>Sep. 2015-Present <blockquote><ul><li>College: Jinan University, China</li><li>Major: Electronic Information Science and Technology</li><li>Major courses included: C Programming Language, Signals and Systems,Digital Image Processing, Digital Signal Processing</li></ul></blockquote></li></ul><h2 id="Honors"><a href="#Honors" class="headerlink" title="Honors"></a>Honors</h2><ul><li>Jan. 2018-Dec. 2018<blockquote><ul><li><strong>“National Scholarship”</strong> in the 2017-2018 academic year</li><li><strong>“Excellent Student”</strong> in the 2017-2018 academic year</li><li><strong>Meritorious Winner (international first prize)</strong> in 2018 Mathematical Contest in Modeling (MCM/ICM 2018)</li><li><strong>“Best Project Award”</strong> in “Win with Innovation” Jinan University Innovation Competition (the 3rd Issue in 11th Season)</li></ul></blockquote></li></ul><ul><li><p>Jan. 2017-Dec. 2017</p><blockquote><ul><li><strong>National second prize &amp; Provincial first prize</strong> in 2017 China Undergraduate Mathematical Contest in Modeling (CUMCM 2017)</li><li><strong>Honorable Mention (international second prize)</strong> in 2017 Mathematical Contest in Modeling (MCM/ICM 2017)</li><li><strong>National third prize</strong> in CCSE Cup 2017, National University Students Electrical Math Modeling Competition</li><li>National Encouragement Scholarship in the 2016-2017 academic year</li><li>Excellent League Member of Jinan University in the 2016-2017 academic year</li></ul></blockquote></li><li><p>Jan. 2016-Dec. 2016</p><blockquote><ul><li><strong>Provincial second prize</strong> in 2016 China Undergraduate Mathematical Contest in Modeling (CUMCM 2016)</li><li>National Encouragement Scholarship in the 2015-2016 academic year</li><li>Excellent League Member of Jinan University in the 2015-2016 academic year</li></ul></blockquote></li></ul><h2 id="Project-Experience"><a href="#Project-Experience" class="headerlink" title="Project Experience"></a>Project Experience</h2><h5 id="Apr-2018-Present-Foreground-extraction-algorithm-based-on-face-detection-and-image-segmentation-leader"><a href="#Apr-2018-Present-Foreground-extraction-algorithm-based-on-face-detection-and-image-segmentation-leader" class="headerlink" title="Apr. 2018-Present(Foreground extraction algorithm based on face detection and image segmentation (leader))"></a>Apr. 2018-Present(Foreground extraction algorithm based on face detection and image segmentation (leader))</h5><p>1.Project outcome</p><blockquote><ul><li>Rated as <strong>2018 National Training Program of Innovation for Undergraduates</strong></li></ul></blockquote><p> 2.What I do</p><blockquote><ul><li>complete the C/C++ testing project on GrabCut algorithm(image matting algorithm) based on OpenCV</li><li>Preliminary study on deep matting (especially on <a href="http://xiaoyongshen.me/webpage_portrait/index.html" target="_blank" rel="noopener"><em>Automatic Portrait Segmentation for Image Stylization</em></a> &amp; <a href="http://www.cse.cuhk.edu.hk/leojia/projects/automatting/index.html" target="_blank" rel="noopener"><em>Deep Automatic Portrait Matting</em></a>)</li><li>Literature survey on traditional matting algorithm &amp; deep matting (based on Deep Learning)</li></ul></blockquote><h5 id="Apr-2018-Present-Algorithm-research-on-bus-smart-travel-plan-participant"><a href="#Apr-2018-Present-Algorithm-research-on-bus-smart-travel-plan-participant" class="headerlink" title="Apr. 2018-Present(Algorithm research on bus smart travel plan (participant))"></a>Apr. 2018-Present(Algorithm research on bus smart travel plan (participant))</h5><p>1.Project outcome</p><blockquote><ul><li>Rated as <strong>2018 National Training Program of Innovation for Undergraduates</strong></li></ul></blockquote><p>2.What I do</p><blockquote><ul><li>Complete the C/C++ project about  people counting of bus video</li></ul></blockquote><h5 id="Apr-2018-Sep-2018-Abnormal-behavior-detection-in-trolley-compartment-participant"><a href="#Apr-2018-Sep-2018-Abnormal-behavior-detection-in-trolley-compartment-participant" class="headerlink" title="Apr. 2018-Sep. 2018(Abnormal behavior detection in trolley compartment (participant))"></a>Apr. 2018-Sep. 2018(Abnormal behavior detection in trolley compartment (participant))</h5><p>1.Project outcome</p><blockquote><ul><li><strong> the project of Institute of Internet of Things and Logistics Engineering of Jinan University</strong></li></ul></blockquote><p>2.What I do</p><blockquote><ul><li>complete the background modeling algorithm(codebook algorithm) with C/C++</li></ul></blockquote><h5 id="July-2017-Apr-2018-The-design-of-intelligent-trash-bin-with-image-processing-technology-leader"><a href="#July-2017-Apr-2018-The-design-of-intelligent-trash-bin-with-image-processing-technology-leader" class="headerlink" title="July 2017-Apr. 2018(The design of intelligent trash bin with image processing technology (leader))"></a>July 2017-Apr. 2018(The design of intelligent trash bin with image processing technology (leader))</h5><p>1.Project outcome</p><blockquote><ul><li>Rated as <strong>2017 National Training Program of Innovation for Undergraduates</strong></li><li><strong>“Best Project Award”</strong> in “Win with Innovation” Jinan University Innovation Competition (the 3rd Issue in 11th Season)</li><li>A patent for utility models</li></ul></blockquote><p>2.What I do</p><blockquote><ul><li>Implemented trash image recognition and classification algorithm with C/C++ programming language on OpenCV platform</li><li>Accomplished the testing algorithm with Python on Raspberry Pi board</li><li>Designed trash bin 3D models on the SolidWorks software platform</li></ul></blockquote><h5 id="July-2016-Apr-2017-Intelligent-transportation-project-based-on-video-image-processing-participant"><a href="#July-2016-Apr-2017-Intelligent-transportation-project-based-on-video-image-processing-participant" class="headerlink" title="July 2016-Apr. 2017(Intelligent transportation project based on video image processing (participant))"></a>July 2016-Apr. 2017(Intelligent transportation project based on video image processing (participant))</h5><p>1.Project outcome</p><blockquote><ul><li>Rated as <strong>2016 Provincial Training Program of Innovation for Undergraduates</strong></li></ul></blockquote><p>2.What I do</p><blockquote><ul><li>Completed the design of traffic flow video background extraction algorithm</li></ul></blockquote><h2 id="Organization-experience"><a href="#Organization-experience" class="headerlink" title="Organization experience"></a>Organization experience</h2><ul><li>Sep. 2016-Sep. 2018(<strong>Mathematical Modeling Innovation Practice Base of Jinan University</strong>)<blockquote><p>Work as assistant &amp; minister in academic department</p></blockquote></li></ul><h2 id="Professional-Skills"><a href="#Professional-Skills" class="headerlink" title="Professional Skills"></a>Professional Skills</h2><blockquote><ul><li>Familiar with C/C++ and Python</li><li>Interested in <strong>Computer Vision(CV), Natural Language Processing(NLP fresher) &amp; Machine Learning Field</strong></li><li>Software project experience in image processing and signal processing</li><li>Extensive experience in team work and working on a regular schedule</li><li>English ability: <strong>CET4(573), CET6(502)</strong>; Skillful English reading ability</li></ul></blockquote>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>gallery</title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>timeline</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
