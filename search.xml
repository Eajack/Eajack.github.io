<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>爬虫-聊天机器人 语料收集</title>
      <link href="/2019/10/06/%E7%88%AC%E8%99%AB-%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%20%E8%AF%AD%E6%96%99%E6%94%B6%E9%9B%86/"/>
      <url>/2019/10/06/%E7%88%AC%E8%99%AB-%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%20%E8%AF%AD%E6%96%99%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>最近被分配弄聊天机器人（但也是很人工、暴力的做法。。），只做其中很小的一部分，入门阶段。其间，被分了写个爬虫爬小爱、小冰的聊天回复（给定提问语料），问句都是单轮对话。</p><p>因此，记录下小爱和小冰的爬虫py代码，以后或许会用到🙃。</p><h2 id="1-小爱机器人-回复爬虫"><a href="#1-小爱机器人-回复爬虫" class="headerlink" title="1. 小爱机器人-回复爬虫"></a>1. 小爱机器人-回复爬虫</h2><pre><code class="lang-python">#!\usr\bin\env python# -*- coding: utf-8 -*-&#39;&#39;&#39;Author: Eajackdate:2019/10/6Function：    小爱机器人-语料回复爬虫Attention：    实测，正常情况下，1000~2000条输入会断1次；需要换Cookie/ip等；默认1个句子问3次&#39;&#39;&#39;import requestsimport re, time, jsonheaders = {    &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&#39;,    &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;,    &#39;Accept-Language&#39;: &#39;zh-CN,zh;q=0.9&#39;,    &#39;Cache-Control&#39;: &#39;max-age=0&#39;,    &#39;Connection&#39;: &#39;keep-alive&#39;,    &#39;Cookie&#39;: &#39;XISESSIONID=1baeeit97b4ovtjaydvpmlj41&#39;,#cookie根据自己浏览器F12改    &#39;Host&#39;: &#39;nlp.xiaoi.com&#39;,    &#39;Upgrade-Insecure-Requests&#39;: &#39;1&#39;,    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36&#39;}def get_reply(input):    url = &quot;http://nlp.xiaoi.com/robot/webrobot?&amp;callback=__webrobot_processMsg&amp;data=%7B%22sessionId%22%3A%22a11f40dc641f4ccbb1d5d9a22a137083%22%2C%22robotId%22%3A%22webbot%22%2C%22userId%22%3A%227e90f929650684844babfe4bb629e7f1c%22%2C%22body%22%3A%7B%22content%22%3A%22{}%22%7D%2C%22type%22%3A%22txt%22%7D&quot;.format(input)    r = requests.get(url, headers=headers)    reply_all = r.text.split(&#39;__webrobot_processMsg&#39;)[-1]    print(reply_all)    reply_all = reply_all.replace(&#39;__webrobot_processMsg&#39;,&#39;&#39;)[1:-2]    print(url)    reply_all = json.loads(reply_all)    try:        reply = reply_all[&#39;body&#39;][&#39;content&#39;].strip()    except KeyError:        reply = reply_all[&#39;body&#39;][&#39;data&#39;].strip()    return reply_all, replydef main():    with open(&#39;小爱-输入.txt&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;) as readFile:        file_all = open(&#39;小爱-输出(所有信息).txt&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;)        file_reply = open(&#39;小爱-输出.txt&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;)        for line in readFile:            input = line.strip()            for i in range(3):#默认1个句子问3次                print(&#39;============================================&#39;)                input = input.replace(r&#39;&amp;&#39;, r&#39;%26&#39;)#可去，此处因为url编码把输入“&amp;”搞乱，下%同                input = input.replace(r&#39;%&#39;, r&#39;%25&#39;)                reply_all, reply = get_reply(input)                reply_all_str = json.dumps(reply_all, ensure_ascii=False, \                                           sort_keys=True, indent=4, separators=(&#39;,&#39;, &#39;:&#39;)).strip()                print(reply_all_str)                print(reply)                print(&#39;============================================&#39;)                reply = re.sub(r&#39;\s+&#39;, &#39; &#39;, reply)                file_all.write(&#39;{}\n\n&#39;.format(reply_all_str))                file_reply.write(&#39;{}&amp;&amp;{}\n&#39;.format(input, reply))                time.sleep(2)            time.sleep(1)        file_all.close()        file_reply.close()if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="2-小冰机器人-回复爬虫"><a href="#2-小冰机器人-回复爬虫" class="headerlink" title="2. 小冰机器人-回复爬虫"></a>2. 小冰机器人-回复爬虫</h2><p>小冰的有点麻烦，没找到公开的网址形式API接口。此处用的是微博小冰接口，需要登陆微博，用selenium模拟登陆，正常情况下，爬虫不会断。期间需要手动操作2次：（1）微博登陆有，代码time.sleep(20) 用于手动按验证码（2）私信界面后同sleep，用于点击小冰私信窗口。后面全自动收集</p><pre><code class="lang-python">#!\usr\bin\env python# -*- coding: utf-8 -*-&#39;&#39;&#39;Author: Eajackdate:2019/10/6Function：    小冰机器人-语料回复爬虫Attention：    此处用的是微博小冰接口，需要登陆微博，用selenium模拟登陆，正常情况下，爬虫不会断。期间需要手动操作2次：（1）微博登陆有，代码time.sleep(20) 用于手动按验证码（2）私信界面后同sleep，用于点击小冰私信窗口。后面全自动收集    默认1个句子问3次&#39;&#39;&#39;import requestsfrom selenium import webdriverfrom selenium.webdriver.common.keys import Keysfrom bs4 import BeautifulSoupimport json,os,re,timeweiboNum = &#39;*******&#39;#自己的微博账号WeiboPassword = &#39;*******&#39;#自己的微博密码def main():    #微博登录    global content_before_list    weibo_loginUrl = r&#39;https://passport.weibo.cn/signin/login&#39;    #1- 先打开登陆界面    driver = webdriver.Chrome()    time.sleep(5)    driver.maximize_window()    #窗口最大化    driver.implicitly_wait(10)  # 隐式等待    driver.get(weibo_loginUrl)    ## 模拟登录    driver.find_element_by_id(&#39;loginName&#39;).clear()    driver.find_element_by_id(&#39;loginName&#39;).send_keys(weiboNum)    driver.find_element_by_id(&#39;loginPassword&#39;).clear()    driver.find_element_by_id(&#39;loginPassword&#39;).send_keys(WeiboPassword)    time.sleep(5)    driver.find_element_by_id(&#39;loginAction&#39;).click()    time.sleep(20)    #2- 打开小冰私聊界面    weibo_XiaoBingUrl = r&#39;https://api.weibo.com/chat/#/chat?source_from=5&#39;    # 打开新Tab    js = r&quot; window.open(&#39; &quot; + weibo_XiaoBingUrl + r&quot;&#39;)&quot;  # 可以看到是打开新的标签页，不是窗口    driver.execute_script(js)    time.sleep(5)    # 窗口切换    # 获取打开的多个窗口句柄    windows = driver.window_handles    # 切换到当前最新打开的窗口    driver.switch_to.window(windows[-1])    # sleep 人工点击小冰    time.sleep(20)    with open(&#39;小冰-输入.txt&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;) as readFile:        ask2Reply = []        flag = False        for line in readFile:            input = line.strip()            for i in range(3):#默认1个句子问3次                print(&#39;============================================&#39;)                try:                    # 输入文字                    driver.find_element_by_id(&#39;webchat-textarea&#39;).clear()                    driver.find_element_by_id(&#39;webchat-textarea&#39;).send_keys(input)                    driver.find_element_by_id(&quot;webchat-textarea&quot;).send_keys(Keys.ENTER)                    time.sleep(5)                    html = driver.page_source                    html_bs = BeautifulSoup(html, &#39;lxml&#39;)                    content_now_list = html_bs.find_all(&quot;p&quot;, class_=&quot;puretext font14 c333 wordbreak&quot;)                    content_now_list = [ item.get_text() for item in content_now_list ]                    input_index = 0                    for i in range(len(content_now_list)-1, -1, -1):                        if content_now_list[i] == input:                            input_index = i                            break                    reply_str = &#39; &#39;.join(content_now_list[input_index+1:])                    ask2Reply.append([input, reply_str])                except Exception as e:                    flag = True                    break            if(flag):                break        with open(&#39;小冰-输出.txt&#39;, &#39;a&#39;, encoding=&#39;utf-8&#39;) as writeFile:            for item in ask2Reply:                writeFile.write(&#39;{}&amp;&amp;{}\n&#39;.format(item[0], item[1]))if __name__ == &#39;__main__&#39;:    main()</code></pre><h2 id="3-输出语料格式"><a href="#3-输出语料格式" class="headerlink" title="3. 输出语料格式"></a>3. 输出语料格式</h2><p>以上代码输出语料格式一致，均如下</p><pre><code>……讲个笑话&amp;&amp;老板：“你物流专业毕业的？”我：“是的。”老板：“很好，你马上去帮我把这个快递寄了。”讲个笑话&amp;&amp;我不！该你讲了！讲个笑话&amp;&amp;妈妈上班请假回家，要带三岁的女儿去逛街。出门前妈妈对女儿说：快向保姆阿姨说Bye-Bye。女儿照说Bye-Bye，当妈妈又说：向阿姨亲一个。女儿带着恐惧的眼神，极力的摇头不肯亲阿姨。妈妈带着生气的语说：为什么不亲？女儿仍带着恐惧的语气大声说：爸爸早上偷亲阿姨后，结果被打的好惨！么么哒&amp;&amp;么么~么么么么哒&amp;&amp;么么么么么么么么么么么么么么么么么哒么么哒&amp;&amp;么么哒~要不要来个唇膏……</code></pre>]]></content>
      
      
      <categories>
          
          <category> 聊天机器人 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> Python </tag>
            
            <tag> 聊天机器人 </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eajack LeetCode Notes- Day6</title>
      <link href="/2019/08/12/Eajack%20LeetCode%20Notes-%20Day6/"/>
      <url>/2019/08/12/Eajack%20LeetCode%20Notes-%20Day6/</url>
      
        <content type="html"><![CDATA[<h3 id="Q45"><a href="#Q45" class="headerlink" title="Q45"></a>Q45</h3><h4 id="1-题目信息"><a href="#1-题目信息" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/implement-stack-using-queues/description/" target="_blank" rel="noopener">用队列实现栈</a></p></li><li><p>编号&amp;难度：[225]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/stack" target="_blank" rel="noopener"><code>stack</code></a> | <a href="https://leetcode.com/tag/design" target="_blank" rel="noopener"><code>design</code></a></p></li><li><p>描述：使用队列实现栈的下列操作：</p><ul><li>push(x) — 元素 x 入栈</li><li>pop() — 移除栈顶元素</li><li>top() — 获取栈顶元素</li><li>empty() — 返回栈是否为空</li></ul><p><strong>注意:</strong></p><ul><li>你只能使用队列的基本操作— 也就是 <code>push to back</code>, <code>peek/pop from front</code>, <code>size</code>, 和 <code>is empty</code> 这些操作是合法的。</li><li>你所使用的语言也许不支持队列。 你可以使用 list 或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li><li>你可以假设所有操作都是有效的（例如, 对一个空的栈不会调用 pop 或者 top 操作）。</li></ul></li></ul></blockquote><h4 id="2-个人Code"><a href="#2-个人Code" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=225 lang=cpp * * [225] 用队列实现栈 */class MyStack {    queue&lt;int&gt; q1, q2;public:    /** Initialize your data structure here. */    MyStack() {    }    /** Push element x onto stack. */    void push(int x) {        q1.push(x);    }    /** Removes the element on top of the stack and returns that element. */    int pop() {        //首先pop出到q2，直到只剩下q1栈顶        while(q1.size() &gt; 1)        {            q2.push(q1.front());            q1.pop();        }        //push逆向        int topNum = q1.front();        q1.pop();        while(q2.size() &gt; 0)        {            q1.push(q2.front());            q2.pop();        }        return topNum;    }    /** Get the top element. */    int top() {        //首先pop出到q2，直到只剩下q1栈顶        while(q1.size() &gt; 1)        {            q2.push(q1.front());            q1.pop();        }        //push逆向        int topNum = q1.front();        q1.pop();        q2.push(topNum);        while(q2.size() &gt; 0)        {            q1.push(q2.front());            q2.pop();        }        return topNum;    }    /** Returns whether the stack is empty. */    bool empty() {        return (q1.empty());    }};/** * Your MyStack object will be instantiated and called as such: * MyStack* obj = new MyStack(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;top(); * bool param_4 = obj-&gt;empty(); */</code></pre><blockquote><ul><li>思路：2个queue实现1个stack，1个queue用来缓存pop过程出来的元素，另一个栈直接储存push进来的元素</li></ul></blockquote><h3 id="Q46"><a href="#Q46" class="headerlink" title="Q46"></a>Q46</h3><h4 id="1-题目信息-1"><a href="#1-题目信息-1" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/implement-stack-using-queues/description/" target="_blank" rel="noopener"><a href="https://leetcode-cn.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener">翻转二叉树</a></a></p></li><li><p>编号&amp;难度：[226]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/tree" target="_blank" rel="noopener"><code>tree</code></a></p></li><li><p>描述：</p><p>输入：</p><pre><code>     4   /   \  2     7 / \   / \1   3 6   9</code></pre><p>输出：</p><pre><code>     4   /   \  7     2 / \   / \9   6 3   1</code></pre></li></ul></blockquote><h4 id="2-个人Code-1"><a href="#2-个人Code-1" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=226 lang=cpp * * [226] 翻转二叉树 *//** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    TreeNode* invertTree(TreeNode* root) {        if(!root || (!root-&gt;left &amp;&amp; !root-&gt;right)){            return root;        }        else{            TreeNode* temp = root-&gt;left;            root-&gt;left = root-&gt;right;            root-&gt;right = temp;            if(root-&gt;left)                TreeNode *trash1 = invertTree(root-&gt;left);            if(root-&gt;right)                TreeNode *trash2 = invertTree(root-&gt;right);        }        return root;    }};</code></pre><blockquote><ul><li>思路：首先根部左右子树交换，然后递归地对左右子树调用原函数</li></ul></blockquote><h3 id="Q47"><a href="#Q47" class="headerlink" title="Q47"></a>Q47</h3><h4 id="1-题目信息-2"><a href="#1-题目信息-2" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：<a href="https://leetcode-cn.com/problems/power-of-two/description/" target="_blank" rel="noopener">2的幂</a></li><li>编号&amp;难度：[226]，easy</li><li>Tags：<a href="https://leetcode.com/tag/math" target="_blank" rel="noopener"><code>math</code></a> | <a href="https://leetcode.com/tag/bit-manipulation" target="_blank" rel="noopener"><code>bit-manipulation</code></a></li><li>描述：给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</li></ul></blockquote><h4 id="2-个人Code-2"><a href="#2-个人Code-2" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=231 lang=cpp * * [231] 2的幂 */class Solution {public:    bool isPowerOfTwo(int n) {        //注意：n&amp;(n-1) == 0是错的, 应该是(n&amp;(n-1)) == 0        return ( (n&gt;0) &amp;&amp; !(n&amp;(n-1)));    }};</code></pre><blockquote><ul><li>思路：看了solution，检查二进制表示的首位digit是否为1即可</li></ul></blockquote><h3 id="Q48"><a href="#Q48" class="headerlink" title="Q48"></a>Q48</h3><h4 id="1-题目信息-3"><a href="#1-题目信息-3" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：<a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/description/" target="_blank" rel="noopener">用栈实现队列</a></li><li>编号&amp;难度：[226]，easy</li><li>Tags：<a href="https://leetcode.com/tag/stack" target="_blank" rel="noopener"><code>stack</code></a> | <a href="https://leetcode.com/tag/design" target="_blank" rel="noopener"><code>design</code></a></li><li>描述：使用栈实现队列的下列操作：<ul><li>push(x) — 将一个元素放入队列的尾部。</li><li>pop() — 从队列首部移除元素。</li><li>peek() — 返回队列首部的元素。</li><li>empty() — 返回队列是否为空。</li></ul></li></ul></blockquote><h4 id="2-个人Code-3"><a href="#2-个人Code-3" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=232 lang=cpp * * [232] 用栈实现队列 */class MyQueue {public:    vector&lt;int&gt; s1, s2;     /** Initialize your data structure here. */    MyQueue() {    }    /** Push element x to the back of queue. */    void push(int x) {        s1.push_back(x);    }    /** Removes the element from in front of queue and returns that element. */    int pop() {        while(s1.size() != 1){            s2.push_back(s1.back());            s1.pop_back();                   }        int top_val = s1.front();        s1.pop_back();        while(!s2.empty()){            s1.push_back(s2.back());            s2.pop_back();        }        return top_val;    }    /** Get the front element. */    int peek() {        while(s1.size() != 1){            s2.push_back(s1.back());            s1.pop_back();                   }        int top_val = s1.front();        while(!s2.empty()){            s1.push_back(s2.back());            s2.pop_back();        }        return top_val;    }    /** Returns whether the queue is empty. */    bool empty() {        return s1.empty();    }};/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */</code></pre><blockquote><ul><li>思路：和“用队列实现栈”差不多。这里用2个栈实现队列，其中1个栈用push代替队列的enqueue，另一个栈作为缓存区辅助dequeue</li></ul></blockquote><h3 id="Q49"><a href="#Q49" class="headerlink" title="Q49"></a>Q49</h3><h4 id="1-题目信息-4"><a href="#1-题目信息-4" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：<a href="https://leetcode-cn.com/problems/palindrome-linked-list/description/" target="_blank" rel="noopener">回文链表</a></li><li>编号&amp;难度：[226]，easy</li><li>Tags：<a href="https://leetcode.com/tag/linked-list" target="_blank" rel="noopener"><code>linked-list</code></a> | <a href="https://leetcode.com/tag/two-pointers" target="_blank" rel="noopener"><code>two-pointers</code></a></li><li>描述：请判断一个链表是否为回文链表。</li></ul></blockquote><h4 id="2-个人Code-4"><a href="#2-个人Code-4" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=234 lang=cpp * * [234] 回文链表 *//** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    bool returnFlag = false;    void isHeadEqualTail(ListNode* head, int len) {        if(len &lt;= 1) {            returnFlag = true;        }        else {            ListNode* tail = head;            int cnt = len - 1;            while(cnt--) tail = tail-&gt;next;            if(head-&gt;val != tail-&gt;val) {                returnFlag = false;            }            else {                isHeadEqualTail(head-&gt;next, len-2);            }        }    }    bool isPalindrome(ListNode* head) {        ListNode* temp = head;        int len = 0;        while (temp) {            ++len;            temp = temp-&gt;next;        }        if(len &lt;= 1)        {            return true;        }        else        {            isHeadEqualTail(head, len);        }        return returnFlag;    }};</code></pre><blockquote><ul><li>思路：最简单思路是首位部双指针，这代码思路是：递归判断首位val是否相等，通过链表长和表头变化递归</li></ul></blockquote><h3 id="Q50"><a href="#Q50" class="headerlink" title="Q50"></a>Q50</h3><h4 id="1-题目信息-5"><a href="#1-题目信息-5" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：<a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/description/" target="_blank" rel="noopener">删除链表中的节点</a></li><li>编号&amp;难度：[237]，easy</li><li>Tags：<a href="https://leetcode.com/tag/linked-list" target="_blank" rel="noopener"><code>linked-list</code></a></li><li>描述：请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</li></ul></blockquote><h4 id="2-个人Code-5"><a href="#2-个人Code-5" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=237 lang=cpp * * [237] 删除链表中的节点 *//** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    void deleteNode(ListNode* node) {        if(node == nullptr) return;        ListNode* temp = node-&gt;next;        node-&gt;val = temp-&gt;val;        node-&gt;next = temp-&gt;next;        delete temp;    }};</code></pre><blockquote><ul><li>思路：看了solution，只能说这个巧妙。。并没有传表头进来。<strong>因为不是首位部node，所以可以复制下一个到当前位，然后删除下一个node。</strong></li></ul></blockquote><h3 id="Q51"><a href="#Q51" class="headerlink" title="Q51"></a>Q51</h3><h4 id="1-题目信息-6"><a href="#1-题目信息-6" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/valid-anagram/description/" target="_blank" rel="noopener">有效的字母异位词</a></p></li><li><p>编号&amp;难度：[242]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/hash-table" target="_blank" rel="noopener"><code>hash-table</code></a> | <a href="https://leetcode.com/tag/sort" target="_blank" rel="noopener"><code>sort</code></a></p></li><li><p>描述：给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p></li><li><p>例子：</p><p><strong>示例 1:</strong></p><pre><code>输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;输出: true</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: s = &quot;rat&quot;, t = &quot;car&quot;输出: false</code></pre></li></ul></blockquote><h4 id="2-个人Code-6"><a href="#2-个人Code-6" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=242 lang=cpp * * [242] 有效的字母异位词 */class Solution {public:    bool isAnagram(string s, string t) {        if((s.length() || t.length()) &amp;&amp; (s.length() != t.length())){            return false;        }        else if(s.length() == 0 &amp;&amp; t.length() == 0){            return true;        }        unordered_map&lt;char, int&gt; s_num, t_num;        for(char ch:s){            if(s_num.find(ch) == s_num.end()){                s_num[ch] = 1;            }            else{                s_num[ch]++;            }        }        for(char ch:t){            if(t_num.find(ch) == t_num.end()){                t_num[ch] = 1;            }            else{                t_num[ch]++;            }        }        for(auto iter=s_num.begin(); iter != s_num.end(); iter++){           if(t_num[iter-&gt;first] != iter-&gt;second){               return false;           }        }        return true;    }};</code></pre><blockquote><ul><li>思路：看了solution。solution给出2种方案：<strong>（1）统计char出现个数，二者对应相等即可（2）sort后的2个string相等</strong></li></ul></blockquote><h3 id="Q52"><a href="#Q52" class="headerlink" title="Q52"></a>Q52</h3><h4 id="1-题目信息-7"><a href="#1-题目信息-7" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/binary-tree-paths/description/" target="_blank" rel="noopener">二叉树的所有路径</a></p></li><li><p>编号&amp;难度：[252]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/tree" target="_blank" rel="noopener"><code>tree</code></a> | <a href="https://leetcode.com/tag/depth-first-search" target="_blank" rel="noopener"><code>depth-first-search</code></a></p></li><li><p>描述：给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p></li><li><p>例子：</p><pre><code>输入:   1 /   \2     3 \  5输出: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]解释: 所有根节点到叶子节点的路径为: 1-&gt;2-&gt;5, 1-&gt;3</code></pre></li></ul></blockquote><h4 id="2-个人Code-7"><a href="#2-个人Code-7" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=257 lang=cpp * * [257] 二叉树的所有路径 *//** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    void getPath(TreeNode* node, vector&lt;string&gt;&amp; paths, string path){        if(!node-&gt;left &amp;&amp; !node-&gt;right){            paths.push_back(path);            return;        }        if(node-&gt;left){            getPath(node-&gt;left, paths, path+&quot;-&gt;&quot;+to_string(node-&gt;left-&gt;val));        }        if(node-&gt;right){            getPath(node-&gt;right, paths, path+&quot;-&gt;&quot;+to_string(node-&gt;right-&gt;val));        }    }    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {        vector&lt;string&gt; paths;        if(root){            getPath(root, paths, to_string(root-&gt;val));        }        return paths;    }};</code></pre><blockquote><ul><li>思路：看了solution，记住，深度遍历</li></ul></blockquote><h3 id="Q53"><a href="#Q53" class="headerlink" title="Q53"></a>Q53</h3><h4 id="1-题目信息-8"><a href="#1-题目信息-8" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/add-digits/description/" target="_blank" rel="noopener">各位相加</a></p></li><li><p>编号&amp;难度：[258]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/math" target="_blank" rel="noopener"><code>math</code></a></p></li><li><p>描述：给定一个非负整数 <code>num</code>，反复将各个位上的数字相加，直到结果为一位数。</p></li><li><p>例子：</p><pre><code>输入: 38输出: 2 解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。</code></pre></li></ul></blockquote><h4 id="2-个人Code-8"><a href="#2-个人Code-8" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=258 lang=cpp * * [258] 各位相加 */class Solution {public:    int addDigits(int num) {        int sum;        do{            sum = 0;            vector&lt;int&gt; digits;            while(num/10){                digits.push_back(num%10);                num /= 10;            }            digits.push_back(num);            for(int digit:digits){                sum += digit;            }            num = sum;        }        while(num &gt;= 10);        return num;    }};</code></pre><blockquote><ul><li>思路：提取各位数字求和相加</li></ul></blockquote><h3 id="Q54"><a href="#Q54" class="headerlink" title="Q54"></a>Q54</h3><h4 id="1-题目信息-9"><a href="#1-题目信息-9" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/move-zeroes/description/" target="_blank" rel="noopener">移动零</a></p></li><li><p>编号&amp;难度：[283]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/array" target="_blank" rel="noopener"><code>array</code></a> | <a href="https://leetcode.com/tag/two-pointers" target="_blank" rel="noopener"><code>two-pointers</code></a></p></li><li><p>描述：给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p></li><li><p>例子：</p><pre><code>输入: [0,1,0,3,12]输出: [1,3,12,0,0]</code></pre></li></ul></blockquote><h4 id="2-个人Code-9"><a href="#2-个人Code-9" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=283 lang=cpp * * [283] 移动零 */class Solution {public:    void moveZeroes(vector&lt;int&gt;&amp; nums) {        int temp, j;        for(int i=0; i&lt;nums.size(); i++){            if(nums[i] == 0){                j = i+1;                while(1){                    if(nums[i] == 0 &amp;&amp; j &lt; nums.size()){                        temp = nums[i];                        nums[i] = nums[j];                        nums[j] = temp;                        j++;                    }                    else{                        break;                    }                }                if(j &gt;= nums.size()){                    break;                }            }        }    }};</code></pre><blockquote><ul><li>思路：遍历逐位右移，solution思路更好：优先把非0值前移，最后后面至0</li></ul></blockquote><h3 id="Q55"><a href="#Q55" class="headerlink" title="Q55"></a>Q55</h3><h4 id="1-题目信息-10"><a href="#1-题目信息-10" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：<a href="https://leetcode-cn.com/problems/word-pattern/description/" target="_blank" rel="noopener">单词规律</a></li><li>编号&amp;难度：[290]，easy</li><li>Tags：<a href="https://leetcode.com/tag/hash-table" target="_blank" rel="noopener"><code>hash-table</code></a></li><li>描述：给定一种规律 <code>pattern</code> 和一个字符串 <code>str</code> ，判断 <code>str</code> 是否遵循相同的规律。这里的 <strong>遵循</strong> 指完全匹配，例如， <code>pattern</code> 里的每个字母和字符串 <code>str</code> 中的每个非空单词之间存在着双向连接的对应规律。</li><li>例子：</li></ul><p><strong>示例1:</strong></p><pre><code>输入: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;输出: true</code></pre><p><strong>示例 2:</strong></p><pre><code>输入:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;输出: false</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;输出: false</code></pre><p><strong>示例 4:</strong></p><pre><code>输入: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;输出: false</code></pre></blockquote><h4 id="2-个人Code-10"><a href="#2-个人Code-10" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=290 lang=cpp * * [290] 单词规律 */class Solution {public:    vector&lt;string&gt; split(string str){        vector&lt;string&gt; str_split;        string split_one;        for(int i=0; i&lt;=str.size(); i++){            if(str[i] == &#39; &#39; || i == str.size()){                str_split.push_back(split_one);                split_one = &quot;&quot;;            }            else{                split_one += str[i];            }        }        return str_split;    }    bool wordPattern(string pattern, string str) {        vector&lt;string&gt; str_split = split(str);        if(str_split.size() != pattern.length()){            return false;        }        unordered_map&lt;char, string&gt; table1;        for(int i=0; i&lt;pattern.size(); i++){            if(table1.find(pattern[i]) == table1.end()){                for(auto iter = table1.begin(); iter != table1.end();iter++){                    if(iter-&gt;second == str_split[i]){                        return false;                    }                }                table1[pattern[i]] = str_split[i];            }            else{                if(table1[pattern[i]] != str_split[i]){                    return false;                }            }        }        return true;    }};</code></pre><blockquote><ul><li>思路：字符串split + 双向map检查</li></ul></blockquote><h3 id="Q56"><a href="#Q56" class="headerlink" title="Q56"></a>Q56</h3><h4 id="1-题目信息-11"><a href="#1-题目信息-11" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：<a href="https://leetcode-cn.com/problems/power-of-three/description/" target="_blank" rel="noopener">3的幂</a></li><li>编号&amp;难度：[326]，easy</li><li>Tags：<a href="https://leetcode.com/tag/math" target="_blank" rel="noopener"><code>math</code></a></li><li>描述：给定一个整数，写一个函数来判断它是否是 3 /n的幂次方。</li></ul></blockquote><h4 id="2-个人Code-11"><a href="#2-个人Code-11" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=326 lang=cpp * * [326] 3的幂 */class Solution {public:    string dec2Ndigit(int num, int n){        string num_digit = &quot;&quot;;        while(num/n){            num_digit = to_string(num%n) + num_digit;            num /= n;        }        num_digit = to_string(num) + num_digit;        return num_digit;    }    bool isPowerOfThree(int n) {        string n_digit = dec2Ndigit(n, 3);        int sum = 0;        for(char ch:n_digit){            sum += (ch-&#39;0&#39;);        }        if(sum == 1 &amp;&amp; n_digit[0] == &#39;1&#39;){            return true;        }        return false;    }};</code></pre><blockquote><ul><li>思路：和2的幂思路一样，区别在于3进制。其实n的幂思路一致，只是转成n进制表示即可</li></ul></blockquote><h3 id="Q57"><a href="#Q57" class="headerlink" title="Q57"></a>Q57</h3><h4 id="1-题目信息-12"><a href="#1-题目信息-12" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：<a href="https://leetcode-cn.com/problems/reverse-string/description/" target="_blank" rel="noopener">反转字符串</a></li><li>编号&amp;难度：[344]，easy</li><li>Tags：<a href="https://leetcode.com/tag/two-pointers" target="_blank" rel="noopener"><code>two-pointers</code></a> | <a href="https://leetcode.com/tag/string" target="_blank" rel="noopener"><code>string</code></a></li><li>描述：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。不要给另外的数组分配额外的空间，你必须<strong>原地修改输入数组</strong>、使用 O(1) 的额外空间解决这一问题。你可以假设数组中的所有字符都是 <a href="https://baike.baidu.com/item/ASCII" target="_blank" rel="noopener">ASCII</a> 码表中的可打印字符。</li></ul></blockquote><h4 id="2-个人Code-12"><a href="#2-个人Code-12" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=344 lang=cpp * * [344] 反转字符串 */class Solution {public:    void reverseString(vector&lt;char&gt;&amp; s) {        int i = 0, j = s.size()-1;        char temp;        while(i&lt;=j){            temp = s[i];            s[i] = s[j];            s[j] = temp;            i++;            j--;        }    }};</code></pre><blockquote><ul><li>思路：双指针简单思路</li></ul></blockquote><h3 id="Q58"><a href="#Q58" class="headerlink" title="Q58"></a>Q58</h3><h4 id="1-题目信息-13"><a href="#1-题目信息-13" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：<a href="https://leetcode-cn.com/problems/reverse-vowels-of-a-string/description/" target="_blank" rel="noopener">反转字符串中的元音字母</a></li><li>编号&amp;难度：[345]，easy</li><li>Tags：<a href="https://leetcode.com/tag/two-pointers" target="_blank" rel="noopener"><code>two-pointers</code></a> | <a href="https://leetcode.com/tag/string" target="_blank" rel="noopener"><code>string</code></a></li><li>描述：编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</li></ul></blockquote><h4 id="2-个人Code-13"><a href="#2-个人Code-13" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=345 lang=cpp * * [345] 反转字符串中的元音字母 */class Solution {public:    string reverseVowels(string s) {                int i = 0, j = s.size()-1;        char temp;        while(i&lt;j){            i = s.find_first_of(&quot;aeiouAEIOU&quot;, i);            j = s.find_last_of(&quot;aeiouAEIOU&quot;, j);            if (i &lt; j){                swap(s[i++],s[j--]);            }        }        return s;    }};</code></pre><blockquote><ul><li>思路：看了solution。。因为题意一看理解错了。关键在于find_first_of、find_last_of</li></ul></blockquote><h3 id="Q59"><a href="#Q59" class="headerlink" title="Q59"></a>Q59</h3><h4 id="1-题目信息-14"><a href="#1-题目信息-14" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/description/" target="_blank" rel="noopener">两个数组的交集</a></li><li>编号&amp;难度：[349]，easy</li><li>Tags：<a href="https://leetcode.com/tag/hash-table" target="_blank" rel="noopener"><code>hash-table</code></a> | <a href="https://leetcode.com/tag/two-pointers" target="_blank" rel="noopener"><code>two-pointers</code></a> | <a href="https://leetcode.com/tag/binary-search" target="_blank" rel="noopener"><code>binary-search</code></a> | <a href="https://leetcode.com/tag/sort" target="_blank" rel="noopener"><code>sort</code></a></li><li>描述：给定两个数组，编写一个函数来计算它们的交集。</li></ul></blockquote><h4 id="2-个人Code-14"><a href="#2-个人Code-14" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=349 lang=cpp * * [349] 两个数组的交集 */class Solution {public:    vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        unordered_map&lt;int,int&gt; map1, map2;        for(int i=0; i&lt;nums1.size(); i++){            if( map1.find(nums1[i]) == map1.end() ){                map1[nums1[i]] = 0;            }        }        for(int i=0; i&lt;nums2.size(); i++){            if( map2.find(nums2[i]) == map2.end() ){                map2[nums2[i]] = 0;            }        }        //begin        vector&lt;int&gt; nums_inter;        for(auto iter1 = map1.begin(); iter1 != map1.end(); iter1++){            if(map2.find(iter1-&gt;first) != map2.end()){                nums_inter.push_back(iter1-&gt;first);            }        }        return nums_inter;    }};</code></pre><blockquote><ul><li>思路：储存2个数组的次数，遍历数组</li></ul></blockquote><h3 id="Q60"><a href="#Q60" class="headerlink" title="Q60"></a>Q60</h3><h4 id="1-题目信息-15"><a href="#1-题目信息-15" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/description/" target="_blank" rel="noopener">两个数组的交集 II</a></li><li>编号&amp;难度：[350]，easy</li><li>Tags：<a href="https://leetcode.com/tag/hash-table" target="_blank" rel="noopener"><code>hash-table</code></a> | <a href="https://leetcode.com/tag/two-pointers" target="_blank" rel="noopener"><code>two-pointers</code></a> | <a href="https://leetcode.com/tag/binary-search" target="_blank" rel="noopener"><code>binary-search</code></a> | <a href="https://leetcode.com/tag/sort" target="_blank" rel="noopener"><code>sort</code></a></li><li>描述：给定两个数组，编写一个函数来计算它们的交集。<strong>说明：</strong>输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。我们可以不考虑输出结果的顺序。</li></ul></blockquote><h4 id="2-个人Code-15"><a href="#2-个人Code-15" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=350 lang=cpp * * [350] 两个数组的交集 II */class Solution {public:    void getArrayInter(vector&lt;int&gt; nums1, vector&lt;int&gt; nums2, \        vector&lt;int&gt;&amp; array_inter){        for(int i=0; i&lt;nums1.size(); i++){            auto iter_find = find(nums2.begin(), nums2.end(), nums1[i]);            if( iter_find != nums2.end() ){                array_inter.push_back(nums1[i]);                nums2.erase(iter_find);            }        }    }    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        vector&lt;int&gt; array_inter;        if(nums1.size() &lt; nums2.size()){            getArrayInter(nums1,nums2,array_inter);        }        else{            getArrayInter(nums2,nums1,array_inter);        }        return array_inter;    }};</code></pre><blockquote><ul><li>思路：遍历nums1，在nums2中查找nums1数字，然后每当查找到就erase nums2中对应数字</li></ul></blockquote><h3 id="Q60-1"><a href="#Q60-1" class="headerlink" title="Q60"></a>Q60</h3><h4 id="1-题目信息-16"><a href="#1-题目信息-16" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：<a href="https://leetcode-cn.com/problems/valid-perfect-square/description/" target="_blank" rel="noopener">有效的完全平方数</a></li><li>编号&amp;难度：[367]，easy</li><li>Tags：<a href="https://leetcode.com/tag/math" target="_blank" rel="noopener"><code>math</code></a> | <a href="https://leetcode.com/tag/binary-search" target="_blank" rel="noopener"><code>binary-search</code></a></li><li>描述：给定一个正整数 <em>num</em>，编写一个函数，如果 <em>num</em> 是一个完全平方数，则返回 True，否则返回 False。</li></ul></blockquote><h4 id="2-个人Code-16"><a href="#2-个人Code-16" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=367 lang=cpp * * [367] 有效的完全平方数 */class Solution {public:    bool isPerfectSquare(int num) {        long left = 0, right = num, mid = num/2;        while(left &lt; right){            if(left+1 == right){                if(left*left == num || right*right == num){                    return true;                }                else{                    return false;                }            }            mid = (left+right)/2;            if(mid*mid &lt; num){                left = mid;            }            else if(mid*mid &gt; num){                right = mid;            }            else{                return true;            }        }        return false;    }};</code></pre><blockquote><ul><li>思路：变相二分法，注意<code>if(left+1 == right)</code></li></ul></blockquote><h3 id="Q61"><a href="#Q61" class="headerlink" title="Q61"></a>Q61</h3><h4 id="1-题目信息-17"><a href="#1-题目信息-17" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：<a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/description/" target="_blank" rel="noopener">字符串中的第一个唯一字符</a></li><li>编号&amp;难度：[387]，easy</li><li>Tags：<a href="https://leetcode.com/tag/hash-table" target="_blank" rel="noopener"><code>hash-table</code></a> | <a href="https://leetcode.com/tag/string" target="_blank" rel="noopener"><code>string</code></a></li><li>描述：给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</li></ul></blockquote><h4 id="2-个人Code-17"><a href="#2-个人Code-17" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=387 lang=cpp * * [387] 字符串中的第一个唯一字符 */class Solution {public:    int firstUniqChar(string s) {        unordered_map&lt;char,int&gt; map_s;        vector&lt;int&gt; vector_s;        for(int i=0; i&lt;s.length(); i++){            if(map_s.find(s[i]) == map_s.end()){                map_s[s[i]] = i;                vector_s.push_back(i);            }            else{                auto iter_find = find(vector_s.begin(), vector_s.end(),map_s[s[i]]);                if( iter_find != vector_s.end() ){                    vector_s.erase(iter_find);                }            }        }        return (vector_s.size())?\            ( *(min_element(vector_s.begin(),vector_s.end())) ):(-1);    }};</code></pre><blockquote><ul><li>思路：遍历字符串，map_s储存不重复字符index，vector_s储存字符index，当出现重复字符时erase掉vector_s中对应的index。最后，返回vector_s最小值</li></ul></blockquote><h3 id="Q62"><a href="#Q62" class="headerlink" title="Q62"></a>Q62</h3><h4 id="1-题目信息-18"><a href="#1-题目信息-18" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：<a href="https://leetcode-cn.com/problems/find-the-difference/description/" target="_blank" rel="noopener">找不同</a></li><li>编号&amp;难度：[389]，easy</li><li>Tags：<a href="https://leetcode.com/tag/hash-table" target="_blank" rel="noopener"><code>hash-table</code></a> | <a href="https://leetcode.com/tag/bit-manipulation" target="_blank" rel="noopener"><code>bit-manipulation</code></a></li><li>描述：给定两个字符串 <strong><em>s</em></strong> 和 <strong><em>t</em></strong>，它们只包含小写字母。字符串 <strong>t</strong> 由字符串 <strong>s</strong> 随机重排，然后在随机位置添加一个字母。请找出在 <strong><em>t</em></strong> 中被添加的字母。</li></ul></blockquote><h4 id="2-个人Code-18"><a href="#2-个人Code-18" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=389 lang=cpp * * [389] 找不同 */class Solution {public:    char findTheDifference(string s, string t) {        unordered_map&lt;char,int&gt; map;        for(char ch_s:s){            if(map.find(ch_s) != map.end()){                map[ch_s]++;            }            else{                map[ch_s] = 1;            }        }        for(char t_ch:t){            if(map.find(t_ch) == map.end() || map[t_ch] == 0){                return t_ch;            }            else{                map[t_ch]--;            }        }        return &#39;0&#39;;//trash code    }};</code></pre><blockquote><ul><li>思路：遍历s记录字符频数map，然后遍历t，在map中查找t字符判断<code>if(map.find(t_ch) == map.end() || map[t_ch] == 0)</code>，否则频数减一</li></ul></blockquote><h3 id="Q63"><a href="#Q63" class="headerlink" title="Q63"></a>Q63</h3><h4 id="1-题目信息-19"><a href="#1-题目信息-19" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：<a href="https://leetcode-cn.com/problems/sum-of-left-leaves/description/" target="_blank" rel="noopener">左叶子之和</a></li><li>编号&amp;难度：[404]，easy</li><li>Tags：<a href="https://leetcode.com/tag/tree" target="_blank" rel="noopener"><code>tree</code></a></li><li>描述：计算给定二叉树的所有左叶子之和。</li></ul></blockquote><h4 id="2-个人Code-19"><a href="#2-个人Code-19" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=404 lang=cpp * * [404] 左叶子之和 *//** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    void getLeftVals(TreeNode* root, vector&lt;int&gt;&amp; leftNodesVals, int leftOrRight){        if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; leftOrRight == 1){            leftNodesVals.push_back(root-&gt;val);            return;        }        if(root-&gt;left){            getLeftVals(root-&gt;left, leftNodesVals, 1);        }        if(root-&gt;right){            getLeftVals(root-&gt;right, leftNodesVals, 2);        }    }    int sumOfLeftLeaves(TreeNode* root) {        if(!root || (!root-&gt;left &amp;&amp; !root-&gt;right)){            return 0;        }        vector&lt;int&gt; leftNodesVals;        getLeftVals(root, leftNodesVals, 1);        int sum = 0;        for(int i=0; i&lt;leftNodesVals.size(); i++){            sum += leftNodesVals[i];        }        return sum;    }};</code></pre><blockquote><ul><li>思路：深度优先遍历 + leftOrRight Flag</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂记长文-记一周年的某个烂flag及某些沙雕思绪</title>
      <link href="/2019/08/08/%E6%9D%82%E8%AE%B0%E9%95%BF%E6%96%87-%E8%AE%B0%E4%B8%80%E5%91%A8%E5%B9%B4%E7%9A%84%E6%9F%90%E4%B8%AA%E7%83%82flag%E5%8F%8A%E6%9F%90%E4%BA%9B%E6%B2%99%E9%9B%95%E6%80%9D%E7%BB%AA/"/>
      <url>/2019/08/08/%E6%9D%82%E8%AE%B0%E9%95%BF%E6%96%87-%E8%AE%B0%E4%B8%80%E5%91%A8%E5%B9%B4%E7%9A%84%E6%9F%90%E4%B8%AA%E7%83%82flag%E5%8F%8A%E6%9F%90%E4%BA%9B%E6%B2%99%E9%9B%95%E6%80%9D%E7%BB%AA/</url>
      
        <content type="html"><![CDATA[<p>随便起的题目，但这篇日志感觉会写得很正经、严肃，算是写给以后的自己看的，乱乱续续。所以，生人勿近咯。只是记录下最近地一些想法，怕忘了。希望以后自己无意间打开这篇日志的话，那时候的自己不像现在的自己这么丧/迷茫。</p><h2 id="1-缘由"><a href="#1-缘由" class="headerlink" title="1. 缘由"></a>1. 缘由</h2><p>为什么会突然想写篇总结性的日志，是早上刚起床时突发想到而已。当时的我，像往常一样，在去华科东一食堂路上，翻翻票圈+未睡醒的胡思乱想+最近的上班式工作（PS：md，老师催进度真的赶，说话如上级，还句句咄咄逼人，果然“资产阶级”就是这样压迫“无产阶级”的。说实话和公司上班没什么两样，可能就没有那么严重罢了，适当摸鱼还行。最近工作比之前好一点点，不是刚来时的那么无聊，但还不是完全自己当初所想的那样）+突然想起前几天“氢氧”的聊天记录说到的一周年烂Flag+最近Jo5感悟（may be）。遂突然想写篇东西总结总结算了吧。。</p><p>还有，最近空间一直都是丧啊。翻了下说说记录，应该这个丧/焦虑应该是大三下开始的，也就是保研那会开始，我也不知为什么都读研了还能这么焦虑。当初的自己，不是自己设定了保研这目标的吗？如今达到这目标了，为何还是延续那段时候的焦虑。我之前以为，一旦达到一个目标后，之后应该就是一直高兴才对。</p><p>现在重新想起来，大概这里面有几个原因：（1）以前：一年前的那个不忍回忆的烂flag（2）现在：如今offer的意料之外&amp;对如今所谓的准研究生生活的疑惑（3）将来：对一年后马上就要秋招的焦虑。</p><h2 id="2-以前：一周年了的某个烂flag"><a href="#2-以前：一周年了的某个烂flag" class="headerlink" title="2. 以前：一周年了的某个烂flag"></a>2. 以前：一周年了的某个烂flag</h2><p>其实，就算没有氢氧的提醒，我也会一直记住那个烂flag的遭遇。只不过，没想到他竟然还会记下来当初我说的这个flag，做了提醒，只能说想起真的百感交集。</p><p>一年前的flag，准确来说就是当初想去pkusz的那个flag，一路顺风顺水直到最后的最后那个lj老师的鸽子（虽然我知道对老师都应该抱有尊敬的态度，但是这个人我至今还是无法原谅）。氢氧提到的这个提醒，又让我想起了那段可怕回忆，真实可怕。11点下飞机赶回本部，从自信满满地去北京拿offer到那晚1个offer都没的我，仅仅3天时间，那晚真的彻夜难眠，和妈又和氢氧聊到1点多，3点才睡。9.23&amp;9.24疯狂赶回学校，连本来和广州老友约好的中秋聚会也不得已地瞬间秒拒了。当天回校，和好友的聊天、发泄，还有最后的暴哭。说实话，我也不知为什么，那晚6点，本来sl叫我一起去吃饭的，说着说着，忍不住了，那次是4年里我第一次哭得这么厉害，我那晚下飞机都在同学旁哭出声。但那一次，突然就爆发一样，也可能是在sl这个好友旁吧，还是十分感谢那段时间的氢氧、sl和陈某人，真正的朋友永远不是那种只在你高兴的时候一起高兴，而是不仅如此还能在你伤心的时候和你一起度过。我一直哭，哭了15分钟，一边说一边哭一边走，走出教学楼后，才开始下意识小声点。我不知道，这算不算那种，你当初选定的目标/梦想在一瞬间化为乌有的伤心。那件事之后，那个老师/学校都忍不住地有点阴影，并排斥甚至有时鄙夷/鄙视。 事后，我也一直在想，会不会是自己虚荣心/自尊心/胜负心太强了，那一下子的崩塌/冲击使我终于忍不住了。一下子就说多了，但不管怎样，这都已成事实，可以说这是一场典型的教训，不管是不是记忆的一道疤，都有挺多可以学的。例如，自己要继续变得优秀、认清社会的某些东西、一条路不要只给自己1个选择……</p><p>其实，我也一直在想，如果当初的我真的最终去了那，研究生生活会如何。如果要拿它和hust比较的话，客观地说，的确是pkusz好，在牌子&amp;地区方面，后者影响大不大就看能不能实习，前者的话的确有影响。但我还是觉得，应该到哪都差不多，除非大佬lab，无非就是帮老师搬砖，可能“砖头”有些是高级点的，有些是低级点的；也是如同上班式工作，无论是做项目/刷论文；也是有自己感兴趣&amp;不感兴趣的……至少，现在我是这样认为的。</p><h2 id="3-现在：意外的hust-amp-所谓的准研究生生活"><a href="#3-现在：意外的hust-amp-所谓的准研究生生活" class="headerlink" title="3. 现在：意外的hust&amp;所谓的准研究生生活"></a>3. 现在：意外的hust&amp;所谓的准研究生生活</h2><p>hust是个意外的offer，不然我就只能去中大了。直到现在，我都还不知道，我这个选择是不是正确的，我仍然持怀疑态度。如果说烂flag的崩塌是1个节点，那hust这个就是另一个节点，2个节点同时在同一年的同一个月发生了。虽然阿舅说，这种节点对于以后你的人生来说根本不算什么，以后的路更多的未知，但至少目前看来这就是很重要的，和高考一样。对了，可能我就是这样吧，遇到高考/读研这种阶段性的节点时，总是如此意外/失望，但高考失望后的本科却又让我好了起来，如同正弦函数…如果这样，会不会一年后又低谷，我也不得而知，只能现在就开始准备。</p><p>所谓的准研究生/研究生生活，已经了解到除了研一上上课，其他时间无课基本就是去“搬砖、上班”，当初的自己说不想走学术路线，如今实现了，之后的自己就不要后悔了（目前感觉良好，望一直能学多点东西）。导师又不放实习，只能直接秋招，1年时间，我觉得会很快的，很快。对于现在的我来说，真的怕自己的才能无法满足自己野心。研究生生活，那晚和师姐聊了下，的确比本科还累，本科还能高度划水，研究生不行了，就算行，我觉得我自己都不让自己过得了内心那关，毕竟也要稳食。师姐还说比高考还累，不同人不同看法吧。累就累吧，就2年，累就还好，希望能别受导师气就不受，最近的压任务（说难听也是压榨，导师还明说了以后工作也是这样，呵呵），负能量满满，搞得我都不好了。</p><h2 id="4-将来：秋招-amp-以后"><a href="#4-将来：秋招-amp-以后" class="headerlink" title="4. 将来：秋招&amp;以后"></a>4. 将来：秋招&amp;以后</h2><p>一年后的秋招，现在就要开始准备了。至于以后，我之前有想过，其实以后的人生是一种排列组合，甚至说的宽点，整个人生都是排列组合（考虑顺序）。对所有组合估量下。</p><p>以以后举例的话，按照类似数学的贝叶斯定理（条件概率那套）&amp;排列组合的思想，假设前提是读完硕士，下一个常见目标有以下几种（即考虑条件概率高的Top K）：<br>（1）读博/双硕士（国内/境外/国外）：如果让我选，肯定选国外，读博不选国外；那还不如不读，国内算了，境外的话香港还行。读博拼一把读国外，其实读博的学术是次要，重要的是想见见世面、试下不同环境的生活，之后就是证书。我也不知不专心做学术的读博想法对不对，不行就另一种是读双硕士，当然也是国外好。毕竟，还是很想去那几个理想的学校念书啊。<br>（2）工作（互联网等公司搬砖打工（包括各种工种，技术岗&amp;非技术岗）、体制内（包括公务员、选调生、体制内其他行政人员等））<br>（3）创业<br>（4）其他类（非本专业的较好职业（e.g.金融行业等），自由职业（e.g.自媒体、公众号、博主等），一时头脑发热型（音乐人（说实话，如果真的可以，我很想做音乐，纯兴趣，但现实就是这样。这算是一个小小的梦想了））等）</p><p>细分如下：</p><ul><li>读博（国内/境外/国外）</li><li>读双硕士（国内/境外/国外）</li><li>工作（互联网类、IT等相关类公司，技术岗）</li><li>工作（互联网类、IT等相关类公司，非技术岗）</li><li>工作（公务员）</li><li>工作（选调生）</li><li>工作（体制内其他行政人员）</li><li>创业</li><li>非本专业职业</li><li>自由职业</li><li>一时头脑发热型</li></ul><p>这里面，一共细类算15类。那读完硕士就是24左右，一般1种选择都要5年一周期吧，例如读博5年（可能更久）、公司工作一签就是3~5年等等。那也就是，如果只考虑十年内，也是只能有2个大类的主要选择，大类主要选择指的是，占大部分时间，例如工作，那肯定几乎每天都要工作了，但是也可以业余小类：玩玩音乐（业余兴趣型）、做做自由职业类（赚外快）等。</p><p>（1）先算全部，排列组合$A_{15}^{2} = 479,001,600$（可跳）<br>（2）然后，先去掉，未来10年大概率不会/不想接触的大类：读博（国内）、读双硕士（国内）、工作（互联网类、IT等相关类公司，非技术岗）、工作（选调生）、工作（体制内其他行政人员）、自由职业、一时头脑发热型。那么剩下仅有7类。即$A_{8}^{2} = 720$。所以说，这一步砍了7个，将10年的人生大类选择基本砍掉（也可以保留更多选择，或者新加更多其余选择）<br>（3）然后，还剩8个。去掉硕士毕业后大概率不会/不想马上接触的大类：非本专业职业、工作（公务员）、创业。剩下5个，分别是：读博（境外/国外）、读双硕士（境外/国外）、工作（互联网类、IT等相关类公司，技术岗），且考虑前后关系（硕士和博士），总共选择即在：</p><ul><li>选第一个/第二个：读博（境外/国外）、读双硕士（境外/国外）、工作（互联网类、IT等相关类公司，技术岗）</li><li>选第二个：非本专业职业、工作（公务员）、创业</li></ul><p>不考虑读硕/博顺序制约，$C_{5}^{1}<em>C_{3}^{1} + C_{5}^{1}</em>C_{4}^{1} = 35$种选择<br>减去读硕/博顺序制约（5种）：读博（境外）+读双硕（境外）、读博（境外）+读双硕（国外）、读博（国外）+读双硕（国外）、读博（国外）+读双硕（境外）、读双硕（国外）+读博（境外）（无必要）</p><p>结论（未考虑家庭等实际因素）：30种大类选择（10年内）、可附加多种小类：自由职业（多种）、一时头脑发热型（多种）</p><p>其实，如果还考虑家庭经济等因素，感觉发现，一个人越长大，自己的人生大路越是受限，越是受各种奇怪制约。现在的小孩可能小时候还有很多兴趣班，说不好听是压榨小孩去读，但真正喜欢的收获很大，因为选择很多，先不谈成功与否，之后道路都会选的更多。考虑家庭的话，大概率毕业还继续读书是不可能的，呵呵，好吧，写到这，到头来，还是没变，其实心里都有了答案的。</p><p>我在备忘录有过以下几条路（未来5~10年）备忘：<br>1- 华科硕 + 香港phd；之后去企业（cjq和我在暨大的最后一晚聊天时，推荐我走的路；后来7月碰巧在武汉遇见后，他还是这样说）；<br>2- 毕业互联网公司工作5年左右 + 出国念双硕士；（自想路，因为之前还是觉得读博太久太累，太学术化，不是很喜欢）<br>3- 毕业互联网公司工作5年左右 + 创业；<br>4- 毕业互联网公司工作；（这路意思是希望跳槽 or 升职至PM等，但不会一直打工，本身很抗拒这种想法）；</p><p>真想不出还有什么花来，小类选择，相当于业余爱好了。<br>1- 学音乐（e.g. 乌克丽丽、练唱歌等。希望而已，兴趣这东西没压力加上自己如果懒惰等，太难把握）<br>2- 做点自己业余爱好（摄影、Geek等代码类项目爱好等）</p><p>说到爱好，想起高中和大学分别最佩服的2个人，1个是钦D，另一个是James。由衷地佩服的2个人，都坚持自己的爱好、最初喜欢的，一直坚持着。有时感觉，自己连最喜欢的是什么都不知道，真的太可悲了，总是有那么一点感觉是自己被潮流冲垮了，随着波逐着流。如此的渺小，在社会简直太渺小了。想到以后的生活如果真一直打工，是有多无趣。所以，才会有野心的说法，不然像上班这种无限重复的人生简直就是浪费生命。希望，能一步一步，让自己能力能配得上野心。</p><p>这篇长文，算是发泄了很多了，应该够了吧。之后希望坚持年初的沙雕快乐愿望，不要再丧下去了，要找到自己喜欢的东西啊，开心点。<br>2019沙雕座右铭：早晨起来👌，拥抱太阳🌞</p>]]></content>
      
      
      <categories>
          
          <category> 鸡汤 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸡汤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eajack LeetCode Notes- Day5</title>
      <link href="/2019/07/14/Eajack%20LeetCode%20Notes-%20Day5/"/>
      <url>/2019/07/14/Eajack%20LeetCode%20Notes-%20Day5/</url>
      
        <content type="html"><![CDATA[<p><strong>PS：偷懒原因，很多题目不再看best solution了…… :)</strong></p><p><strong>收获：以后刷题一看题，先想最简单暴力求解，先不管时间复杂度、空间复杂度等要求，保证首次AC。之后，再优化大O。稳中求优！不然时间浪费太多了！</strong></p><h3 id="Q28"><a href="#Q28" class="headerlink" title="Q28"></a>Q28</h3><h4 id="1-题目信息"><a href="#1-题目信息" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：<a href="https://leetcode-cn.com/problems/valid-palindrome/description/" target="_blank" rel="noopener">验证回文串</a></li><li>编号&amp;难度：[125]，easy</li><li>Tags：<a href="https://leetcode.com/tag/two-pointers" target="_blank" rel="noopener"><code>two-pointers</code></a> | <a href="https://leetcode.com/tag/string" target="_blank" rel="noopener"><code>string</code></a></li><li>描述：给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。<strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</li><li>例子：</li></ul><pre><code>输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 输入: &quot;race a car&quot; 输出: false</code></pre></blockquote><h4 id="2-个人Code"><a href="#2-个人Code" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=125 lang=cpp * * [125] 验证回文串 */class Solution {public:    bool isPalindrome(string s) {        //1- 清洗s        string s_clear = &quot;&quot;;        for(int i=0; i&lt;s.size(); i++)        {            if((s[i] &gt;= &#39;a&#39; &amp;&amp; s[i] &lt;= &#39;z&#39;) || \                (s[i] &gt;= &#39;A&#39; &amp;&amp; s[i] &lt;= &#39;Z&#39;) || \                (s[i] &gt;= &#39;0&#39; &amp;&amp; s[i] &lt;= &#39;9&#39;))                s_clear += s[i];        }        //2- 重新遍历s_clear        if(s_clear.size() == 0 || s_clear.size() == 1)        {            return true;        }        int head = 0, tail = s_clear.size()-1;        while(head &lt; tail)        {            if( s_clear[head] == s_clear[tail] || \                ( (isalpha(s_clear[head]) &amp;&amp; isalpha(s_clear[tail])) &amp;&amp; \                  (abs(s_clear[head]-s_clear[tail]) == abs(&#39;A&#39;-&#39;a&#39;)) ) )            {                head++; tail--;            }            else            {                return false;            }        }        return true;    }};</code></pre><blockquote><ul><li>思路：首先清洗字符串s，只保留：字母&amp;数字。之后，对清洗后string首尾部双指针检测</li></ul></blockquote><h3 id="Q29"><a href="#Q29" class="headerlink" title="Q29"></a>Q29</h3><h4 id="1-题目信息-1"><a href="#1-题目信息-1" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：<a href="https://leetcode-cn.com/problems/single-number/description/" target="_blank" rel="noopener">只出现一次的数字</a></li><li>编号&amp;难度：[136]，easy</li><li>Tags：<a href="https://leetcode.com/tag/hash-table" target="_blank" rel="noopener"><code>hash-table</code></a> | <a href="https://leetcode.com/tag/bit-manipulation" target="_blank" rel="noopener"><code>bit-manipulation</code></a></li><li>描述：给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。<strong>说明：</strong>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</li><li>例子：</li></ul><pre><code>输入: [2,2,1]输出: 1输入: [4,1,2,1,2]输出: 4</code></pre></blockquote><h4 id="2-个人Code-1"><a href="#2-个人Code-1" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">class Solution {public:    int singleNumber(vector&lt;int&gt;&amp; nums) {        unordered_map&lt;int, int&gt; num_times;        for(int i=0; i&lt;nums.size(); i++)        {            if(num_times.find(nums[i]) != num_times.end())            {                num_times.erase(nums[i]);            }            else            {                num_times[nums[i]] = 1;            }        }        return (num_times.begin())-&gt;first;    }};</code></pre><blockquote><ul><li>思路：hash表典型题目。遍历nums，进行hash；若当前num在hash表find到了，证明num出现了2次，则删掉key = num的item。最后，hash表仅剩出现1次的num，return即可。</li></ul></blockquote><h3 id="Q30"><a href="#Q30" class="headerlink" title="Q30"></a>Q30</h3><h4 id="1-题目信息-2"><a href="#1-题目信息-2" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：<a href="https://leetcode-cn.com/problems/linked-list-cycle/description/" target="_blank" rel="noopener">环形链表</a></li><li>编号&amp;难度：[141]，easy</li><li>Tags：<a href="https://leetcode.com/tag/linked-list" target="_blank" rel="noopener"><code>linked-list</code></a> | <a href="https://leetcode.com/tag/two-pointers" target="_blank" rel="noopener"><code>two-pointers</code></a></li><li>描述：给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</li><li><strong>进阶：</strong>你能用 <em>O(1)</em>（即，常量）内存解决此问题吗？</li><li>例子：</li></ul><pre><code>输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。输入：head = [1], pos = -1输出：false解释：链表中没有环。</code></pre></blockquote><h4 id="2-个人Code-2"><a href="#2-个人Code-2" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=141 lang=cpp * * [141] 环形链表 *//** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    bool hasCycle(ListNode *head) {        unordered_map&lt;ListNode*,int&gt; nodeMap;        ListNode* temp = head;        while(temp != NULL)        {            if(nodeMap.find(temp) != nodeMap.end())            {                return true;            }            nodeMap[temp] = 1;            temp = temp-&gt;next;        }        return false;    }};</code></pre><blockquote><ul><li>思路：hashmap记录节点，遍历链表，若当前节点出现过，则return true。</li></ul></blockquote><h3 id="Q31"><a href="#Q31" class="headerlink" title="Q31"></a>Q31</h3><h4 id="1-题目信息-3"><a href="#1-题目信息-3" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：<a href="https://leetcode-cn.com/problems/min-stack/description/" target="_blank" rel="noopener">最小栈</a></li><li>编号&amp;难度：[155]，easy</li><li>Tags：<a href="https://leetcode.com/tag/stack" target="_blank" rel="noopener"><code>stack</code></a> | <a href="https://leetcode.com/tag/design" target="_blank" rel="noopener"><code>design</code></a></li><li>描述：设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。<ul><li>push(x) — 将元素 x 推入栈中。</li><li>pop() — 删除栈顶的元素。</li><li>top() — 获取栈顶元素。</li><li>getMin() — 检索栈中的最小元素。</li></ul></li><li><strong>进阶：</strong>你能用 <em>O(1)</em>（即，常量）内存解决此问题吗？</li><li>例子：</li></ul><pre><code>MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.</code></pre></blockquote><h4 id="2-个人Code-3"><a href="#2-个人Code-3" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=155 lang=cpp * * [155] 最小栈 *///https://blog.csdn.net/alps1992/article/details/41741811class MinStack {public:    vector&lt;long&gt; stack;    long stackMin = 0;    /** initialize your data structure here. */    MinStack() {    }    void push(int x) {        if(stack.empty())        {            stack.push_back(0);            stackMin = x;        }        else        {            stack.push_back(x-stackMin);            stackMin = (x&lt;stackMin)?(x):(stackMin);        }    }    void pop() {        if(stack.back() &lt; 0)        {            stackMin -= stack.back();            stack.pop_back();        }        else        {            stack.pop_back();        }    }    int top() {        return (stack.back() &lt; 0)?(stackMin):(stack.back()+stackMin);    }    int getMin() {        return stackMin;    }};/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */</code></pre><blockquote><ul><li>思路：其实这里是看了：<a href="https://blog.csdn.net/alps1992/article/details/41741811的思路。最小栈，会额外保留最小值stackMin；push是储存（x-stackMin），同时stackMin更新；pop是若stackMin" target="_blank" rel="noopener">https://blog.csdn.net/alps1992/article/details/41741811的思路。最小栈，会额外保留最小值stackMin；push是储存（x-stackMin），同时stackMin更新；pop是若stackMin</a> &lt; 0，更新stackMin -= stack.back()，stack.pop_back()；top，return (stack.back() &lt; 0)?(stackMin):(stack.back()+stackMin)</li></ul></blockquote><h3 id="Q32"><a href="#Q32" class="headerlink" title="Q32"></a>Q32</h3><h4 id="1-题目信息-4"><a href="#1-题目信息-4" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noopener">相交链表</a></p></li><li><p>编号&amp;难度：[160]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/linked-list" target="_blank" rel="noopener"><code>linked-list</code></a></p></li><li><p>描述：编写一个程序，找到两个单链表相交的起始节点。</p></li><li><p>例子：</p><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>如下面的两个链表<strong>：</strong></p><p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" target="_blank" rel="noopener"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p><p>在节点 c1 开始相交。</p></li></ul><p>  <strong>示例 1：</strong></p><p>  <a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png" target="_blank" rel="noopener"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt="img"></a></p><pre><code>  输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3  输出：Reference of the node with value = 8  输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</code></pre><p>  <strong>示例 2：</strong></p><p>  <a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png" target="_blank" rel="noopener"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt="img"></a></p><pre><code>  输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1  输出：Reference of the node with value = 2  输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre><p>  <strong>示例 3：</strong></p><p>  <a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png" target="_blank" rel="noopener"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p><pre><code>  输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2  输出：null  输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。  解释：这两个链表不相交，因此返回 null。</code></pre><p>  <strong>注意：</strong></p><ul><li>如果两个链表没有交点，返回 <code>null</code>.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(<em>n</em>) 时间复杂度，且仅用 O(<em>1</em>) 内存。</li></ul></blockquote><h4 id="2-个人Code-4"><a href="#2-个人Code-4" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=160 lang=cpp * * [160] 相交链表 *//** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {        if(headA == headB &amp;&amp; headA == nullptr) return headA;        //1- O(n^2)/*        ListNode* tempA = headA;        while(tempA != nullptr)        {            ListNode* tempB = headB;            while(tempB != nullptr)            {                if(tempA == tempB)                {                    return tempA;                }                tempB = tempB-&gt;next;                    }            tempA = tempA-&gt;next;        }        return nullptr;*/        //2- O(n)        unordered_map&lt;ListNode*, int&gt; nodeMap;        ListNode *tempA = headA, *tempB = headB;        while(tempA != nullptr)        {            nodeMap[tempA] = 1;            tempA = tempA-&gt;next;        }        while(tempB != nullptr)        {            if(nodeMap.find(tempB) != nodeMap.end())            {                return tempB;            }            tempB = tempB-&gt;next;        }        return nullptr;    }};</code></pre><blockquote><ul><li>思路：2种思路O(n^2) &amp; O(n)。O(n^2)，遍历List1，对当前Node1和List2所有Node比较，若地址相等，则return true，最后return false。O(n)，引入hashmap首先储存所有List1节点地址，再遍历List2，map.find是否有Node,2次O(n)，即为O(n)。</li></ul></blockquote><h3 id="Q33"><a href="#Q33" class="headerlink" title="Q33"></a>Q33</h3><h4 id="1-题目信息-5"><a href="#1-题目信息-5" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="noopener">两数之和 II - 输入有序数组</a></p></li><li><p>编号&amp;难度：[167]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/array" target="_blank" rel="noopener"><code>array</code></a> | <a href="https://leetcode.com/tag/two-pointers" target="_blank" rel="noopener"><code>two-pointers</code></a> | <a href="https://leetcode.com/tag/binary-search" target="_blank" rel="noopener"><code>binary-search</code></a></p></li><li><p>描述：给定一个已按照<strong>升序排列</strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p><p><strong>说明:</strong></p><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul></li><li><p>例子：</p><pre><code>输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</code></pre></li></ul></blockquote><h4 id="2-个人Code-5"><a href="#2-个人Code-5" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=167 lang=cpp * * [167] 两数之和 II - 输入有序数组 */class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {        int i = 0, j = numbers.size()-1;        while(i &lt; j)        {            if(numbers[i]+numbers[j] == target)            {                return {i+1,j+1};            }            else if(numbers[i]+numbers[j] &gt; target)            {                j--;            }            else if(numbers[i]+numbers[j] &lt; target)            {                i++;            }        }        return {0,0};    }};</code></pre><blockquote><ul><li>思路：注意<strong>升序=&gt;二分查询</strong>，首尾部2指针查询，判断（numbers[i]+numbers[j] == target），大于则尾部指针递减，小于则首部指针递增</li></ul></blockquote><h3 id="Q34"><a href="#Q34" class="headerlink" title="Q34"></a>Q34</h3><h4 id="1-题目信息-6"><a href="#1-题目信息-6" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/excel-sheet-column-title/description/" target="_blank" rel="noopener">Excel表列名称</a></p></li><li><p>编号&amp;难度：[168]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/math" target="_blank" rel="noopener"><code>math</code></a></p></li><li><p>描述：给定一个正整数，返回它在 Excel 表中相对应的列名称。</p></li><li><p>例子：</p><pre><code>    1 -&gt; A    2 -&gt; B    3 -&gt; C    ...    26 -&gt; Z    27 -&gt; AA    28 -&gt; AB     ...输入: 1输出: &quot;A&quot;输入: 28输出: &quot;AB&quot;输入: 701输出: &quot;ZY&quot;</code></pre></li></ul></blockquote><h4 id="2-个人Code-6"><a href="#2-个人Code-6" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=168 lang=cpp * * [168] Excel表列名称 */class Solution {public:    string convertToTitle(int n) {        string res=&quot;&quot;;        while(n&gt;0){            res=char(&#39;A&#39;+(n-1)%26)+res;            n=(n-1)/26;        }        return res;    }};</code></pre><blockquote><ul><li><p>思路：纯数学题。。。看了solution的，本质就是二进制形式幂函数：</p><p><code>28 = 26 + 2 = 26^1 * 1 + 26^0 * 2 = 26^1 * &#39;A&#39; + 26^0 * &#39;B&#39; = &quot;AB&quot;</code></p></li></ul></blockquote><h3 id="Q35"><a href="#Q35" class="headerlink" title="Q35"></a>Q35</h3><h4 id="1-题目信息-7"><a href="#1-题目信息-7" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="noopener">两数之和 II - 输入有序数组</a></p></li><li><p>编号&amp;难度：[167]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/array" target="_blank" rel="noopener"><code>array</code></a> | <a href="https://leetcode.com/tag/two-pointers" target="_blank" rel="noopener"><code>two-pointers</code></a> | <a href="https://leetcode.com/tag/binary-search" target="_blank" rel="noopener"><code>binary-search</code></a></p></li><li><p>描述：给定一个已按照<strong>升序排列</strong> 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2<em>。</em></p><p><strong>说明:</strong></p><ul><li>返回的下标值（index1 和 index2）不是从零开始的。</li><li>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</li></ul></li><li><p>例子：</p><pre><code>输入: numbers = [2, 7, 11, 15], target = 9输出: [1,2]解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</code></pre></li></ul></blockquote><h4 id="2-个人Code-7"><a href="#2-个人Code-7" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=167 lang=cpp * * [167] 两数之和 II - 输入有序数组 */class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {        int i = 0, j = numbers.size()-1;        while(i &lt; j)        {            if(numbers[i]+numbers[j] == target)            {                return {i+1,j+1};            }            else if(numbers[i]+numbers[j] &gt; target)            {                j--;            }            else if(numbers[i]+numbers[j] &lt; target)            {                i++;            }        }        return {0,0};    }};</code></pre><blockquote><ul><li>思路：注意<strong>升序=&gt;二分查询</strong>，首尾部2指针查询，判断（numbers[i]+numbers[j] == target），大于则尾部指针递减，小于则首部指针递增</li></ul></blockquote><h3 id="Q36"><a href="#Q36" class="headerlink" title="Q36"></a>Q36</h3><h4 id="1-题目信息-8"><a href="#1-题目信息-8" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/majority-element/description/" target="_blank" rel="noopener">求众数</a></p></li><li><p>编号&amp;难度：[169]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/array" target="_blank" rel="noopener"><code>array</code></a> | <a href="https://leetcode.com/tag/divide-and-conquer" target="_blank" rel="noopener"><code>divide-and-conquer</code></a> | <a href="https://leetcode.com/tag/bit-manipulation" target="_blank" rel="noopener"><code>bit-manipulation</code></a></p></li><li><p>描述：给定一个大小为 <em>n</em> 的数组，找到其中的众数。众数是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。你可以假设数组是非空的，并且给定的数组总是存在众数。</p></li><li><p>例子：</p><pre><code>输入: [3,2,3]输出: 3输入: [2,2,1,1,1,2,2]输出: 2</code></pre></li></ul></blockquote><h4 id="2-个人Code-8"><a href="#2-个人Code-8" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=169 lang=cpp * * [169] 求众数 */class Solution {public:    int majorityElement(vector&lt;int&gt;&amp; nums) {        unordered_map&lt;int, int&gt; numsTimes;        for(auto num: nums)        {            //注意：numsTimes[num]初始化为0            if(++numsTimes[num] &gt; nums.size()/2)                    return num;        }        return -1;//trash code    }};</code></pre><blockquote><ul><li>思路：简单，又可以用hashmap的。遍历nums，添加num入hashmap作为key，同时判断当前（++numsTimes[num] &gt; nums.size()/2）return num。（因为题干说一定有众数），return -1属于trash code。</li></ul></blockquote><h3 id="Q37"><a href="#Q37" class="headerlink" title="Q37"></a>Q37</h3><h4 id="1-题目信息-9"><a href="#1-题目信息-9" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/excel-sheet-column-number/description/" target="_blank" rel="noopener">Excel表列序号</a></p></li><li><p>编号&amp;难度：[171]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/math" target="_blank" rel="noopener"><code>math</code></a></p></li><li><p>描述：给定一个Excel表格中的列名称，返回其相应的列序号。</p></li><li><p>例子：</p><pre><code>    A -&gt; 1    B -&gt; 2    C -&gt; 3    ...    Z -&gt; 26    AA -&gt; 27    AB -&gt; 28     ...输入: &quot;A&quot;输出: 1输入: &quot;AB&quot;输出: 28输入: &quot;ZY&quot;输出: 701</code></pre></li></ul></blockquote><h4 id="2-个人Code-9"><a href="#2-个人Code-9" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=171 lang=cpp * * [171] Excel表列序号 */class Solution {public:    int titleToNumber(string s) {        if(s==&quot;&quot;) return 0;        long s_num = (s.back()-&#39;A&#39;+1), cnt = 1;        for(int i=s.size()-2; i&gt;=0; i--)        {            s_num += ((pow(26,cnt)) * (s[i]-&#39;A&#39;+1));            cnt++;        }        return s_num;    }};</code></pre><blockquote><ul><li>思路：Q34逆问题。关键：<code>28 = 26 + 2 = 26^1 * 1 + 26^0 * 2 = 26^1 * &#39;A&#39; + 26^0 * &#39;B&#39; = &quot;AB&quot;</code></li></ul></blockquote><h3 id="Q38"><a href="#Q38" class="headerlink" title="Q38"></a>Q38</h3><h4 id="1-题目信息-10"><a href="#1-题目信息-10" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/rotate-array/description/" target="_blank" rel="noopener">旋转数组</a></p></li><li><p>编号&amp;难度：[189]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/array" target="_blank" rel="noopener"><code>array</code></a></p></li><li><p>描述：给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p></li><li><p>例子：</p><pre><code>输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4]输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释: 向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100]说明:尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。要求使用空间复杂度为 O(1) 的 原地 算法。</code></pre></li></ul></blockquote><h4 id="2-个人Code-10"><a href="#2-个人Code-10" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=189 lang=cpp * * [189] 旋转数组 */class Solution {public:    void rotate(vector&lt;int&gt;&amp; nums, int k) {        //源代码：左右比较，暴力/*        int right_i = k%nums.size(), left_i = nums.size()-left_i;        if(right_i &lt;= left_i)        {            while(right_i--)            {                int lastNum = nums.back();                for(int j=nums.size()-1; j&gt;0; j--)                {                    nums[j] = nums[j-1];                }                nums[0] = lastNum;            }                    }        else        {            while(left_i--)            {                int firstNum = nums[0];                for(int j=0; j&lt;nums.size()-1; j++)                {                    nums[j] = nums[j+1];                }                nums[nums.size()-1] = firstNum;            }        }*/        //solution，绝妙        // 这个方法基于这个事实：当我们旋转数组 k 次，         //      k%n个尾部元素会被移动到头部，剩下的元素会被向后移动。        if(k%nums.size())        {            reverse(nums.begin(),nums.end());//反转整个数组            reverse(nums.begin(),nums.begin()+k%nums.size());//反转前k个元素            reverse(nums.begin()+k%nums.size(),nums.end());//反转后面n-k元素        }    }};</code></pre><blockquote><ul><li>思路：方法1：暴力k%nums.size()次（因为nums.size()次后数组不变），ac报错，因为有个很复杂输入导致超时；方法2：巧妙至极……（solution做法）</li></ul></blockquote><h3 id="Q39"><a href="#Q39" class="headerlink" title="Q39"></a>Q39</h3><h4 id="1-题目信息-11"><a href="#1-题目信息-11" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/reverse-bits/description/" target="_blank" rel="noopener">颠倒二进制位</a></p></li><li><p>编号&amp;难度：[190]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/bit-manipulation" target="_blank" rel="noopener"><code>bit-manipulation</code></a></p></li><li><p>描述：颠倒给定的 32 位无符号整数的二进制位。</p></li><li><p>例子：</p><pre><code>输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</code></pre></li></ul></blockquote><h4 id="2-个人Code-11"><a href="#2-个人Code-11" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=190 lang=cpp * * [190] 颠倒二进制位 */class Solution {public:    uint32_t reverseBits(uint32_t n) {        bitset&lt;32&gt; bin_num(n);        string bin_n_str = bin_num.to_string();        uint32_t n_reverse;        int head = 0, tail = bin_num.size()-1;        while(head &lt; tail)        {            char digit = bin_n_str[head];            bin_n_str[head] = bin_n_str[tail];            bin_n_str[tail] = digit;            head++; tail--;        }        bitset&lt;32&gt; bin_reverse(bin_n_str);        if(bin_reverse.size() != 0)        {            n_reverse = bin_reverse.to_ulong();            return n_reverse;        }        return 0;    }};</code></pre><blockquote><ul><li>思路：没啥说的，关键标准库class：bitset<32> bin_num(n)，百度可知，用于十进制 &lt;=&gt; 二进制，无技巧，solution 太技巧了，不喜欢。</32></li></ul></blockquote><h3 id="Q40"><a href="#Q40" class="headerlink" title="Q40"></a>Q40</h3><h4 id="1-题目信息-12"><a href="#1-题目信息-12" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/number-of-1-bits/description/" target="_blank" rel="noopener">位1的个数</a></p></li><li><p>编号&amp;难度：[191]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/bit-manipulation" target="_blank" rel="noopener"><code>bit-manipulation</code></a></p></li><li><p>描述：编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href="https://baike.baidu.com/item/汉明重量" target="_blank" rel="noopener">汉明重量</a>）。</p></li><li><p>例子：</p><pre><code>输入：00000000000000000000000000001011输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。输入：11111111111111111111111111111101输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</code></pre></li></ul></blockquote><h4 id="2-个人Code-12"><a href="#2-个人Code-12" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=191 lang=cpp * * [191] 位1的个数 */class Solution {public:    int hammingWeight(uint32_t n) {        int one_cnt = 0;        while(n &gt; 0)        {            if(n &amp; 1) one_cnt++;            n &gt;&gt;= 1;        }        return one_cnt;    }};</code></pre><blockquote><ul><li>思路：简单，先和1相与，后右移，直到n &lt;= 0。</li></ul></blockquote><h3 id="Q41"><a href="#Q41" class="headerlink" title="Q41"></a>Q41</h3><h4 id="1-题目信息-13"><a href="#1-题目信息-13" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/description/" target="_blank" rel="noopener">移除链表元素</a></p></li><li><p>编号&amp;难度：[203]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/linked-list" target="_blank" rel="noopener"><code>linked-list</code></a></p></li><li><p>描述：删除链表中等于给定值 <strong>val</strong> 的所有节点。</p></li><li><p>例子：</p><pre><code>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</code></pre></li></ul></blockquote><h4 id="2-个人Code-13"><a href="#2-个人Code-13" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=203 lang=cpp * * [203] 移除链表元素 *//** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode* removeElements(ListNode* head, int val) {        //clear val in the front        while(head &amp;&amp; head-&gt;val == val)        {            head = head-&gt;next;        }        //begin clear        ListNode *nowNode = head, *previousNode=nullptr;        while(nowNode)        {            if(nowNode-&gt;val == val)            {                ListNode* temp = nowNode;                nowNode = nowNode-&gt;next;                previousNode-&gt;next = nowNode;                delete temp;            }            else            {                //update nodes                previousNode = nowNode;                nowNode = nowNode-&gt;next;                            }        }        return head;    }};</code></pre><blockquote><ul><li>思路：首先删除首部为val值节点，然后线性遍历删除val节点。<strong>关键在于第一步 &amp; delete的链表操作。</strong></li></ul></blockquote><h3 id="Q41-1"><a href="#Q41-1" class="headerlink" title="Q41"></a>Q41</h3><h4 id="1-题目信息-14"><a href="#1-题目信息-14" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/count-primes/description/" target="_blank" rel="noopener">计数质数</a></p></li><li><p>编号&amp;难度：[204]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/hash-table" target="_blank" rel="noopener"><code>hash-table</code></a> | <a href="https://leetcode.com/tag/math" target="_blank" rel="noopener"><code>math</code></a></p></li><li><p>描述：统计所有小于非负整数 <em>n</em> 的质数的数量。</p></li><li><p>例子：</p><pre><code>输入: 10输出: 4解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</code></pre></li></ul></blockquote><h4 id="2-个人Code-14"><a href="#2-个人Code-14" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=204 lang=cpp * * [204] 计数质数 */class Solution {public:    int isPrime(int n)    {        for(int i=2; i*i&lt;=n; i++)        {            if(n%i == 0)                return false;        }        return true;    }    int countPrimes(int n) {        if(n&lt;3) return 0;        int prime_cnt = 1;        for(int i=3; i&lt;n; i++)        {            if(isPrime(i))                prime_cnt++;        }        return prime_cnt;    }};</code></pre><blockquote><ul><li>思路：简单。内置isPrime函数判断是否为质数，遍历n，逐个判断，计数。</li></ul></blockquote><h3 id="Q42"><a href="#Q42" class="headerlink" title="Q42"></a>Q42</h3><h4 id="1-题目信息-15"><a href="#1-题目信息-15" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/reverse-linked-list/description/" target="_blank" rel="noopener">反转链表</a></p></li><li><p>编号&amp;难度：[206]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/linked-list" target="_blank" rel="noopener"><code>linked-list</code></a></p></li><li><p>描述：反转一个单链表。</p></li><li><p>例子：</p><pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre></li></ul></blockquote><h4 id="2-个人Code-15"><a href="#2-个人Code-15" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=206 lang=cpp * * [206] 反转链表 *//** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    //1- O(N)空间复杂度/*    ListNode* reverseList(ListNode* head) {        if(!head) return nullptr;        vector&lt;ListNode*&gt; nodes;        //push        while(head != nullptr)        {            nodes.push_back(head);            head = head-&gt;next;        }        //pop        ListNode* head_reverse = nodes.back();        ListNode* nowNode = head_reverse;        nodes.pop_back();        for(int i=nodes.size()-1; i&gt;=0; i--)        {            ListNode* temp = nodes[i];            nowNode-&gt;next = temp;            nowNode = nowNode-&gt;next;        }        nowNode-&gt;next = nullptr;        return head_reverse;    }*/    //2- O(1) 空间复杂度，迭代/*    ListNode* reverseList(ListNode* head){        if(!head || !(head-&gt;next)) return head;        ListNode  *head_reverse = head-&gt;next, *previousNode = head, \            *temp = nullptr;        head-&gt;next = nullptr;        while(head_reverse-&gt;next != nullptr)        {            temp = head_reverse-&gt;next;            head_reverse-&gt;next = previousNode;            previousNode = head_reverse;            head_reverse = temp;        }        head_reverse-&gt;next = previousNode;        return head_reverse;    }*/    //3- O(1) 空间复杂度，递归    ListNode* reverseList_sub(ListNode* previousNode, ListNode* nowNode){        if(nowNode-&gt;next)        {            ListNode* head_reverse = reverseList_sub(nowNode, nowNode-&gt;next);            nowNode-&gt;next = previousNode;            return head_reverse;        }        else        {            nowNode-&gt;next = previousNode;            ListNode* head_reverse = nowNode;            return head_reverse;        }    }    ListNode* reverseList(ListNode* head){        if(!head || !(head-&gt;next)) return head;        ListNode *nowNode = head-&gt;next;        head-&gt;next = nullptr;        ListNode* head_reverse = reverseList_sub(head, nowNode);        return head_reverse;    }};</code></pre><blockquote><ul><li>思路：典型题。3种解法：（1）- O(n)空间复杂度，栈push节点，栈pop节点；(2)- 迭代，O(1)原地操作；(3)- 递归，O(1)原地操作。</li></ul></blockquote><h3 id="Q43"><a href="#Q43" class="headerlink" title="Q43"></a>Q43</h3><h4 id="1-题目信息-16"><a href="#1-题目信息-16" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/contains-duplicate/description/" target="_blank" rel="noopener">存在重复元素</a></p></li><li><p>编号&amp;难度：[217]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/array" target="_blank" rel="noopener"><code>array</code></a> | <a href="https://leetcode.com/tag/hash-table" target="_blank" rel="noopener"><code>hash-table</code></a></p></li><li><p>描述：给定一个整数数组，判断是否存在重复元素。如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p></li><li><p>例子：</p><pre><code>输入: [1,2,3,1]输出: true输入: [1,2,3,4]输出: false输入: [1,1,1,3,3,4,3,2,4,2]输出: true</code></pre></li></ul></blockquote><h4 id="2-个人Code-16"><a href="#2-个人Code-16" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=217 lang=cpp * * [217] 存在重复元素 */class Solution {public:    bool containsDuplicate(vector&lt;int&gt;&amp; nums) {        unordered_map&lt;int, int&gt; numsMap;        for(auto num:nums)        {            if(numsMap.find(num) != numsMap.end())            {                return true;            }            else            {                numsMap[num] = 1;            }        }        return false;    }};</code></pre><blockquote><ul><li>思路：hashmap典型题。2次重复变种，这里可以多次重复。</li></ul></blockquote><h3 id="Q44"><a href="#Q44" class="headerlink" title="Q44"></a>Q44</h3><h4 id="1-题目信息-17"><a href="#1-题目信息-17" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/contains-duplicate-ii/description/" target="_blank" rel="noopener">存在重复元素 II</a></p></li><li><p>编号&amp;难度：[219]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/array" target="_blank" rel="noopener"><code>array</code></a> | <a href="https://leetcode.com/tag/hash-table" target="_blank" rel="noopener"><code>hash-table</code></a></p></li><li><p>描述：给定一个整数数组和一个整数 <em>k</em>，判断数组中是否存在两个不同的索引 <em>i</em> 和 <em>j</em>，使得 <strong>nums [i] = nums [j]</strong>，并且 <em>i</em> 和 <em>j</em> 的差的绝对值最大为 <em>k</em>。</p></li><li><p>例子：</p><pre><code>输入: nums = [1,2,3,1], k = 3输出: true输入: nums = [1,0,1,1], k = 1输出: true输入: nums = [1,0,1,1], k = 1输出: true</code></pre></li></ul></blockquote><h4 id="2-个人Code-17"><a href="#2-个人Code-17" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=219 lang=cpp * * [219] 存在重复元素 II */class Solution {public:    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {        unordered_map&lt;int,vector&lt;int&gt;&gt; numsMap;        for(int i=0; i&lt;nums.size(); i++)        {            if(numsMap.find(nums[i]) != numsMap.end())            {                numsMap[nums[i]].push_back(i);            }            else            {                numsMap[nums[i]] = {i};            }        }        //遍历numsMap        for(auto it=numsMap.begin(); it!=numsMap.end(); it++)        {            vector&lt;int&gt; m_2 = it-&gt;second;            if(m_2.size() &gt;= 2)            {                for(int i=0; i&lt;m_2.size(); i++)                {                    for(int j=i+1; j&lt;m_2.size(); j++)                    {                        if(abs(m_2[i]-m_2[j]) &lt;= k)                            return true;                    }                }            }        }        return false;    }};</code></pre><blockquote><ul><li>思路：上题变种。先存下来，再遍历map。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eajack LeetCode Notes- Day4</title>
      <link href="/2019/07/03/Eajack%20LeetCode%20Notes-%20Day4/"/>
      <url>/2019/07/03/Eajack%20LeetCode%20Notes-%20Day4/</url>
      
        <content type="html"><![CDATA[<p><strong>PS：由于最近leetcode官网访问问题，暂改成leetcode-zh刷题。</strong></p><h3 id="Q22"><a href="#Q22" class="headerlink" title="Q22"></a>Q22</h3><h4 id="1-题目信息"><a href="#1-题目信息" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：二叉树的层次遍历 II</p></li><li><p>编号&amp;难度：[107]，easy</p></li><li><p>Tags：tree| breadth-first-search</p></li><li><p>描述：给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p></li><li><p>例子：</p><pre><code>给定二叉树 [3,9,20,null,null,15,7],   3  / \ 9  20   /  \  15   7[ [15,7], [9,20], [3]]</code></pre></li></ul></blockquote><h4 id="2-个人Code"><a href="#2-个人Code" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=107 lang=cpp * * [107] 二叉树的层次遍历 II *//** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    vector&lt;vector&lt;int&gt;&gt; levelOrderBottom(TreeNode* root) {        vector&lt;vector&lt;int&gt;&gt; levelorder_nodes;        vector&lt;TreeNode*&gt; temp;        temp.push_back(root);        int currentLevel_nodesNum = 0;        if(root == nullptr)        {            return levelorder_nodes;        }        while(temp.size())        {            currentLevel_nodesNum = temp.size();            vector&lt;int&gt; currentLevelNodes_val;            //层次遍历            // 自顶向下读取，逆向储存            TreeNode* node_buffer = nullptr;            while(currentLevel_nodesNum--)            {                //pop                node_buffer = temp[0];                temp.erase(temp.begin());                //push                if(node_buffer)                {                    temp.push_back(node_buffer-&gt;left);                    temp.push_back(node_buffer-&gt;right);                    currentLevelNodes_val.push_back(node_buffer-&gt;val);                }            }            //push in levelorder_nodes            if(levelorder_nodes.empty())            {                levelorder_nodes.push_back(currentLevelNodes_val);            }            else if(!currentLevelNodes_val.empty())            {                //levelorder_nodes右移                levelorder_nodes.push_back(currentLevelNodes_val);//trash                int last_cnt = levelorder_nodes.size()-1;                while(last_cnt)                {                    levelorder_nodes[last_cnt] = levelorder_nodes[last_cnt-1];                    last_cnt--;                }                levelorder_nodes[0] = currentLevelNodes_val;            }        }        return levelorder_nodes;    }};</code></pre><blockquote><ul><li><p>思路：题目要求是逆向遍历。思路依然是层次遍历思路，然而关键是逆向储存。举例如下</p><pre><code>给定二叉树 [3,9,20,null,null,15,7],   3  / \ 9  20   /  \  15   7levelorder_nodes = []第一层：遍历[3]，push =&gt; levelorder_nodes = [[3]];第二层：遍历[9,20]，先右移levelorder_nodes =&gt; levelorder_nodes = [[],[3]]，注意首位为空；首部填充[9,20] =&gt; levelorder_nodes = [[9,20],[3]]第三层：遍历[15,7]，先右移levelorder_nodes =&gt; levelorder_nodes = [[],[9,20],[3]]，注意首位为空；首部填充[15,7] =&gt; levelorder_nodes = [[15,7],[9,20],[3]]</code></pre></li></ul></blockquote><h3 id="Q23"><a href="#Q23" class="headerlink" title="Q23"></a>Q23</h3><h4 id="1-题目信息-1"><a href="#1-题目信息-1" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：二叉树的层次遍历 II</p></li><li><p>编号&amp;难度：[107]，easy</p></li><li><p>Tags：tree| breadth-first-search</p></li><li><p>描述：给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><blockquote><p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过1。</p></blockquote></li><li><p>例子：</p><pre><code>示例1：给定二叉树 [3,9,20,null,null,15,7]    3   / \  9  20    /  \   15   7返回 true 。示例 2:给定二叉树 [1,2,2,3,3,null,null,4,4]       1      / \     2   2    / \   3   3  / \ 4   4返回 false 。</code></pre></li></ul></blockquote><h4 id="2-个人Code-1"><a href="#2-个人Code-1" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=110 lang=cpp * * [110] 平衡二叉树 *//** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {    int getHeight(TreeNode* root)    {        if(root == nullptr)        {            return 0;        }        else        {            int left_height = getHeight(root-&gt;left);            int right_height = getHeight(root-&gt;right);            return (left_height&gt;right_height)?(left_height+1):(right_height+1);        }    }public:    bool isBalanced(TreeNode* root) {        TreeNode* node_now = root;        vector&lt;TreeNode*&gt; nodes;        nodes.push_back(root);        int left_h, right_h;        while(nodes.size())        {            //pop            TreeNode* node_now = nodes[0];            nodes.erase(nodes.begin());            //get height of left&amp;right            left_h = (node_now &amp;&amp; node_now-&gt;left)?(getHeight(node_now-&gt;left)):(0);            right_h = (node_now &amp;&amp; node_now-&gt;right)?(getHeight(node_now-&gt;right)):(0);            if(abs(left_h-right_h) &gt; 1) return false;            //push            if(node_now)            {                nodes.push_back(node_now-&gt;left);                nodes.push_back(node_now-&gt;right);            }        }        return true;    }};</code></pre><blockquote><ul><li>思路：内置求节点高度的函数getHeight(TreeNode* root)。层次遍历，从第二层开始，遍历左右子树，求节点高度，if(abs(left_h-right_h) &gt; 1) return false; 否则，继续遍历。遍历完树后，推出 return true。</li></ul></blockquote><h3 id="Q24"><a href="#Q24" class="headerlink" title="Q24"></a>Q24</h3><h4 id="1-题目信息-2"><a href="#1-题目信息-2" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="noopener">二叉树的最小深度</a></p></li><li><p>编号&amp;难度：[111]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/tree" target="_blank" rel="noopener"><code>tree</code></a> | <a href="https://leetcode.com/tag/depth-first-search" target="_blank" rel="noopener"><code>depth-first-search</code></a> | <a href="https://leetcode.com/tag/breadth-first-search" target="_blank" rel="noopener"><code>breadth-first-search</code></a></p></li><li><p>描述：给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<strong>说明:</strong> 叶子节点是指没有子节点的节点。</p></li><li><p>例子：</p><pre><code>给定二叉树 [3,9,20,null,null,15,7],    3   / \  9  20    /  \   15   7返回它的最小深度  2.</code></pre></li></ul></blockquote><h4 id="2-个人Code-2"><a href="#2-个人Code-2" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=111 lang=cpp * * [111] 二叉树的最小深度 *//** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    int minDepth(TreeNode* root) {         if(root == NULL)            return 0;        if(root-&gt;left == nullptr) return minDepth(root-&gt;right) + 1;        if(root-&gt;right == nullptr) return minDepth(root-&gt;left) + 1;        int left_h = minDepth(root-&gt;left) + 1;        int right_h = minDepth(root-&gt;right) + 1;        return (left_h&lt;right_h)?(left_h):(right_h);    }};</code></pre><blockquote><ul><li>思路：这里好像记得是没想出来，看的solution。。。首先，检查根部是否有双孩子，否则的话，返回有孩子的（minDepth(root-&gt;right) + 1)；然后，求left最小深度 &amp; right最小深度，返回二者较小者。</li></ul></blockquote><h3 id="Q25"><a href="#Q25" class="headerlink" title="Q25"></a>Q25</h3><h4 id="1-题目信息-3"><a href="#1-题目信息-3" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="noopener"><a href="https://leetcode-cn.com/problems/pascals-triangle/description/" target="_blank" rel="noopener">杨辉三角</a></a></p></li><li><p>编号&amp;难度：[118]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/array" target="_blank" rel="noopener"><code>array</code></a></p></li><li><p>描述：给定一个非负整数 <em>numRows，</em>生成杨辉三角的前 <em>numRows</em> 行。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"></p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p></li><li><p>例子：</p><pre><code>输入: 5输出:[     [1],    [1,1],   [1,2,1],  [1,3,3,1], [1,4,6,4,1]]</code></pre></li></ul></blockquote><h4 id="2-个人Code-3"><a href="#2-个人Code-3" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=118 lang=cpp * * [118] 杨辉三角 */class Solution {public:    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {        if(numRows == 0)        {            vector&lt;vector&lt;int&gt;&gt; zero_return;                        return zero_return;        }        //1- init 1&amp;2 rows        vector&lt;int&gt; row_1{1}, row_2{1,1};        vector&lt;vector&lt;int&gt;&gt; triangle_YH;        //2- begin        if(numRows == 1)        {            triangle_YH.push_back(row_1);        }        else if(numRows == 2)        {            triangle_YH.push_back(row_1);            triangle_YH.push_back(row_2);        }        else        {            triangle_YH.push_back(row_1);            triangle_YH.push_back(row_2);            //begin at 3-th row            vector&lt;int&gt; lastRow = row_2;            for(int i=3; i&lt;=numRows; i++)            {                int cnt = i;                vector&lt;int&gt; nowRow;                for(int j=0; j&lt;cnt; j++)                {                    if(j==0 || j==cnt-1)                    {                        nowRow.push_back(1);                    }                    else                    {                        nowRow.push_back(lastRow[j-1] + lastRow[j]);                    }                }                lastRow = nowRow;                triangle_YH.push_back(nowRow);            }        }        return triangle_YH;    }};</code></pre><blockquote><ul><li>思路：按照杨辉三角概念。首先，初始化好第1、2层的vector；然后，从第3层开始，保存上一层为<code>lastRow</code>，当前层初始化为空vector<code>nowRow</code>，<code>nowRow[0] = 1</code>；Next，双指针形式在<code>lastRow</code>中递进求和，push入<code>nowRow</code>，即<code>nowRow.push_back(lastRow[j-1] + lastRow[j])</code>,最后在push多1个1，即<code>nowRow[-1] = 1</code>,至此当前层<code>nowRow</code>完成，push入<code>triangle_YH</code>；继续下一层直到结束。</li></ul></blockquote><h3 id="Q26"><a href="#Q26" class="headerlink" title="Q26"></a>Q26</h3><h4 id="1-题目信息-4"><a href="#1-题目信息-4" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/pascals-triangle-ii/description/" target="_blank" rel="noopener">杨辉三角 II</a></p></li><li><p>编号&amp;难度：[119]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/array" target="_blank" rel="noopener"><code>array</code></a></p></li><li><p>描述：给定一个非负索引 <em>k</em>，其中 <em>k</em> ≤ 33，返回杨辉三角的第 <em>k</em> 行。</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"></p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p></li><li><p>例子：</p><pre><code>输入: 3输出: [1,3,3,1]</code></pre></li></ul><ul><li>要求：你可以优化你的算法到 <em>O</em>(<em>k</em>) 空间复杂度吗？</li></ul></blockquote><h4 id="2-个人Code-4"><a href="#2-个人Code-4" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=119 lang=cpp * * [119] 杨辉三角 II */class Solution {public:    vector&lt;int&gt; getRow(int rowIndex) {        vector&lt;int&gt; triangle_YH_k;        int k = 0;        //1- 0 or 1        if(rowIndex == 0 || rowIndex == 1)        {            k = rowIndex + 1;            while(k--)            {                triangle_YH_k.push_back(1);            }        }        else//2- rowIndex &gt;= 2        {            triangle_YH_k.push_back(1);            triangle_YH_k.push_back(1);            //begin from 2            for(int row=2; row&lt;=rowIndex; row++)            {                //每一行loop (row-1) times                for(int cnt=1; cnt&lt;row; cnt++)                {                    //pop first &amp; push (first+second)                    int value_1 = triangle_YH_k[0], value_2 = triangle_YH_k[1];                    triangle_YH_k.push_back(value_1+value_2);                    triangle_YH_k.erase(triangle_YH_k.begin());                }                triangle_YH_k.push_back(1);//last one            }        }        return triangle_YH_k;    }};</code></pre><blockquote><ul><li>思路：其实和Q25差不多思路，只是这里只要求取第(k+1)层，且空间复杂度为O(k)。所以，<code>triangle_YH_k.size() = k</code>才行。因此，就只能逐层递进求了。可用队列形式实现，和树的层次遍历有点像：enque作为当前层node；deque首部2个上一层node求和，再enque作为当前层node。<strong>关键：注意首部尾部1</strong></li></ul></blockquote><h3 id="Q27"><a href="#Q27" class="headerlink" title="Q27"></a>Q27</h3><h4 id="1-题目信息-5"><a href="#1-题目信息-5" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li><p>标题：<a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">买卖股票的最佳时机</a></p></li><li><p>编号&amp;难度：[121]，easy</p></li><li><p>Tags：<a href="https://leetcode.com/tag/array" target="_blank" rel="noopener"><code>array</code></a> | <a href="https://leetcode.com/tag/dynamic-programming" target="_blank" rel="noopener"><code>dynamic-programming</code></a></p></li><li><p>描述：给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。</p></li><li><p>例子：</p><pre><code>示例 1:输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。示例 2:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre></li></ul></blockquote><h4 id="2-个人Code-5"><a href="#2-个人Code-5" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=121 lang=cpp * * [121] 买卖股票的最佳时机 */class Solution {public:    int maxProfit(vector&lt;int&gt;&amp; prices) {        int maxIncome = INT_MIN;        for(int i=0; i&lt;prices.size(); i++)        {            int cost = prices[i];            for(int j=i+1; j&lt;prices.size(); j++)            {                int gain = prices[j];                if(gain-cost &gt; maxIncome)                {                    maxIncome = gain-cost;                }            }        }        return ( (maxIncome &gt; 0)?maxIncome:0 );            }};</code></pre><blockquote><ul><li>思路：因为只能产生1对数字，且顺序不能逆转。则对1个n个元素的数组，有$(n-1)+(n-2)+…+1=\frac{n^{2}+n+2}{2}=O(n^{2})$简易算法，即穷举暴力遍历。可以获得最大利润值。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Road 2 NLP- Text Classfication文本分类模型（TextCNN）</title>
      <link href="/2019/07/02/Road%202%20NLP-%20Text%20Classfication%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%EF%BC%88TextCNN%EF%BC%89/"/>
      <url>/2019/07/02/Road%202%20NLP-%20Text%20Classfication%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%EF%BC%88TextCNN%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-参考资料"><a href="#1-参考资料" class="headerlink" title="1. 参考资料"></a>1. 参考资料</h1><blockquote><ul><li>TextCNN论文：<a href="https://github.com/Eajack/NLP-Papers/blob/master/Text%20Classification%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/TextCNN%20%26%20CharCNN/Convolutional%20Neural%20Networks%20for%20Sentence%20Classification.pdf" target="_blank" rel="noopener">《Convolutional Neural Networks for Sentence Classification》</a>，作者Yoon Kim，纽约大学学生、哈佛大学研究生</li><li>博客文：<a href="http://www.wildml.com/2015/12/implementing-a-cnn-for-text-classification-in-tensorflow/" target="_blank" rel="noopener">《Implementing a CNN for Text Classification in TensorFlow – WildML》</a></li></ul></blockquote><h1 id="2-TextCNN原理"><a href="#2-TextCNN原理" class="headerlink" title="2. TextCNN原理"></a>2. TextCNN原理</h1><p>TextCNN，由2014年Kim提出，该模型框架很简单。这篇文章算是较为出名的、关于CNN在NLP领域应用的开山之作。因为，在此之前，CNN在计算机视觉CV的图像分类等任务中应用广泛，而在NLP领域应用较少。思路引用了CNN在图像中的应用思路，将文本转化为矩阵（image）处理。</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Text%20Classification%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B/TextCNN%20%26%20CharCNN/%E5%9B%BE1.png" alt="图1- TextCNN"></p><p>现分层介绍：</p><ul><li>词向量层：TextCNN输入是词向量化后的分词文本，可取Word2vec、GloVe、FastText、ELMo或者多种concat组合等的词向量形式。以上图为例，文本<code>这个 店 排队 真的 要 很久 啊</code>7个词语，即可对应7个词向量。此处假设词向量维度为<code>d=5</code>。所以文本可以等价为<code>7*5</code>的矩阵，其实和image矩阵一样了！！（这也是我第一次了解TextCNN感到的惊讶之处，CNN从CV到NLP的迁移很好）</li><li>卷积层：n组卷积核，每组m个核，一般每组卷积核尺寸取连续自然数。如上图，n=3，m=2，尺寸为(2,3,4)，即((2×d), (3×d), (4×d))的矩阵尺寸。卷积输出为n*m个向量。</li><li>池化层：1阶最大池化。遍历卷积层输出的n*m个向量，取最大值然后先每组内部concat，之后全部concat，组成concat vector。</li><li>softmax层：对concat vector进行softmax处理，可二分类/多分类，得到预测分类标签$Y_{predict}$。同时，实际标签为$Y_{real}$，构造loss function，SGD等算法训练TextCNN模型参数。</li></ul><p><strong>特别地，当分词以字符形式分词，则为charCNN。即文本变成<code>这 个 店 排 队 真 的 要 很 久 啊</code>，直接按字分词，对应为字向量。</strong></p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TextCNN </tag>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Road 2 NLP- Word Embedding词向量（ELMo）</title>
      <link href="/2019/07/02/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88ELMo%EF%BC%89/"/>
      <url>/2019/07/02/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88ELMo%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-参考资料"><a href="#1-参考资料" class="headerlink" title="1. 参考资料"></a>1. 参考资料</h1><blockquote><ul><li>ELMo论文：<a href="https://github.com/Eajack/NLP-Papers/blob/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/ELMo/%E3%80%8ADeep%20contextualized%20word%20representations%E3%80%8B.pdf" target="_blank" rel="noopener">《Deep contextualized word representations》</a>，作者Matthew et al. ，AllenNLP</li><li>ELMo前论文（ELMo基于该论文模型改进）：<a href="https://github.com/Eajack/NLP-Papers/blob/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/ELMo/Semi-supervised%20sequence%20tagging%20with%20bidirectional%20language%20models.pdf" target="_blank" rel="noopener">《Semi-supervised sequence tagging with bidirectional language models》</a></li><li><a href="https://zhuanlan.zhihu.com/p/51679783" target="_blank" rel="noopener">知乎专栏文《ELMo原理解析及简单上手使用》</a></li></ul></blockquote><h1 id="2-RNN基础：标准RNN-LSTM-GRU"><a href="#2-RNN基础：标准RNN-LSTM-GRU" class="headerlink" title="2. RNN基础：标准RNN/LSTM/GRU"></a>2. RNN基础：标准RNN/LSTM/GRU</h1><p>ELMo基于双向LSTM，因此在此之前先了解下常用RNN结构，顺便了解RNN结构。</p><p><strong>ELMo中的常用RNN结构：LSTM &amp; GRU（均为标准RNN的变体）。</strong></p><h2 id="2-1-标准RNN（Recurrent-Neural-Networks）"><a href="#2-1-标准RNN（Recurrent-Neural-Networks）" class="headerlink" title="2.1 标准RNN（Recurrent Neural Networks）"></a>2.1 标准RNN（Recurrent Neural Networks）</h2><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/ELMo/%E5%9B%BE1.png" alt="图1- 标准RNN"></p><p>如上图，符号说明：$(t)、(t-1)$表示时序，即对应句子分词后词语的词向量；$h_{m×1}$为隐状态；$x_{n×1}$为词向量；$W_{m×n}、U_{m×m}$分别为系数矩阵，初值随机化；$h_{m×1}^{(0)}$初值随机化。<strong>注意，$W_{m×n}、U_{m×m}$矩阵共享，不因时序而不同。</strong></p><p>因此，标准RNN隐状态更新公式为</p><script type="math/tex; mode=display">h_{m×1}^{(t)}=f(W_{m×n}x_{n×1}^{(t)}+U_{m×m}h_{m×1}^{(t-1)}+b_{m×1})</script><p>其中，$f(X)=tanh(X)$。</p><p>标准RNN存在梯度消失问题。单个RNN cell的参数量：$mn+mm+m$，包括$W_{m×n}、U_{m×m}、b_{m×1}$；$h_{m×1}$是生成的，不算入参数。</p><h2 id="2-2-LSTM（Long-Short-Term-Memory）"><a href="#2-2-LSTM（Long-Short-Term-Memory）" class="headerlink" title="2.2 LSTM（Long Short-Term Memory）"></a>2.2 LSTM（Long Short-Term Memory）</h2><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/ELMo/%E5%9B%BE2.png" alt="图2- LSTM"></p><p>LSTM（Long Short-Term Memory），属于标准RNN变体，当前时刻状态可受前面几个时刻的影响。公式如下：</p><script type="math/tex; mode=display">输入门input：i_{m×1}^{(t)}=\sigma(W_{m×n}^{i}x_{n×1}^{(t)}+U_{m×m}^{i}h_{m×1}^{(t-1)}+b_{m×1}^{i})\\遗忘门forget：f_{m×1}^{(t)}=\sigma(W_{m×n}^{f}x_{n×1}^{(t)}+U_{m×m}^{f}h_{m×1}^{(t-1)}+b_{m×1}^{f})\\输出门output：o_{m×1}^{(t)}=\sigma(W_{m×n}^{o}x_{n×1}^{(t)}+U_{m×m}^{o}h_{m×1}^{(t-1)}+b_{m×1}^{o})\\普通门gate：g_{m×1}^{(t)}=tanh(W_{m×n}^{g}x_{n×1}^{(t)}+U_{m×m}^{g}h_{m×1}^{(t-1)}+b_{m×1}^{g})\\cell状态c：c_{m×1}^{(t)}=f_{m×1}^{(t)} \cdot c_{m×1}^{(t-1)}+i_{m×1}^{(t)} \cdot g_{m×1}^{(t)}\\隐状态h：h_{m×1}^{t}=o_{m×1}^{(t)} \cdot tanh(c_{m×1}^{(t)})\\</script><p><strong>PS：注意上述式子中c、h的乘法均为，按对应位的元素相乘，即$a_{m×1} \cdot b_{m×1} = c_{m×1}$。</strong>其中，$\sigma(x)= \frac{1}{1+e^{-x}}$，是sigmoid函数，此处为按点求$\sigma(x)$。</p><p>单个LSTM cell的参数量：$4(mn+mm+m)$，包括4组$W_{m×n}、U_{m×m}、b_{m×1}$。符号说明和标准RNN一致。</p><h2 id="2-3-GRU（Gated-Recurrent-Unit）"><a href="#2-3-GRU（Gated-Recurrent-Unit）" class="headerlink" title="2.3 GRU（Gated Recurrent Unit）"></a>2.3 GRU（Gated Recurrent Unit）</h2><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/ELMo/%E5%9B%BE3.png" alt="图3- GRU"></p><script type="math/tex; mode=display">重置门reset：r_{m×1}^{(t)}=\sigma(W_{m×n}^{r}x_{n×1}^{(t)}+U_{m×m}^{r}h_{m×1}^{(t-1)}+b_{m×1}^{r})\\更新门update：z_{m×1}^{(t)}=\sigma(W_{m×n}^{z}x_{n×1}^{(t)}+U_{m×m}^{z}h_{m×1}^{(t-1)}+b_{m×1}^{z})\\隐状态h：h_{m×1}^{(t)}=(1-z_{m×1}^{(t)}) \cdot h_{m×1}^{(t-1)}+z_{m×1}^{(t)} \cdot tanh(U_{m×m}^{h} \cdot (r_{m×1}^{(t)} \cdot h_{m×1}^{(t-1)})+W_{m×n}^{h} \cdot x_{n×1}^{(t)})</script><p>可以看出，GRU其实是LSTM变体，简单版LSTM。符号说明和标准RNN一致。</p><h2 id="3-ELMo（Embeddings-from-Language-Models）"><a href="#3-ELMo（Embeddings-from-Language-Models）" class="headerlink" title="3. ELMo（Embeddings from Language Models）"></a>3. ELMo（Embeddings from Language Models）</h2><p>ELMo框架如下（LSTM可换GRU）：</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/ELMo/%E5%9B%BE4.png" alt="图5- ELMo"></p><p>ELMo包含1个biLM（Bidirectional Language Models，即双向语言模型），分别是前向预测和后向预测。</p><script type="math/tex; mode=display">前向LM：p\left(t_{1}, t_{2}, \ldots, t_{N}\right)=\prod_{k=1}^{N} p\left(t_{k} | t_{1}, t_{2}, \ldots, t_{k-1}\right)\\后向LM：p\left(t_{1}, t_{2}, \ldots, t_{N}\right)=\prod_{k=1}^{N} p\left(t_{k} | t_{k+1}, t_{k+2}, \ldots, t_{N}\right)\\biLM：\sum_{k=1}^{N}\left(\log p\left(t_{k} | t_{1}, \ldots, t_{k-1} ; \Theta_{x}, \vec{\Theta}_{L S T M}, \Theta_{s}\right)\right.+\log p\left(t_{k} | t_{k+1}, \ldots, t_{N} ; \Theta_{x}, \Theta_{L S T M}, \Theta_{s}\right) )</script><p>即ELMo目标函数为biLM对数似然函数。</p><p>观察ELMo网络可知，以上图2层LSTM为例。分析如下：</p><ol><li><p><strong>注意：底层$E_{i}(i=1,2,…)$输入，为句子分词后对应位置单词的静态词向量，常用Word2vec/GloVe等。词向量维度为n</strong></p></li><li><p>记下层为层1，上层为层2。</p></li><li><strong>注意：1层LSTM包括前向LM &amp; 后向LM，且二者cell数目一致，等于词语数目。设词语数为A，则1层LSTM cell数目 = 2*A。</strong></li><li>以上图第二个词语，即$E_{2}$处，的前向LM为例，有上图所示。<strong>观察可以发现，其实在层2的下侧输入中，标准LSTM输入应该为$x_{n×1}$，即n维向量。然而！又由于LSTM隐状态输出为$h_{m×1}$,即m维向量！！因此，不难推断出，biLM中，其实是取m = n了！！</strong></li><li>如何获得ELMo词向量：</li></ol><ul><li><p>loss function为biLM对数似然函数，常规用SGD等算法优化更新参数；</p></li><li><p>ELMo词向量获取方法有多种：</p><p><strong>注意： $T_{2}$ 为前向 &amp; 后向LM concat向量，其余$T_{i}$ 同理，维度为2m</strong></p><ul><li><p>(1) 只取顶层LSTM的输出隐状态h向量（该例子即为层2）</p><p>以该例子（2层LSTM）中单词$E_{2}$为例，其对应ELMo词向量为</p></li></ul><script type="math/tex; mode=display">ELMo\_E2\_method1 = concat(x_{2},T_{2})</script><p><strong>即将该单词原输入词向量$x_{2}$和对应LSTM cell输出隐状态$T_{2}$，直接拼接。由于m = n，则ELMo词向量维度为3m。</strong>e.g.，取Word2vec维度为300输入，则ELMo输出为900维度词向量。</p><p>即下图的右侧图，左侧不用管。来源：《Semi-supervised sequence tagging with bidirectional language models》</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/ELMo/%E5%9B%BE5.PNG" alt="图5- ELMo1"></p><ul><li><p>(2) 取所有层的LSTM的输出隐状态h向量（<strong>层数设为L</strong>）</p><p>在这方法中，又有2种思路：<strong>1- 直接concat；2- 带系数求和后concat</strong></p><p>1- 直接concat</p></li></ul><p>同上，以该例子（2层LSTM）中单词$E_{2}$为例，此思路的对应ELMo词向量为：</p><script type="math/tex; mode=display">ELMo\_E2\_method2 = concat(x_{2},T_{2}^{(层1)},T_{2})</script><p><strong>和方法1相比，方法2也就只是concat多1层h向量。然而，在这例子是多1层，当层数很大时，例如100，则是concat多99层。</strong></p></li></ul><p><strong>该方法下ELMo词向量维度和LSTM层数有关，为（m+2mL）维度</strong></p><p>2- 带系数求和后concat</p><p>同上，有该思路下,单词$E_{2}$ELMo词向量：</p><pre><code>$$</code></pre><p>  ELMo_{E2}=γ\sum_{j=0}^{L}{s^{(j,2)} \cdot h_{m×1}^{(j,2)}} \\  T_{2}^{‘} = concat(ELMo_{E2}^{前向LM}, ELMo_{E2}^{后向LM})\\ ELMo_E2_method3 = concat(x_{2},T_{2}^{‘})</p><pre><code>$$</code></pre><p>  该思路关键如下：给每一层LSTM一个系数向量$s_{2A×1}$，按位置和该层的2A个$h$向量相乘后，所有层求和。最后再乘上系数γ，作为向量$ELMO_{E}$。<strong>注意：$ELMO_{E}$维度为m，还需一步是对应位置的前后向LM concat为$T_{2}^{‘}$，维度为2m</strong>。然后，将原输入静态词向量$x$和$T_{2}^{‘}$concat。<strong>该方法下ELMo词向量维度，为3m维度</strong></p><p>  <strong>论文采取方式：方法3，带系数求和后concat。</strong>其实方法2也可以，直接concat所有层h，但可能维度过高了。</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> ELMo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Road 2 NLP- Word Embedding词向量（FastText）</title>
      <link href="/2019/07/01/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88FastText%EF%BC%89/"/>
      <url>/2019/07/01/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88FastText%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-参考资料"><a href="#1-参考资料" class="headerlink" title="1. 参考资料"></a>1. 参考资料</h1><blockquote><ul><li>论文1：FastText1词向量，<a href="https://github.com/Eajack/NLP-Papers/blob/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/FastText/Enriching%20Word%20Vectors%20with%20Subword%20Information.pdf" target="_blank" rel="noopener">《Enriching Word Vectors with Subword Information》</a>，作者Bojanowski et al. （包括Mikolov），FAIR（Facebook AI Research）</li><li>论文2：FastText2文本分类模型，<a href="https://github.com/Eajack/NLP-Papers/blob/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/FastText/Bag%20of%20Tricks%20for%20Efficient%20Text%20Classification.pdf" target="_blank" rel="noopener">《Bag of Tricks for Efficient Text Classification》</a>，作者Joulin et al. （包括Mikolov），FAIR（Facebook AI Research）</li><li>博客文：<a href="https://heleifz.github.io/14732610572844.html" target="_blank" rel="noopener">《fastText 源码分析》</a></li><li><a href="https://github.com/facebookresearch/fastText/tree/master/src" target="_blank" rel="noopener">FastText源代码（C++）</a></li></ul></blockquote><p>主要参考资料如上，其实还有其他博客文，然而很多博客文都是互相抄袭的……而且很多都是讲解<strong>FastText文本分类模型</strong>，而非<strong>FastText词向量</strong>，前者基于后者建模。FastText文本分类模型原理简单易懂，然而词向量的训练原理有某些地方讲的很含糊。基于以上参考资料，我只能做出个人理解。（因为看源码看了很久，还是感觉没能解决我的核心疑惑……）</p><p>FastText其实是包括2个东西的：</p><ul><li><p>FastText词向量（PS：和Word2vec、GloVe一样，FastText词向量也属于<strong>静态词向量</strong>），对应论文1</p></li><li><p>FastText文本分类模型，对应论文2</p></li></ul><p>虽说本系列文章主题是：<strong>Word Embedding词向量</strong>，但是由于FastText特殊性，这里一起讲<strong>FastText文本分类模型</strong>。</p><p>FastText的最大优点：快速。</p><pre><code>《Efficient estimation of word representations in vector space》摘要部分：We can train fastText on more than one billion words in less than ten minutes using a standard multicore CPU, and classify half a million sentences among 312K classes in less than a minute.</code></pre><h1 id="2-FastText原理1：词向量训练"><a href="#2-FastText原理1：词向量训练" class="headerlink" title="2. FastText原理1：词向量训练"></a>2. FastText原理1：词向量训练</h1><p>关于FastText词向量资料，原论文<a href="https://github.com/Eajack/NLP-Papers/blob/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/FastText/Enriching%20Word%20Vectors%20with%20Subword%20Information.pdf" target="_blank" rel="noopener">《Enriching Word Vectors with Subword Information》</a>的原理部分提及得相当简略。</p><p>FastText词向量框架是基于Word2vec框架的，区别主要如下：</p><p>前者利用n-grams向量之和作为词向量（<strong>key point &amp; 疑惑点</strong>）</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/FastText/%E5%9B%BE1.PNG" alt="图1- FastText词向量表示"></p><p>即单词w对应1个n-grams集合（原论文为提取3-grams ~ 6-grams的所有子串），每个字串会有对应的向量，因此该单词w的词向量 = 所有n-grams字串向量求和。</p><p>关于n-grams，原论文有以下例子：</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/FastText/%E5%9B%BE2.PNG" alt="图2- n-grams"></p><p>这里，以<code>where</code>为例，其对应的3-grams子串集合<code>G={&quot;&lt;wh&quot;,&quot;whe&quot;,&quot;her&quot;,&quot;ere&quot;,&quot;re&gt;&quot;,&quot;&lt;where&gt;&quot;}</code>，其中每一个子串对应1个向量表示，则<code>where</code>词向量则为求和。同理对于中文，举例<code>苏格拉底</code>的3-grams子串集合<code>G_1={&quot;&lt;苏格&quot;,&quot;苏格拉&quot;,&quot;格拉底&quot;,&quot;拉底&gt;,&quot;&lt;苏格拉底&gt;&quot;}</code>。</p><p>以上原理都不难理解，关键在于：<strong>原论文貌似没给出子串向量是如何获得！</strong>当然n-grams向量理应是训练得到，然而如何训练，网络结构如何，原论文没提及，只是说基于Word2vec架构。Word2vec原理如下文：</p><p><a href="https://eajack.github.io/2019/06/21/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88Word2vec%EF%BC%89/">Road 2 NLP- Word Embedding词向量（Word2vec）</a></p><p>本人一直卡在<strong>如何训练n-grams子串向量</strong>这问题上。涉及资料主要是：博客文<a href="https://heleifz.github.io/14732610572844.html" target="_blank" rel="noopener">《fastText 源码分析》</a>、<a href="https://github.com/facebookresearch/fastText/tree/master/src" target="_blank" rel="noopener">FastText源代码（C++）</a>。经过多次分析猜测（由于本人最后还是放弃通读C++源码…我看了挺久，但还是不知道如何训练n-grams子串获得向量的，只发现了<strong>如何获取子串string</strong>代码）。</p><p><strong>FastText默认Skip-Gram模型，对比Word2vec的Skip-Gram模型，有以下个人理解</strong>（由于画图较为复杂，此处文字描述）：</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/Word2vec/%E5%9B%BE3.PNG" alt="图3- Skip-Gram"></p><p>如上图为Word2vec原Skip-Gram模型。</p><ul><li>输入层：输入为当前单词w的n-grams的index集合，从输入向量矩阵$W_{V×N}$中挑出对应n-grams向量求和，作为输入层的$x_{k}$。<strong>因此，FastText的输入层和Word2vec的区别在于：前者取n-gram求和作为词向量，后者取One-Hot词向量；前者输入向量矩阵$W_{V×N}$，其N为所有语料的n-grams总数，后者则为语料word总数。</strong></li><li>隐含层&amp;输出层：Word2vec &amp; FastText一致。</li></ul><p>因此，FastText词向量训练框架 &amp; Word2vec不一致仅在于输入层。（PS：个人理解）</p><h1 id="3-FastText原理2：文本分类模型"><a href="#3-FastText原理2：文本分类模型" class="headerlink" title="3. FastText原理2：文本分类模型"></a>3. FastText原理2：文本分类模型</h1><p>FastText文本分类模型和词向量训练框架差不多，有了词向量的原理基础，该模型可以很简单地用下图总结：</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/FastText/%E5%9B%BE3.PNG" alt="图4- FastText文本分类模型"></p><p>如上图，FastText文本分类模型仅3层。</p><ul><li>输入层：句子的n-grams表示向量（<strong>PS：此处的n-grams向量为经过FastText词向量训练获得</strong>）</li><li>隐藏层：n-grams向量求平均（<strong>PS：FastText词向量训练则是求和</strong>）</li><li>输出层：softmax层（<strong>PS：沿用Word2vec的Hierarchical Softmax</strong>）</li></ul><p>由此可以看出，关键是输入层的<strong>n-grams向量</strong>，而这个便是FastText词向量训练步骤。所以，FastText文本分类模型包括2步：<strong>1- FastText词向量训练；2- FastText文本分类模型构建</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> FastText </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Road 2 NLP- Word Embedding词向量（GloVe）</title>
      <link href="/2019/06/22/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88GloVe%EF%BC%89/"/>
      <url>/2019/06/22/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88GloVe%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>参考资料</strong></p><blockquote><ul><li>GloVe开山之作：《GloVe: Global Vectors for Word Representation》，作者Jeffrey Pennington（Stanford NLP）</li><li>CSDN博客文章：<a href="https://blog.csdn.net/u014665013/article/details/79642083" target="_blank" rel="noopener">理解GloVe模型（+总结）</a></li></ul></blockquote><p>个人觉得这篇文章：<a href="https://blog.csdn.net/u014665013/article/details/79642083" target="_blank" rel="noopener">理解GloVe模型（+总结）</a>，已经讲的很好了…我直接看这文章弄懂了GloVe原理的。有了上一篇Word2vec基础，GloVe原理不是很难：</p><p><a href="https://eajack.github.io/2019/06/21/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88Word2vec%EF%BC%89/">Road 2 NLP- Word Embedding词向量（Word2vec）</a></p><p>按照GloVe原文可知，GloVe综合2类Word Representation模型优点：</p><pre><code>The two main model families for learning word vectors are: 1) global matrix factorization methods,such as latent semantic analysis (LSA) (Deerwester et al., 1990) and 2) local context window methods, such as the skip-gram model of Mikolov et al. (2013c).GloVe = global matrix factorization methods + local context window methods</code></pre>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> GloVe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>blog建站日志</title>
      <link href="/2019/06/21/blog%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/"/>
      <url>/2019/06/21/blog%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>该个人blog powered by Hexo &amp; github pages，在建blog时涉及到的资料有以下几个：</p><blockquote><ul><li><a href="http://opiece.me/2015/04/09/hexo-guide/" target="_blank" rel="noopener">使用Hexo搭建个人博客(基于hexo3.0)</a></li><li>参考风格源于<a href="http://flygon.net/" target="_blank" rel="noopener">龙哥盟</a></li><li><a href="https://github.com/wizardforcel/blog" target="_blank" rel="noopener">龙哥盟blog</a>的github开源地址</li><li>Hexo的<a href="https://github.com/wizardforcel/hexo-theme-cyanstyle" target="_blank" rel="noopener">cyanstyle</a>风格github源码</li><li><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a></li></ul></blockquote><p><strong>update on 2017/8/19</strong></p><p>关于搭建博客如何备份md的问题，刚好搜到相关资料，可以把source下的markdown文章储存在Github博客同一仓库的其它分支branch上。具体参考资料如下：</p><blockquote><ul><li>博客教程<a href="http://fanzhenyu.me/2017/08/10/Github-Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88%E5%9B%9B%EF%BC%89/#more" target="_blank" rel="noopener">Github Pages + Hexo搭建博客（四）</a></li><li>Github开源库<a href="https://github.com/coneycode/hexo-git-backup" target="_blank" rel="noopener">hexo-git-backup</a></li></ul></blockquote><p><strong>update on 2018/7/28</strong></p><p>终于，blog换了新主题了，之前的老问题也相应的修复了。找了好久，感觉这个<a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="noopener">material主题</a>不错，挺喜欢的。</p><p>以下为本人迁移主题时涉及到的主要资料：</p><blockquote><ul><li>博客教程1<a href="https://zdran.com/20180326.html" target="_blank" rel="noopener">Hexo + Material + Github 搭建博客与配置</a></li><li>博客教程2<a href="https://crowncj.com/20170616.html" target="_blank" rel="noopener">Hexo Material 主题博客搭建以及优化心得</a></li></ul></blockquote><p><strong>update on 2019/6/21</strong></p><p>添加hexo支持Mathjax输入数学公式的功能，TeX公式语法。尽管Typora内置渲染可以显示TeX公式，然而Hexo原生并不行。该教程也是Material主题，因此选了这个教程。</p><blockquote><ul><li>Hexo + Mathjax教程：<a href="https://ranmaosong.github.io/2017/11/29/hexo-support-mathjax" target="_blank" rel="noopener">如何在 hexo 中支持 Mathjax？</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Road 2 NLP- Word Embedding词向量（Word2vec）</title>
      <link href="/2019/06/21/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88Word2vec%EF%BC%89/"/>
      <url>/2019/06/21/Road%202%20NLP-%20Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F%EF%BC%88Word2vec%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-参考资料"><a href="#1-参考资料" class="headerlink" title="1. 参考资料"></a>1. 参考资料</h1><blockquote><ul><li>Word2vec 开山之作1：《Distributed Representations of Sentences and Documents》，作者Mikolov</li><li>Word2vec 开山之作2：《Efficient estimation of word representations in vector space》，作者Mikolov</li><li>Word2vec论文讲解：《word2vec Parameter Learning Explained》,作者Xin Rong</li><li>知乎专栏文：<a href="https://zhuanlan.zhihu.com/p/26306795" target="_blank" rel="noopener">[NLP] 秒懂词向量Word2vec的本质</a></li><li>博客文章：<a href="https://www.cnblogs.com/pinard/p/7249903.html" target="_blank" rel="noopener">word2vec原理(三) 基于Negative Sampling的模型</a></li></ul></blockquote><p>以下为<a href="https://zhuanlan.zhihu.com/p/26306795" target="_blank" rel="noopener">[NLP] 秒懂词向量Word2vec的本质</a> 的推荐资料分析：</p><pre><code>1. Mikolov 两篇原论文：『Distributed Representations of Sentences and Documents』      贡献：在前人基础上提出更精简的语言模型（language model）框架并用于生成词向量，这个框架就是 Word2vec『Efficient estimation of word representations in vector space』      贡献：专门讲训练 Word2vec 中的两个trick：hierarchical softmax 和 negative sampling优点：Word2vec 开山之作，两篇论文均值得一读缺点：只见树木，不见森林和树叶，读完不得要义。      这里『森林』指 word2vec 模型的理论基础——即 以神经网络形式表示的语言模型      『树叶』指具体的神经网络形式、理论推导、hierarchical softmax 的实现细节等等2. 北漂浪子的博客：『深度学习word2vec 笔记之基础篇』优点：非常系统，结合源码剖析，语言平实易懂缺点：太啰嗦，有点抓不住精髓3. Yoav Goldberg 的论文：『word2vec Explained- Deriving Mikolov et al.’s Negative-Sampling Word-Embedding Method』优点：对 negative-sampling 的公式推导非常完备缺点：不够全面，而且都是公式，没有图示，略显干枯4. Xin Rong 的论文：『word2vec Parameter Learning Explained』：！重点推荐！理论完备由浅入深非常好懂，且直击要害，既有 high-level 的 intuition 的解释，也有细节的推导过程一定要看这篇paper！一定要看这篇paper！一定要看这篇paper！5. 来斯惟的博士论文『基于神经网络的词和文档语义向量表示方法研究』以及他的博客（网名：licstar）可以作为更深入全面的扩展阅读，这里不仅仅有 word2vec，而是把词嵌入的所有主流方法通通梳理了一遍6. 几位大牛在知乎的回答：『word2vec 相比之前的 Word Embedding 方法好在什么地方？』刘知远、邱锡鹏、李韶华等知名学者从不同角度发表对 Word2vec 的看法，非常值得一看7. Sebastian 的博客：『On word embeddings - Part 2: Approximating the Softmax』详细讲解了 softmax 的近似方法，Word2vec 的 hierarchical softmax 只是其中一种</code></pre><p><strong>对比上述所有资料，重点看《word2vec Parameter Learning Explained》，并期望基于此文完全弄懂Word2vec原理。</strong></p><h1 id="2-Word2vec原理（《word2vec-Parameter-Learning-Explained》）"><a href="#2-Word2vec原理（《word2vec-Parameter-Learning-Explained》）" class="headerlink" title="2. Word2vec原理（《word2vec Parameter Learning Explained》）"></a>2. Word2vec原理（《word2vec Parameter Learning Explained》）</h1><p><strong>Word2vec = CBOW + Skip-Gram（Hierarchical Softmax &amp; Negative Sampling）</strong></p><p>其中，</p><ul><li>CBOW：上下文词语 预测 中心词</li><li>Skip-Gram：中心词 预测 上下文词语</li></ul><h2 id="2-1-One-Word-Context（CBOW-amp-Skip-Gram一致的最简单情形）"><a href="#2-1-One-Word-Context（CBOW-amp-Skip-Gram一致的最简单情形）" class="headerlink" title="2.1. One-Word Context（CBOW &amp; Skip-Gram一致的最简单情形）"></a>2.1. One-Word Context（CBOW &amp; Skip-Gram一致的最简单情形）</h2><ul><li>问题描述：最简单情形，<strong>input =&gt; 当前词，output =&gt; 下一个词，即输入当前词预测下一个词</strong></li><li>模型框架</li></ul><p>为方便解说，这里不直接引用原论文图，自己重新Visio画。</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/Word2vec/%E5%9B%BE1.png" alt="图1- One-Word-Context"></p><p>(1). Input layer：输入：$X_{V×1} = OneHot(wordNow)$（模型外部输入input1）, 初始化随机矩阵$W_{V×N}$（<strong>PS：$W_{V×N}$第w行的行向量 $V_w$,称作输入向量(input vector)，Size为：1×N，N为词向量维度，V&gt;&gt;N</strong>）。输出：$h_{N×1}=W_{V×N}^{T}X_{V×1}$。</p><p>(2). Hidden layer：输入：Input层输出$h_{N×1}$，初始化随机矩阵 $W^{‘}_{V×N}$（<strong>PS：$W^{‘}_{V×N}$的第w列的列向量 , $V^{‘}_w$称作输出向量(output vector)，Size为：N×1</strong>）。输出：$u_{V×1}=W^{‘T}_{N×V}h_{N×1}$。</p><p>(3). Output layer：输入：Hidden层输出$u$。输出：$y_j = \frac{exp(u_j)}{\sum_{a=1}^{V}exp(u_a)}$（预测输出Y_predict）。实际输出（模型外部输入input2）$YReal=OneHot(wordNext)$。Y_predict &amp; Y_real构造loss function更新权值$W$、$W^{‘}$。</p><p>输入向量矩阵$W$、输出向量矩阵$W^{‘}$，均可作为词语的词向量表示。<strong>但是Word2vec采用输入向量矩阵$W$</strong>。原因：输出向量矩阵$W^{‘}$更新代价大，以下为《word2vec Parameter Learning Explained》原文</p><pre><code>1. 英文原文：Learning the input vectors is cheap; but learning the output vectors is very expensive. From the update equations (22)and (33), we can and that, in order to update v_w , for each training instance, we have to iterate through every word w_j in the vocabulary, compute their net input u_j , probability prediction y_j (or y_{cj} for skip-gram), their prediction error e_j (or EI_j for skip-gram), and finally use their prediction error to update their output vector v^{&#39;}_{j}.Doing such computations for all words for every training instance is very expensive,making it impractical to scale up to large vocabularies or large training corpora. To solve this problem, an intuition is to limit the number of output vectors that must be updated per training instance. One elegant approach to achieving this is hierarchical softmax; another approach is through sampling, which will be discussed in the next section.2. 中文翻译（Google）：学习输入向量很便宜; 但学习输出向量非常昂贵。从更新方程（22）和（33），我们可以和那个为了更新v_w，对于每个训练实例，我们必须遍历词汇表中的每个单词w_j，计算它们的净输入u_j，概率预测y_j（ 或者y_ {cj}用于skip-gram），它们的预测误差e_j（或者用于skip-gram的EI_j），并且最后使用它们的预测误差来更新它们的输出向量v^{&#39;}_{j}。对每个训练实例的所有单词进行此类计算非常昂贵，使扩展到大型词汇表或大型培训语料库变得不切实际。为了解决这个问题，直觉是限制每个训练实例必须更新的输出向量的数量。 实现这一目标的一个优雅方法是分层softmax; 另一种方法是通过抽样，这将在下一节中讨论。</code></pre><p><strong>这段文字有2个结论：（1）训练输入向量更容易；（2）Hierarchical Softmax &amp; Negative Sampling 方法都是用于更新输出向量的。</strong></p><ul><li>模型本质</li></ul><p>通过上面对3层分析，Word2vec模型本质：<strong>训练更新权值矩阵W，即输入向量矩阵，作为词向量表。因为矩阵W尺寸为V×N，则每一行的行向量对应着该位置的词的Word2vec词向量</strong></p><ul><li>模型例子</li></ul><p>词库为：“我”、“喜欢”、“苹果”，对应的One-Hot词向量分别为[1,0,0]、[0,1,0]、[0,0,1]。输入到One-Word-Context CBOW模型，取词向量维度N=2（一般V&gt;&gt;N，此处V=3，作为例子取N=2）经过训练得到W矩阵如下：</p><script type="math/tex; mode=display">W = \begin{bmatrix}0.2 & 0.4\\\\0.6 &0.7\\\\0.8 &0.1\end{bmatrix}</script><p>尺寸为V x N，即3 x 2。因此，“我”的Word2vec词向量为[0.2, 0.4]，“喜欢”的Word2vec词向量为[0.6, 0.7]，“苹果的”Word2vec词向量为[0.8, 0.1]。</p><ul><li>loss function</li></ul><p>Output层的预测输出：$y_j = \frac{exp(u_j)}{\sum_{a=1}^{V}exp(u_a)}$</p><p>联合额外公式：$h_{N×1}=W_{V×N}^{T}X_{V×1}=v_{wI}^{T}$、 <script type="math/tex">u_j=V_w^{'T}h_{N×1}</script> PS：$u_j$为标量，$V_w^{‘T}$尺寸为1×N。</p><p>推导出：</p><script type="math/tex; mode=display">y_j = \frac{exp(V_{w_j}^{'T}v_{wI}^{T})}{\sum_{a=1}^{V}{exp(V_{w_a}^{'T}v_{wI}^{T}})}</script><p>令loss function为最大似然函数：</p><script type="math/tex; mode=display">E=log(y_j)=u_j - log(\sum_{a=1}^{V}exp(u_a))</script><ul><li>模型训练：参数更新（BP/SGD算法）</li></ul><p>PS：此处涉及矩阵求导。。也不是很懂，尽可能去理解。部分公式可能编辑有问题，能理解原意即可。</p><p>(1). $W^{‘}$更新：$u→W^{‘}$(output→hidden)</p><p>$u$：$\frac{\partial E}{\partial u_j}=y_j - t_j := e_j$（y$_j$为实际输出；$t_j=1(j=j^{real})$，$j$为预测输出y位置，$j^{real}$后者则为实际输出；$e_j为$预测error）</p><p>$W^{‘}$：$\frac{\partial E}{\partial w_{ij}}=\frac{\partial E}{\partial u_j} - \frac{\partial u_j}{\partial w_{ij}} := e_j * h_i$</p><p><strong>更新公式</strong>：</p><script type="math/tex; mode=display">w_{ij}^{(new)} = w_{ij}^{(old)}  - η * e_j * h_i</script><script type="math/tex; mode=display">V_{wj}^{'(new)} = V_{wj}^{'(old)}  - η * e_j * h</script><p>$V_{wj}$为$W^{‘}$矩阵的第$j$列的列向量，即输出向量。</p><p>(2). $W$更新：$h→W$(hidden→input)</p><p>$h：\frac{\partial E}{\partial h_i}=\sum_{j=1}^{V}{\frac{\partial E}{\partial u_j}\frac{\partial u_j}{\partial h_i}} =\sum_{j=1}^{V}{e_j * w^{‘}_{ij}}:= Z_i$</p><p>$W：\frac{\partial E}{\partial w_{ki}}=\frac{\partial E}{\partial h_i}\frac{\partial h_i}{\partial w_{ki}}=Z_i*X_k$</p><p>PS：$\frac{\partial E}{\partial W}=X_{V×1}叉乘Z$，叉乘定义：$a 叉乘 b = |a||b|sin(a,b)$。由于$X$仅有唯一位置非0，则$\frac{\partial E}{\partial W}$仅有唯一的一行非零向量，其值为$Z^T$</p><p><strong>更新公式</strong>：</p><script type="math/tex; mode=display">V^{(new)}_{wI}=V^{(old)}_{wI}-η*Z^{T}</script><p>$V_{wI}$为$W$矩阵的第$i$行的行向量，即输入向量。</p><p>至此One-Word-Context所有原理结束，接下来的Multi-Word CBOW &amp; Skip-Gram模型原理和这个差别不大，仅在此基础上修改部分公式。</p><h2 id="2-2-CBOW（Continuous-Bag-of-Word-Model）"><a href="#2-2-CBOW（Continuous-Bag-of-Word-Model）" class="headerlink" title="2.2 CBOW（Continuous Bag-of-Word Model）"></a>2.2 CBOW（Continuous Bag-of-Word Model）</h2><h3 id="2-2-1-Multi-Word-Context"><a href="#2-2-1-Multi-Word-Context" class="headerlink" title="2.2.1 Multi-Word Context"></a>2.2.1 Multi-Word Context</h3><p>Multi-Word的意思是说，多个上下文词语 =&gt; 中心词（当前词）。<strong>CBOW，即为One-Word-Context的Input layer扩展</strong>。此处直接借用文献图</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/Word2vec/%E5%9B%BE2.PNG" alt="图2- CBOW"></p><ul><li>和One-Word-Context的唯一区别：$h=\frac{1}{C}W^{T}(x_{1}+x_{2}+···+x_{C})=\frac{1}{C}(V_{w1}+V_{w2}+···+V_{wC})^{T}$，<strong>即取上下文总共C个词语的One-Hot编码，上下文词数分别为$\frac{2}{C}$，求平均所有Input layer输入</strong>。</li></ul><h2 id="2-3-Skip-Gram"><a href="#2-3-Skip-Gram" class="headerlink" title="2.3 Skip-Gram"></a>2.3 Skip-Gram</h2><p>同CBOW理，<strong>Skip-Gram，即为One-Word-Context的Output layer扩展</strong>。</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/Word2vec/%E5%9B%BE3.PNG" alt="图3- Skip-Gram"></p><ul><li>和One-Word-Context的唯一区别：loss function<script type="math/tex; mode=display">\begin{aligned} E &=-\log p\left(w_{O, 1}, w_{O, 2}, \cdots, w_{O, C} | w_{I}\right) \\ &=-\log \prod_{c=1}^{C} \frac{\exp \left(u_{c, j_{c}}^{*}\right)}{\sum_{j^{\prime}=1}^{V} \exp \left(u_{j^{\prime}}\right)} \\ &=-\sum_{c=1}^{C} u_{j_{c}^{*}}+C \cdot \log \sum_{j^{\prime}=1}^{V} \exp \left(u_{j^{\prime}}\right) \end{aligned}</script></li></ul><h2 id="2-4-Hierarchical-Softmax"><a href="#2-4-Hierarchical-Softmax" class="headerlink" title="2.4 Hierarchical Softmax"></a>2.4 Hierarchical Softmax</h2><p>分层softmax（Hierarchical Softmax）本质是优化版softmax，<strong>即引入Hierarchical Softmax仅是代替原来softmax结构，优化output vector计算复杂度</strong>。</p><ul><li>原softmax：$y_{i}=\frac{exp(x_i)}{\sum_{a=1}^{V}{exp(x_a)}}$，其中$x_i$为输入向量$X_{V×1}$第$i$位数值标量，$y_i$则为对应输出，输出向量$Y_{V×1}$</li></ul><p>可以看出，计算一次$y_i$需要知道所有$x_{i}$值。复杂度为O(V)。</p><ul><li><p>Hierarchical Softmax：引入霍夫曼树，首先依据词频构建霍夫曼树，词语节点都是叶节点。q</p><p>如下图为论文原图</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/Word2vec/%E5%9B%BE4.PNG" alt="图4- Hierarchical Softmax"></p></li></ul><p>在Hierarchical Softmax中，举例如上图，计算词语$w_{2}$对应的softmax近似概率（H-softmax计算近似值）：</p><script type="math/tex; mode=display">y_{i}=P(w_{2}=w_{O})=P(n(w_2,1),left)*P(n(w_2,2),left)*P(n(w_2,3),right)=σ(v^{'T}_{n(w_{2},1)}h)*σ(v^{'T}_{n(w_{2},2)}h)*(1-σ(v^{'T}_{n(w_{2},3)}h))</script><p>其中$v^{‘T}_{n(w_{2},1)}、v^{‘T}_{n(w_{2},2)}、v^{‘T}_{n(w_{2},3)}$分别为3个节点参数，需要训练更新。</p><p>且</p><script type="math/tex; mode=display">\sum_{a=1}^{V}{P(w_{i}=w_{O})}=1</script><p>为表示方便，上图例子公式如下</p><script type="math/tex; mode=display">y_{i}=σ(θ^{'T}_{n(w_{2},1)}h)*σ(θ^{'T}_{n(w_{2},2)}h)*(1-σ(θ^{'T}_{n(w_{2},3)}h))</script><p>其中，$σ(x)$函数为二元逻辑回归函数$y=\frac{1}{1+exp(-X^{T}*θ)}$。</p><p>容易看出，上面计算$y_{i}$公式计算复杂度下降，不再需要计算V步，仅需要$log(V)$步（即$w_2$路径长）。所以Hierarchical Softmax的计算复杂度为$O(log(V))$</p><p><strong>参数更新：</strong></p><script type="math/tex; mode=display">\theta^{(new)}_j = \theta^{(old)}_j – \eta(\sigma({\theta_j}^Th)-t_j)h</script><h2 id="2-5-Negative-Sampling"><a href="#2-5-Negative-Sampling" class="headerlink" title="2.5 Negative Sampling"></a>2.5 Negative Sampling</h2><p>参考博客文章<a href="https://www.cnblogs.com/pinard/p/7249903.html" target="_blank" rel="noopener">word2vec原理(三) 基于Negative Sampling的模型</a>，总结如下。</p><p><strong>Negative Sampling，是代替H-softmax方法的另一种优化计算output vector的方法。</strong>如其名，这方法涉及采样（Sampling）。</p><ul><li><p>大致原理：现有训练样本,包括当前中心词$w$和C个上下文词$Context(w)$（上下文分别$\frac{2}{C}$个词），命名为<strong>正例</strong>。对词库进行负采样（Negative Sampling），得到<strong>非$w$的N个中心词$w_i(i=1,2,···,N)$</strong>，将N个样本$w_i、Context(w)(i=1,2,···,N)$（注意：$Context(w)$没变，只是中心词w变了）一起作为训练样本，命名为<strong>负例</strong>。正例 &amp; 负例 =&gt; loss function。</p></li><li><p>2个问题：如上原理介绍，有2个问题：</p><ul><li>Q1：如何Negative Sampling获得<strong>非$w$的N个中心词$w_i(i=1,2,···,N)$</strong>？</li><li>Q2：如何根据正负样例构造loss function？</li></ul></li><li><p>Q1：Negative Sampling</p><p>词库词语数量为V，引入长度为1的标准线L，将其分为V份，每一小段对应1个词语。Word2vec中，定义每个词语对应的长度为$len(w_{i})=\frac{count(w_{i})^{3/4}}{\sum_{a=1}^{V}{count(w_{i})^{3/4}}}$，且有$\sum_{a=1}^{V}{len(w_i)=1}$。</p><p>采样前，将标准线L等分为M份（M&gt;&gt;V，Word2vec中M取$10^{8}$），因此每个词长可以对应若干个M小份长度。如下图为博客图片：</p><p><img src="https://raw.githubusercontent.com/Eajack/NLP-Papers/master/Word%20Embedding%E8%AF%8D%E5%90%91%E9%87%8F/Word2vec/%E5%9B%BE5.PNG" alt="图5- Negative Sampling"></p><p>采样时，随机在M个位置中采样N个$m_{i}$位置，则每一个位置肯定落入对应的1个词语。注意：采样词不要重复且不能和当前中心词$w$一样。</p></li><li><p>Q2：loss function</p><p>定义当前词$w$为$w_{0}$，正例为$[w_{0},Context(w_{0})]$,负例为$[w_{i},Context(w_{i})]（i=1,2,···,N）$。</p><p>根据逻辑函数有正例概率：</p><script type="math/tex; mode=display">P(context(w_0), w_i) = \sigma(x_{w_0}^T\theta^{w_i}) ,y_i=1, i=0</script><p>负例概率：</p><script type="math/tex; mode=display">P(context(w_0), w_i) =1-  \sigma(x_{w_0}^T\theta^{w_i}), y_i = 0, i=1,2,..N</script><p>最大化公式：</p><script type="math/tex; mode=display">\prod_{i=0}^{N}P(context(w_0), w_i) = \sigma(x_{w_0}^T\theta^{w_0})\prod_{i=1}^{N}(1-  \sigma(x_{w_0}^T\theta^{w_i}))</script><p>似然函数：</p><script type="math/tex; mode=display">Q=\prod_{i=0}^{N} \sigma(x_{w_0}^T\theta^{w_i})^{y_i}(1-  \sigma(x_{w_0}^T\theta^{w_i}))^{1-y_i}</script><p>log似然：</p><script type="math/tex; mode=display">L = \sum\limits_{i=0}^{N}y_i log(\sigma(x_{w_0}^T\theta^{w_i})) + (1-y_i) log(1-  \sigma(x_{w_0}^T\theta^{w_i}))</script><p><strong>参数更新：（SGD算法）</strong></p><p>类似前面操作，最终有参数$x_{w_0}, \theta^{w_i},  i=0,1,..N$更新公式。具体参考<a href="https://www.cnblogs.com/pinard/p/7249903.html" target="_blank" rel="noopener">word2vec原理(三) 基于Negative Sampling的模型</a>。</p></li></ul><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><ul><li><p><strong>Word2vec = CBOW + Skip-Gram（Hierarchical Softmax &amp; Negative Sampling）</strong></p><p>其中，CBOW：上下文词语 预测 中心词；Skip-Gram：中心词 预测 上下文词语</p></li><li><p><strong>Word2vec词向量仅是模型副产品，即输入向量矩阵W</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> NLP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
            <tag> Word2vec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eajack LeetCode Notes- Day3</title>
      <link href="/2019/06/12/Eajack%20LeetCode%20Notes-%20Day3/"/>
      <url>/2019/06/12/Eajack%20LeetCode%20Notes-%20Day3/</url>
      
        <content type="html"><![CDATA[<p><strong>PS：由于最近leetcode官网访问问题，暂改成leetcode-zh刷题。</strong></p><h2 id="1-题目解答"><a href="#1-题目解答" class="headerlink" title="1. 题目解答"></a>1. 题目解答</h2><h3 id="Q15"><a href="#Q15" class="headerlink" title="Q15"></a>Q15</h3><h4 id="1-题目信息"><a href="#1-题目信息" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：x 的平方根</li><li>编号&amp;难度：[69]，easy</li><li>Tags：binary-search | math</li><li>描述：实现 int sqrt(int x) 函数。计算并返回 x 的平方根，其中 x 是非负整数。由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</li><li>例子：</li></ul></blockquote><pre><code>输入: 4输出: 2输入: 8输出: 2说明: 8 的平方根是 2.82842...,      由于返回类型是整数，小数部分将被舍去。</code></pre><h4 id="2-个人Code"><a href="#2-个人Code" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=69 lang=cpp * * [69] Sqrt(x) */class Solution {public:    int mySqrt(int x) {        long low = 0, high = x, mid = x/2;        if(x == 1)        {            return 1;        }        else        {            //binary-search            while(low &lt; high)            {                if( (mid*mid == x) || ((mid*mid &lt; x) &amp;&amp; ((mid+1)*(mid+1) &gt; x)) )                {                    return mid;                }                else if(mid*mid &lt; x)                {                    low = mid;                    mid = (low+high)/2;                }                else                {                    high = mid;                    mid = (low+high)/2;                }            }            return mid;        }        return mid;    }};</code></pre><blockquote><ul><li>思路：二分法求开方，重点在于第一个if判断<code>if( (mid*mid == x) || ((mid*mid &lt; x) &amp;&amp; ((mid+1)*(mid+1) &gt; x)) )</code>。前半段<code>(mid*mid == x)</code>表明，mid刚好为sqrt数；后半段<code>((mid*mid &lt; x) &amp;&amp; ((mid+1)*(mid+1) &gt; x))</code>表明以下情况：</li></ul></blockquote><pre><code>mid = 2;x = 5;mid*mid = 4 &lt; 5;(mid+1)*(mid+1) = 9 &gt;5;5^0.5 =&gt; 2;</code></pre><h4 id="3-best-solution"><a href="#3-best-solution" class="headerlink" title="(3) best solution"></a>(3) best solution</h4><pre><code class="lang-cpp">//Newton method// holy shit, so short!/*任说1个整数x，我任猜它的平方根为y，如果不对或精度不够准确，那我令y = (y+x/y)/2。如此循环反复下去，y就会无限逼近x的平方根*/long r = x;while (r*r &gt; x)    r = (r + x/r) / 2;return r;</code></pre><blockquote><ul><li>思路：牛顿法求开方数。。算法很简单</li></ul></blockquote><h3 id="Q16"><a href="#Q16" class="headerlink" title="Q16"></a>Q16</h3><h4 id="1-题目信息-1"><a href="#1-题目信息-1" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：爬楼梯</li><li>编号&amp;难度：[70]，easy</li><li>Tags：dynamic-programming</li><li>描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。</li><li>例子：</li></ul></blockquote><pre><code>输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1.  1 阶 + 1 阶2.  2 阶输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1.  1 阶 + 1 阶 + 1 阶2.  1 阶 + 2 阶3.  2 阶 + 1 阶</code></pre><h4 id="2-个人Code-1"><a href="#2-个人Code-1" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=70 lang=cpp * * [70] Climbing Stairs */class Solution {public:    int climbStairs(int n) {        if(n==1)        {            return 1;        }        else if(n==2)        {            return 2;        }        //Fibonacci        int* fibonacci_array = new int[n];        fibonacci_array[0] = 1; fibonacci_array[1] = 2;        for(int i=2; i&lt;n; i++)        {            fibonacci_array[i] = fibonacci_array[i-2] + fibonacci_array[i-1];        }        return fibonacci_array[n-1];    }};</code></pre><blockquote><ul><li>思路：爬楼梯问题，高中数学竞赛课碰到过的题目。。明显是<strong>斐波那契数列</strong>：令F(n)为爬第n级楼梯方法数，则F(n) = F(n-1) + F(n-2)，<strong>因为爬到第n级的前一step，只有两个可能，脚在倒数第一个台阶&amp;倒数第二个台阶。</strong>斐波那契求解，明显不能用递归，要用顺序迭代。该题最佳思路一样，只不过不保存，没有O(n)的空间复杂度<code>fibonacci_array[n]</code></li></ul></blockquote><h3 id="Q17"><a href="#Q17" class="headerlink" title="Q17"></a>Q17</h3><h4 id="1-题目信息-2"><a href="#1-题目信息-2" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：删除排序链表中的重复元素</li><li>编号&amp;难度：[83]，easy</li><li>Tags：linked-list</li><li>描述：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</li><li>例子：</li></ul></blockquote><pre><code>输入: 1-&gt;1-&gt;2输出: 1-&gt;2输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3</code></pre><h4 id="2-个人Code-2"><a href="#2-个人Code-2" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=83 lang=cpp * * [83] Remove Duplicates from Sorted List *//** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode* deleteDuplicates(ListNode* head) {        //len == 0 or 1        if(head == nullptr || head-&gt;next==nullptr)        {            return head;        }        //len &gt; 1        ListNode *p=head, *k=head-&gt;next;         while(1)        {            int val_current = p-&gt;val;            ListNode* temp = nullptr;            while(k != nullptr &amp;&amp; k-&gt;val == val_current)            {                temp = k;                k = k-&gt;next;                p-&gt;next = k;                delete temp;            }            if(k == nullptr)            {                break;            }            else            {                p = k;                k = p-&gt;next;            }        }        return head;    }};</code></pre><blockquote><ul><li>思路：two-pointers思想，双指针。第二指针遍历和第一指针值对比，相等则delete掉。<strong>双指针方法重点在于边界检查。</strong></li></ul></blockquote><h4 id="2-个人Code-3"><a href="#2-个人Code-3" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">class Solution {public:    ListNode* deleteDuplicates(ListNode* head) {        return head &amp;&amp; (head-&gt;next = deleteDuplicates(head-&gt;next)) &amp;&amp; \            head-&gt;next-&gt;val == head-&gt;val ? head-&gt;next : head;    }};</code></pre><blockquote><ul><li>思路：无fa可说。。简洁代码要多练才能想到。。</li></ul></blockquote><h3 id="Q18"><a href="#Q18" class="headerlink" title="Q18"></a>Q18</h3><h4 id="1-题目信息-3"><a href="#1-题目信息-3" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：合并两个有序数组</li><li>编号&amp;难度：[88]，easy</li><li>Tags：array | two-pointers</li><li><p>描述：给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。<br>说明:<br>(1) 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。<br>(2) 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p></li><li><p>例子：</p></li></ul></blockquote><pre><code>输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6],       n = 3输出: [1,2,2,3,5,6]</code></pre><h4 id="2-个人Code-4"><a href="#2-个人Code-4" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=88 lang=cpp * * [88] 合并两个有序数组 */class Solution {public:    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {        int i=m-1, j=n-1, k=m+n-1;        while(j &gt;= 0)        {            nums1[k--] = (i&gt;=0 &amp;&amp; nums1[i]&gt;nums2[j])?(nums1[i--]):(nums2[j--]);        }    }};</code></pre><blockquote><ul><li>思路：这里看了solution了。。这逆序思路很好。。</li></ul></blockquote><h3 id="Q19"><a href="#Q19" class="headerlink" title="Q19"></a>Q19</h3><h4 id="1-题目信息-4"><a href="#1-题目信息-4" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：相同的树</li><li>编号&amp;难度：[100]，easy</li><li>Tags：depth-first-search | tree</li><li>描述：给定两个二叉树，编写一个函数来检验它们是否相同。<br>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</li><li>例子：</li></ul></blockquote><pre><code>输入:       1         1          / \       / \         2   3     2   3        [1,2,3],   [1,2,3]输出: true输入:      1          1          /           \         2             2        [1,2],     [1,null,2]输出: false输入:       1         1          / \       / \         2   1     1   2        [1,2,1],   [1,1,2]输出: false</code></pre><h4 id="2-个人Code-5"><a href="#2-个人Code-5" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=100 lang=cpp * * [100] 相同的树 *//** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    bool isSameTree(TreeNode* p, TreeNode* q) {        if( (!p&amp;&amp;!q) ) return true;        if( (!p&amp;&amp;q) || (p&amp;&amp;!q) ) return false;        return (p-&gt;val == q-&gt;val) &amp;&amp; (isSameTree(p-&gt;left,q-&gt;left)) &amp;&amp; \            (isSameTree(p-&gt;right, q-&gt;right));    }};</code></pre><blockquote><ul><li>思路：巨坑在于要求中树的表示，右子树为NULL时，不表示出来。。不懂怎么弄的，看了solution，这思路很好理解。</li></ul></blockquote><h3 id="Q20"><a href="#Q20" class="headerlink" title="Q20"></a>Q20</h3><h4 id="1-题目信息-5"><a href="#1-题目信息-5" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：对称二叉树</li><li>编号&amp;难度：[101]，easy</li><li>Tags：breadth-first-search | depth-first-search | tree</li><li>描述：给定一个二叉树，检查它是否是镜像对称的。</li><li>例子：</li></ul></blockquote><pre><code>对称：    1   / \  2   2 / \ / \3  4 4  3不对称：    1   / \  2   2   \   \   3    3</code></pre><h4 id="2-个人Code-6"><a href="#2-个人Code-6" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=101 lang=cpp * * [101] 对称二叉树 *//** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    bool isSymmetric(TreeNode* root) {        if(!root) return true;        queue&lt;TreeNode*&gt; nodes_buffer;        vector&lt;TreeNode*&gt; nodes_currentLevel;        TreeNode* node;        nodes_buffer.push(root);        while(!nodes_buffer.empty())        {            int buffer_size = nodes_buffer.size();            for(int i=0; i&lt;buffer_size; i++)            {                node = nodes_buffer.front();                nodes_buffer.pop();                nodes_currentLevel.push_back(node);                if( node )                {                    nodes_buffer.push(node-&gt;left);                    nodes_buffer.push(node-&gt;right);                }            }            if(nodes_currentLevel.size() != 1)            {                int nodesNum = nodes_currentLevel.size();                for(int i=0; i&lt;nodesNum/2; i++)                {                    if(!nodes_currentLevel[i] &amp;&amp; !nodes_currentLevel[nodesNum-1-i])                        continue;                    if( (!nodes_currentLevel[i]&amp;&amp;nodes_currentLevel[nodesNum-1-i]) || \                        (nodes_currentLevel[i]&amp;&amp;!nodes_currentLevel[nodesNum-1-i]) )                        return false;                    if(nodes_currentLevel[i]-&gt;val != nodes_currentLevel[nodesNum-1-i]-&gt;val)                        return false;                }            }            nodes_currentLevel.clear();        }        return true;    }};</code></pre><blockquote><ul><li>思路：缓存nodes_currentLevel为树的每层节点，检查每层节点是否对称，树对称当且仅当所有层都对称，否则返回不对称。</li></ul></blockquote><h4 id="3-best-solution-1"><a href="#3-best-solution-1" class="headerlink" title="(3) best solution"></a>(3) best solution</h4><pre><code class="lang-cpp">class Solution {public:    bool isSymmetric(TreeNode* root) {        if (root == NULL)            return true;        return checkSymmetric(root-&gt;left, root-&gt;right);    }    //check the two nodes in symmetric position    bool checkSymmetric(TreeNode *leftSymmetricNode, TreeNode *rightSymmetricNode)    {        if (leftSymmetricNode == NULL &amp;&amp; rightSymmetricNode == NULL)            return true;        if (leftSymmetricNode == NULL || rightSymmetricNode == NULL)            return false;        if (leftSymmetricNode-&gt;val == rightSymmetricNode-&gt;val)            return checkSymmetric(leftSymmetricNode-&gt;left, rightSymmetricNode-&gt;right) &amp;&amp; checkSymmetric(leftSymmetricNode-&gt;right, rightSymmetricNode-&gt;left);        return false;    }};</code></pre><blockquote><ul><li>思路：<strong>递归调用，好思路！内置函数checkSymmetric，递归调用。</strong>重点在于<code>return checkSymmetric(leftSymmetricNode-&gt;left, rightSymmetricNode-&gt;right) &amp;&amp; checkSymmetric(leftSymmetricNode-&gt;right, rightSymmetricNode-&gt;left)</code>。自己体会。。。</li></ul></blockquote><h3 id="Q21"><a href="#Q21" class="headerlink" title="Q21"></a>Q21</h3><h4 id="1-题目信息-6"><a href="#1-题目信息-6" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：二叉树的最大深度</li><li>编号&amp;难度：[104]，easy</li><li>Tags：depth-first-search | tree</li><li>描述：给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。</li><li>例子：</li></ul></blockquote><pre><code>最大深度：3   3   / \  9  20    /  \   15   7</code></pre><h4 id="2-个人Code-7"><a href="#2-个人Code-7" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode.cn id=104 lang=cpp * * [104] 二叉树的最大深度 *//** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public:    int maxDepth(TreeNode* root) {         if(root == NULL)            return 0;        else        {            int left_height = maxDepth(root-&gt;left);            int right_height = maxDepth(root-&gt;right);            return 1 + ((left_height&gt;right_height)?left_height:right_height);        }    }};</code></pre><blockquote><ul><li>思路：《数据结构与算法分析-C语言描述》有，思路简单易懂。。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eajack LeetCode Notes- Day2</title>
      <link href="/2019/06/06/Eajack%20LeetCode%20Notes-%20Day2/"/>
      <url>/2019/06/06/Eajack%20LeetCode%20Notes-%20Day2/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目解答"><a href="#1-题目解答" class="headerlink" title="1. 题目解答"></a>1. 题目解答</h2><h3 id="Q6"><a href="#Q6" class="headerlink" title="Q6"></a>Q6</h3><h4 id="1-题目信息"><a href="#1-题目信息" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Valid Parentheses</li><li>编号&amp;难度：[20]，easy</li><li>Tags：stack | string</li><li>描述：Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid.<br>An input string is valid if:<br>(1) Open brackets must be closed by the same type of brackets.<br>(2) Open brackets must be closed in the correct order.<br>Note that an empty string is also considered valid.</li><li>例子：</li></ul></blockquote><pre><code>Input: &quot;()&quot;Output: trueInput: &quot;()[]{}&quot;Output: trueInput: &quot;(]&quot;Output: falseInput: &quot;([)]&quot;Output: false</code></pre><h4 id="2-个人Code"><a href="#2-个人Code" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=20 lang=cpp * * [20] Valid Parentheses */class Solution {public:    bool isValid(string s) {        unordered_map&lt;char, char&gt; m = {            {&#39;(&#39;,&#39;)&#39;}, {&#39;[&#39;,&#39;]&#39;},{&#39;{&#39;,&#39;}&#39;}        };        vector&lt;char&gt; stack;        char ch;        for(int i=0; i&lt;s.size(); i++)        {            if(s[i] == &#39;(&#39; || s[i] == &#39;[&#39; || s[i] == &#39;{&#39;)            {                stack.push_back(s[i]);            }            else            {                if(stack.size() != 0)                {                    ch = stack.back();                    stack.pop_back();                    if(s[i] != m[ch])                    {                        return false;                    }                }                else                {                    return false;                }            }        }        return stack.empty();    }};</code></pre><blockquote><ul><li>思路：这题目在《数据结构与算法分析-C语言描述》中的“栈的应用”章节有提及。<strong>思路：遍历所有字符，碰到左边符A（包括：(、{、[），push入栈；碰到右边符号B（包括：)、}、]），则pop出栈中元素E，若E不是B对应的右边符，return false，否则继续遍历。当便利完成，检查是否空栈，空栈则返回true，否则返回false。</strong></li></ul></blockquote><h4 id="3-best-solution"><a href="#3-best-solution" class="headerlink" title="(3) best solution"></a>(3) best solution</h4><pre><code class="lang-cpp">/*Repetitive code but I guess this is clean, and easy to understand. This solution also accepts (and ignores) any characters other than parenthesis in the string. Hence, it can be used to check if the parenthesis matches in an equation for example.*/#include &lt;stack&gt;class Solution {public:    bool isValid(string s) {        stack&lt;char&gt; paren;        for (char&amp; c : s) {            switch (c) {                case &#39;(&#39;:                 case &#39;{&#39;:                 case &#39;[&#39;: paren.push(c); break;                case &#39;)&#39;: if (paren.empty() || paren.top()!=&#39;(&#39;) return false; else paren.pop(); break;                case &#39;}&#39;: if (paren.empty() || paren.top()!=&#39;{&#39;) return false; else paren.pop(); break;                case &#39;]&#39;: if (paren.empty() || paren.top()!=&#39;[&#39;) return false; else paren.pop(); break;                default: ; // pass            }        }        return paren.empty() ;    }};</code></pre><blockquote><ul><li>思路：思路其实一致的，<strong>需要学习的点：case判断char字符；写得真优雅！排版太好看了！</strong></li></ul></blockquote><h3 id="Q7"><a href="#Q7" class="headerlink" title="Q7"></a>Q7</h3><h4 id="1-题目信息-1"><a href="#1-题目信息-1" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Merge Two Sorted Lists</li><li>编号&amp;难度：[21]，easy</li><li>Tags：linked-list</li><li>描述：Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</li><li>例子：</li></ul></blockquote><pre><code>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre><h4 id="2-个人Code-1"><a href="#2-个人Code-1" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=21 lang=cpp * * [21] Merge Two Sorted Lists *//** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {        //0-        if(l1 == nullptr || l2 == nullptr)        {            return (l1 == nullptr)?(l2):(l1);        }        ListNode* l3 = (l1-&gt;val &lt;= l2-&gt;val)?(l1):(l2);        ListNode* l4 = (l1-&gt;val &lt;= l2-&gt;val)?(l2):(l1);        //1-         ListNode *p2 = l4, *temp1 = nullptr, *temp2 = nullptr;        while(p2 != nullptr)        {            int p2_now_val = p2-&gt;val;            bool allPass_flag = true;            ListNode *p1_now = l3;            while(p1_now != nullptr)            {                int p1_next_val = (p1_now-&gt;next == nullptr)?(INT_MAX):(p1_now-&gt;next-&gt;val);                if(p1_now-&gt;val &lt;= p2_now_val &amp;&amp; p2_now_val &lt;= p1_next_val)                {                    temp1 = p1_now-&gt;next;                    p1_now-&gt;next = p2;                    temp2 = p2-&gt;next;                    p2-&gt;next = temp1;                    p2 = temp2;                    allPass_flag = false;                    break;                }                p1_now = p1_now-&gt;next;            }            if(allPass_flag)            {                l4-&gt;next = l3;                return l4;            }        }        return l3;    }};</code></pre><blockquote><ul><li>思路：伪代码如下（并不规范）</li></ul></blockquote><pre><code>BEGIN:    if(l1 == nullptr or l2 == nullptr):        return (l1 == nullptr)?(l2):(l1);    l3 = l1&amp;l2中首元素较小者; l4 = l1&amp;l2中首元素较大者;    for l4node in l4_nodes:        val_current = l4node-&gt;val;        val_next = next_node-&gt;val;        for l3node in l3_nodes:            val_l3node_now = l3node-&gt;val;            if(val_current &lt;= val_l3node_now &lt;= val_next):                insert l3node between l4node &amp; next_nodeEND</code></pre><h4 id="3-best-solution-1"><a href="#3-best-solution-1" class="headerlink" title="(3) best solution"></a>(3) best solution</h4><pre><code class="lang-cpp">/*C++The first line ensures that a is at least as good a list head as b, by swapping them if that’s not already the case. The second line merges the remaining lists behind a.*/ListNode* mergeTwoLists(ListNode* a, ListNode* b) {    if (!a || b &amp;&amp; a-&gt;val &gt; b-&gt;val) swap(a, b);    if (a) a-&gt;next = mergeTwoLists(a-&gt;next, b);    return a;}/*CSame solution, I just have to replace C++&#39;s swap. I’m not sure whether evaluation order is standardized, but it worked and got accepted this way.*/struct ListNode* mergeTwoLists(struct ListNode* a, struct ListNode* b) {    if (!a || b &amp;&amp; a-&gt;val &gt; b-&gt;val) a += b - (b = a);    if (a) a-&gt;next = mergeTwoLists(a-&gt;next, b);    return a;}</code></pre><blockquote><ul><li>思路：这个思路类似归并排序（merge-sort），但真的巧妙了，慢慢学习吧。。先记住。</li></ul></blockquote><h3 id="Q8"><a href="#Q8" class="headerlink" title="Q8"></a>Q8</h3><h4 id="1-题目信息-2"><a href="#1-题目信息-2" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Remove Duplicates from Sorted Array</li><li>编号&amp;难度：[26]，easy</li><li>Tags：array | two-pointers</li><li>描述：Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.<br>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</li><li>例子：</li></ul></blockquote><pre><code>Given nums = [1,1,2],Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.It doesn&#39;t matter what you leave beyond the returned length.Given nums = [0,0,1,1,1,2,2,3,3,4],Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.It doesn&#39;t matter what values are set beyond the returned length.</code></pre><h4 id="2-个人Code-2"><a href="#2-个人Code-2" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=26 lang=cpp * * [26] Remove Duplicates from Sorted Array */class Solution {public:    int removeDuplicates(vector&lt;int&gt;&amp; nums) {        //0- 0&amp;1 check        if(nums.empty() || nums.size() == 1)        {            return nums.size();        }        //1- begin        int i = 0, j = 1, cnt = 0;        while(i &lt; nums.size()-1 &amp;&amp; j &lt;= nums.size()-1)        {            while (j &lt;= nums.size()-1)            {                if(nums[j] == nums[i])                {                    j++;                }                else                {                    nums[cnt] = nums[i];                    i = j;                    j = i+1;                    cnt++;                    break;                }            }        }        nums[cnt] = nums[i];        return (cnt+1);    }};</code></pre><blockquote><ul><li>思路：two-pointers思想，双指针</li></ul></blockquote><pre><code>BEGIN    if(nums 为空 or nums 长度为1):        return nums.size()    int i=0, j=1 //双指针    int cnt=0 //更新后数组索引    while(i &lt; nums.size()-1 and j &lt;= nums.size()-1):#保证双指针均不越界        while (j &lt;= nums.size()-1):    #保证j指针不越界，以j指针遍历            if(nums[j] == nums[i]):                j++            else:                nums[cnt]更新，指针i=j, j=i+1, 索引cnt++                break    nums[cnt] = nums[i];    return(cnt+1)END</code></pre><h3 id="Q9"><a href="#Q9" class="headerlink" title="Q9"></a>Q9</h3><h4 id="1-题目信息-3"><a href="#1-题目信息-3" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Remove Element</li><li>编号&amp;难度：[27]，easy</li><li>Tags：array | two-pointers</li><li>描述：Given an array nums and a value val, remove all instances of that value in-place and return the new length.<br>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.<br>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</li><li>例子：</li></ul></blockquote><pre><code>Given nums = [3,2,2,3], val = 3,Your function should return length = 2, with the first two elements of nums being 2.It doesn&#39;t matter what you leave beyond the returned length.Given nums = [0,1,2,2,3,0,4,2], val = 2,Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.Note that the order of those five elements can be arbitrary.It doesn&#39;t matter what values are set beyond the returned length.</code></pre><h4 id="2-个人Code-3"><a href="#2-个人Code-3" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=27 lang=cpp * * [27] Remove Element */class Solution {public:    int removeElement(vector&lt;int&gt;&amp; nums, int val) {        int new_index = 0;        for(int i=0; i&lt;nums.size(); i++)        {            if(nums[i] != val)            {                nums[new_index] = nums[i];                new_index++;            }        }        return new_index;    }};</code></pre><blockquote><ul><li>思路：two-pointers思想，双指针。思路其实很简单，然而最终还是要看答案。。<strong> 即初始化new_index = 0，遍历输入数组，若当前值 != val，则nums[new_index] = nums[i]，new_index++ </strong></li></ul></blockquote><h3 id="Q10"><a href="#Q10" class="headerlink" title="Q10"></a>Q10</h3><h4 id="1-题目信息-4"><a href="#1-题目信息-4" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Implement strStr</li><li>编号&amp;难度：[27]，easy</li><li>Tags：string | two-pointers</li><li>描述：Implement strStr().<br>Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</li><li>例子：</li></ul></blockquote><pre><code>Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;Output: 2Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;Output: -1For the purpose of this problem, we will return 0 when needle is an empty string</code></pre><h4 id="2-个人Code-4"><a href="#2-个人Code-4" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=28 lang=cpp * * [28] Implement strStr() */class Solution {public:    int strStr(string haystack, string needle) {        if(needle.size() == 0)        {            return 0;        }        int find_index = -1;        for(int i=0; i&lt;haystack.size(); i++)        {            int same_cnt = 0;            if(haystack[i] == needle[0])            {                find_index = i;                same_cnt++;                // haystack 不包含 needle                if(haystack.size()-i+1 &lt; needle.size())                {                    return -1;                }                // haystack 包含 needle长度，遍历                for(int j=i+1, k=1; k&lt;needle.size(); j++, k++)                {                    if(haystack[j] == needle[k])                    {                        same_cnt++;                    }                }                if(same_cnt == needle.size())                {                    return find_index;                }            }        }        return -1;    }};</code></pre><blockquote><ul><li>思路：首先，遍历haystack字符串，寻找和needle字符串首个char相同的位置i， 记录find_index = i；然后，判断剩余的haystack字符串能否覆盖needle字符串，若不能，则return false，否则遍历同时遍历 haystack字符串 &amp; needle字符串，计算相同个数same_cnt；最后，判断same_cnt == needle.size()，return find_index，否则return -1。</li></ul></blockquote><h4 id="3-best-solution-2"><a href="#3-best-solution-2" class="headerlink" title="(3) best solution"></a>(3) best solution</h4><pre><code class="lang-cpp">// bruteclass Solution {public:    int strStr(string haystack, string needle) {        int m = haystack.size(), n = needle.size();        for (int i = 0; i &lt;= m - n; i++) {            int j = 0;            for (; j &lt; n; j++) {                if (haystack[i + j] != needle[j]) {                    break;                }            }            if (j == n) {                return i;            }        }        return -1;    }};//KMPclass Solution {public:    int strStr(string haystack, string needle) {        int m = haystack.size(), n = needle.size();        if (!n) {            return 0;        }        vector&lt;int&gt; lps = kmpProcess(needle);        for (int i = 0, j = 0; i &lt; m;) {            if (haystack[i] == needle[j]) {                 i++, j++;            }            if (j == n) {                return i - j;            }            if (i &lt; m &amp;&amp; haystack[i] != needle[j]) {                j ? j = lps[j - 1] : i++;            }        }        return -1;    }private:    vector&lt;int&gt; kmpProcess(string needle) {        int n = needle.size();        vector&lt;int&gt; lps(n, 0);        for (int i = 1, len = 0; i &lt; n;) {            if (needle[i] == needle[len]) {                lps[i++] = ++len;            } else if (len) {                len = lps[len - 1];            } else {                lps[i++] = 0;            }        }        return lps;    }};</code></pre><blockquote><ul><li>思路：brute暴力搜索类似我的解决方案，但更简略；KMP是有名的字符串搜索算法；</li></ul></blockquote><h3 id="Q11"><a href="#Q11" class="headerlink" title="Q11"></a>Q11</h3><h4 id="1-题目信息-5"><a href="#1-题目信息-5" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Search Insert Position</li><li>编号&amp;难度：[35]，easy</li><li>Tags：array | binary-search</li><li>描述：Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.<br>You may assume no duplicates in the array.</li><li>例子：</li></ul></blockquote><pre><code>Input: [1,3,5,6], 5Output: 2Input: [1,3,5,6], 2Output: 1Input: [1,3,5,6], 7Output: 4Input: [1,3,5,6], 0Output: 0</code></pre><h4 id="2-个人Code-5"><a href="#2-个人Code-5" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=35 lang=cpp * * [35] Search Insert Position */class Solution {public:    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {        int low = 0, high = nums.size()-1, mid = 0;        while(low &lt;= high)        {            mid = (low+high)/2;            if(nums[mid] &lt; target)            {                low = mid+1;            }            else if(nums[mid] &gt; target)            {                high = mid-1;            }            else            {                return mid;            }        }        //not found        return (low&gt;high)?(low):(high);    }};</code></pre><blockquote><ul><li>思路：这题就是binary-search变种，找返回位置，否则返回low &amp; high较大者。</li></ul></blockquote><h3 id="Q12"><a href="#Q12" class="headerlink" title="Q12"></a>Q12</h3><h4 id="1-题目信息-6"><a href="#1-题目信息-6" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Maximum Subarray</li><li>编号&amp;难度：[53]，easy</li><li>Tags：array | divide-and-conquer | dynamic-programming</li><li>描述：Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</li><li>例子：</li></ul></blockquote><pre><code>Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6.</code></pre><h4 id="2-个人Code-6"><a href="#2-个人Code-6" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=53 lang=cpp * * [53] Maximum Subarray */class Solution {public:    int maxSubArray(vector&lt;int&gt;&amp; nums) {        int thisSum, maxSum, i;        thisSum = maxSum = 0;        for(int i=0; i&lt;nums.size(); i++)        {            thisSum += nums[i];            if(thisSum &gt; maxSum)            {                maxSum = thisSum;            }            else if(thisSum &lt; 0)            {                thisSum = 0;            }        }        //all are minus        if(maxSum == 0)        {            maxSum = nums[0];            for(int i=1; i&lt;nums.size(); i++)            {                maxSum = (nums[i]&gt;maxSum)?(nums[i]):(maxSum);            }        }        return maxSum;    }};</code></pre><blockquote><ul><li>思路：最大子序列和，在《数据结构与算法分析-C语言描述》中有，此处也是用的书中代码改一下。思路很巧妙：<strong>除了全负数序列外，其他序列的最大子序列和一定大于等于0</strong>，因此设置maxSum = 0 ，遍历N次逐项累加thisSum，若thisSum &gt; maxSum，则更新maxSum，若thisSum &lt; 0，则令thisSum = 0继续遍历。遍历完后，判断maxSum == 0，若是则证明为全负数序列，取序列最大值return；否则return 原来的maxSum（&gt; 0）。<strong>best solution可以用分治，这里就不说了。。</strong></li></ul></blockquote><h3 id="Q13"><a href="#Q13" class="headerlink" title="Q13"></a>Q13</h3><h4 id="1-题目信息-7"><a href="#1-题目信息-7" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Length of Last Word</li><li>编号&amp;难度：[58]，easy</li><li>Tags：string</li><li>描述：Given a string s consists of upper/lower-case alphabets and empty space characters ‘ ‘, return the length of last word in the string.<br>If the last word does not exist, return 0.<br>Note: A word is defined as a character sequence consists of non-space characters only.</li><li>例子：</li></ul></blockquote><pre><code>Input: &quot;Hello World&quot;Output: 5</code></pre><h4 id="2-个人Code-7"><a href="#2-个人Code-7" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=58 lang=cpp * * [58] Length of Last Word */class Solution {public:    int lengthOfLastWord(string s) {        int last_blank_index = -1, word_len = 0;        int s_begin = 0, s_end = s.size()-1;        //1- cut head &amp; tail blanks(s.strip())        while(s_begin &lt; s.size() &amp;&amp; s[s_begin] == &#39; &#39;)        {            s_begin++;        }        while(s_end &gt;= 0 &amp;&amp; s[s_end] == &#39; &#39;)        {            s_end--;        }        //2- check if s.strip() == &#39;&#39;        if(s_begin == s.size() &amp;&amp; s_end == -1)        {            return 0;        }        //3- begin        for(int i=s_begin; i&lt;s_end+1; i++)//get the last_blank_index        {            if(s[i] == &#39; &#39;)            {                last_blank_index = i;            }        }        if(last_blank_index != -1)//has blank inside s.strip()        {            for(int i=last_blank_index+1; i&lt;s_end+1; i++)            {                word_len++;            }        }        else//no blank inside s.strip() &amp;&amp; s.strip() != &#39;&#39;        {            word_len = s_end-s_begin+1;        }        return word_len;    }};</code></pre><blockquote><ul><li>思路：1- s.strip()（类似python函数）；2- 判断s.strip() == ‘’，是则返回0；3-开始遍历获得最后一个空格，对应的后面word，计算len。</li></ul></blockquote><h4 id="3-best-solution-3"><a href="#3-best-solution-3" class="headerlink" title="(3) best solution"></a>(3) best solution</h4><pre><code class="lang-cpp">/* Well, the basic idea is very simple. Start from the tail of s and move backwards to find the first non-space character. Then from this character, move backwards and count the number of non-space characters until we pass over the head of s or meet a space character. The count will then be the length of the last word. *///从尾部开始找第一个非空格字符，开始len++，直到倒退找到第一个空格字符class Solution {public:    int lengthOfLastWord(string s) {         int len = 0, tail = s.length() - 1;        while (tail &gt;= 0 &amp;&amp; s[tail] == &#39; &#39;) tail--;        while (tail &gt;= 0 &amp;&amp; s[tail] != &#39; &#39;) {            len++;            tail--;        }        return len;    }};</code></pre><blockquote><ul><li>思路：如注释。。<strong>逆向思维，这才是好解答。</strong></li></ul></blockquote><h3 id="Q14"><a href="#Q14" class="headerlink" title="Q14"></a>Q14</h3><h4 id="1-题目信息-8"><a href="#1-题目信息-8" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Add Binary</li><li>编号&amp;难度：[67]，easy</li><li>Tags：math | string</li><li>描述：Given two binary strings, return their sum (also a binary string).<br>The input strings are both non-empty and contains only characters 1 or 0.</li><li>例子：</li></ul></blockquote><pre><code>Input: a = &quot;11&quot;, b = &quot;1&quot;Output: &quot;100&quot;Input: a = &quot;1010&quot;, b = &quot;1011&quot;Output: &quot;10101&quot;</code></pre><h4 id="2-个人Code-8"><a href="#2-个人Code-8" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=67 lang=cpp * * [67] Add Binary */class Solution {public:    string addBinary(string a, string b) {        string ab_sum, ab_sum_return;        char sum_now = &#39;0&#39;, carry = &#39;0&#39;;        bool a_bool, b_bool, carry_bool;        //1- 补0等长 + 1        int a_len = a.size(), b_len = b.size();        if(a_len != b_len)        {            int extraLen = abs(a_len-b_len)+1;            bool aorb = (a_len &lt; b_len);            for(int i=1; i&lt;=extraLen; i++)            {                if(aorb)                {                    a = &#39;0&#39; + a;                    if(i==1) b = &#39;0&#39; + b;                }                else                {                    b = &#39;0&#39; + b;                    if(i==1) a = &#39;0&#39; + a;                }            }        }        //2- begin        for(int i=a.size()-1; i&gt;=0; i--)        {            a_bool = (a[i] == &#39;1&#39;)?(true):(false);            b_bool = (b[i] == &#39;1&#39;)?(true):(false);            carry_bool = (carry == &#39;1&#39;)?(true):(false);            //真值表            sum_now = ( ((!a_bool)&amp;&amp;(!b_bool)&amp;&amp;(carry_bool)) || ((!a_bool)&amp;&amp;(b_bool)&amp;&amp;(!carry_bool)) || \                ((a_bool)&amp;&amp;(!b_bool)&amp;&amp;(!carry_bool)) || ((a_bool)&amp;&amp;(b_bool)&amp;&amp;(carry_bool)) )? (&#39;1&#39;):(&#39;0&#39;);            carry = ( ((!a_bool)&amp;&amp;(b_bool)&amp;&amp;(carry_bool)) || ((a_bool)&amp;&amp;(!b_bool)&amp;&amp;(carry_bool)) || \                ((a_bool)&amp;&amp;(b_bool)&amp;&amp;(!carry_bool)) || ((a_bool)&amp;&amp;(b_bool)&amp;&amp;(carry_bool)) )? (&#39;1&#39;):(&#39;0&#39;);            ab_sum = sum_now + ab_sum;        }        ab_sum = carry + ab_sum;        //3- ab_sum.lstrip()        int first_notZero_index = 0;        while(first_notZero_index &lt; ab_sum.size()-1 &amp;&amp; ab_sum[first_notZero_index] == &#39;0&#39;)        {            first_notZero_index++;        }        if (first_notZero_index == -1)        {            first_notZero_index = 1;        }        for(int i=first_notZero_index; i&lt;ab_sum.size(); i++)        {            ab_sum_return += ab_sum[i];        }        return ab_sum_return;    }};</code></pre><blockquote><ul><li>思路：二进制加法，个人代码采用典型的<strong>数字电路的真值表解法</strong>，我觉得这做法比best solution好。代码不难懂，需要一些基本数电基础即可。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eajack LeetCode Notes- Day1</title>
      <link href="/2019/05/31/Eajack%20LeetCode%20Notes-%20Day1/"/>
      <url>/2019/05/31/Eajack%20LeetCode%20Notes-%20Day1/</url>
      
        <content type="html"><![CDATA[<h2 id="1-题目解答"><a href="#1-题目解答" class="headerlink" title="1. 题目解答"></a>1. 题目解答</h2><h3 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h3><h4 id="1-题目信息"><a href="#1-题目信息" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Two Sum</li><li>编号&amp;难度：[1]，easy</li><li>Tags：array，hash-table</li><li>描述：Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice.</li><li>例子：Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</li></ul></blockquote><h4 id="2-个人Code"><a href="#2-个人Code" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=1 lang=cpp * * [1] Two Sum *///O(N^2)class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;int&gt; indices;        for(int i=0; i&lt;nums.size(); i++)        {            int find_flag = 0;            for(int j=i+1; j&lt;nums.size(); j++)            {                if(nums[i]+nums[j] == target)                {                    find_flag = 1;                    indices.push_back(i);                    indices.push_back(j);                    break;                }            }            if(find_flag)            {                break;            }        }        return indices;    }};</code></pre><blockquote><ul><li>思路：相当简单，O(N^2)，由于题目限定只考虑2个不是同1个元素的sum，因此i、j遍历</li></ul></blockquote><h4 id="3-best-solution"><a href="#3-best-solution" class="headerlink" title="(3) best solution"></a>(3) best solution</h4><pre><code class="lang-cpp">/* The basic idea is to maintain a hash table for each element num in nums, using num as key and its index (0-based) as value. For each num, search for target - num in the hash table. If it is found and is not the same element as num, then we are done.The code is as follows. Note that each time before we add num to mp, we search for target - num first and so we will not hit the same element. *///O(N)class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        unordered_map&lt;int, int&gt; indices;        for (int i = 0; i &lt; nums.size(); i++) {            if (indices.find(target - nums[i]) != indices.end()) {                return {indices[target - nums[i]], i};            }            indices[nums[i]] = i;        }        return {};    }};</code></pre><blockquote><ul><li>思路：如注释所示，引入<code>unordered_map</code>（<strong>注意：LeetCode平台不能用map（也看情况，目前碰到的题目不能用），可以用标准库内置的unordered_map</strong>），即哈希表。如果map中没有另一半元素，则添加<code>key =nums[i] , value = i</code>，此处<code>value</code>没用。O(N)。</li></ul></blockquote><h3 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h3><h4 id="1-题目信息-1"><a href="#1-题目信息-1" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Reverse Integer</li><li>编号&amp;难度：[7]，easy</li><li>Tags：math</li><li>描述：Given a 32-bit signed integer, reverse digits of an integer.</li><li>例子：123 =&gt; 321，-123 =&gt; -321，120 =&gt; 21</li><li>备注：Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</li></ul></blockquote><h4 id="2-个人Code-1"><a href="#2-个人Code-1" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><p>这道题没AC，弄太久了…直接看solution了</p><pre><code class="lang-cpp">/* * @lc app=leetcode id=7 lang=cpp * * [7] Reverse Integer *///failed in 2019/5/30// using solution code ACclass Solution {public:    int reverse(int x) {        long result = 0;        while(x != 0)        {            result = result*10 + x%10;//key code!            x /= 10;        }        return ((result &gt; INT_MAX || result &lt; INT_MIN)?(0):(result));};};</code></pre><blockquote><ul><li>思路：可以说代码相当巧妙。。key code =&gt; <code>result = result*10 + x%10</code>，先记住吧。。还有另一种思路push &amp; pop，类似。</li></ul></blockquote><pre><code class="lang-cpp">//pop operation:pop = x % 10;x /= 10;//push operation:temp = rev * 10 + pop;rev = temp;</code></pre><h3 id="Q3"><a href="#Q3" class="headerlink" title="Q3"></a>Q3</h3><h4 id="1-题目信息-2"><a href="#1-题目信息-2" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Palindrome Number</li><li>编号&amp;难度：[9]，easy</li><li>Tags：math</li><li>描述：Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</li><li>备注：Coud you solve it without converting the integer to a string?</li></ul></blockquote><h4 id="2-个人Code-2"><a href="#2-个人Code-2" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=9 lang=cpp * * [9] Palindrome Number */class Solution {public:    bool isPalindrome(int x) {        if(x &lt; 0)        {            return false;        }        else if(x &gt;= 0 &amp;&amp; x &lt; 10)        {            return true;        }        else        {            //reverse_x            // using code in Problem[7]            long reverse_x = 0, x_buffer = x;            while(x != 0)            {                reverse_x = reverse_x*10 + x%10;                x /= 10;            }            if(x_buffer == reverse_x)            {                return true;            }            else            {                return false;            }        }    }};</code></pre><blockquote><ul><li>思路：相当简单，直接沿用Q2代码，只用考虑 <code>x &gt;= 10</code>数字（Q2代码）</li></ul></blockquote><h4 id="3-best-solution-1"><a href="#3-best-solution-1" class="headerlink" title="(3) best solution"></a>(3) best solution</h4><pre><code class="lang-cpp">class Solution {public:    bool isPalindrome(int x) {        if(x&lt;0|| (x!=0 &amp;&amp;x%10==0)) return false;        int sum=0;        while(x&gt;sum)        {            sum = sum*10+x%10;            x = x/10;        }        return (x==sum)||(x==sum/10);    }};</code></pre><blockquote><ul><li>思路：差别不大，也是先剔除明显的。最后对比，因为sum省去求后连续0的和，因此补上 <code>(x==sum/10)</code>。</li></ul></blockquote><h3 id="Q4"><a href="#Q4" class="headerlink" title="Q4"></a>Q4</h3><h4 id="1-题目信息-3"><a href="#1-题目信息-3" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Roman to Integer</li><li>编号&amp;难度：[13]，easy</li><li>Tags：math，string</li><li>描述：Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:（1） I can be placed before V (5) and X (10) to make 4 and 9. （2）X can be placed before L (50) and C (100) to make 40 and 90. （3）C can be placed before D (500) and M (1000) to make 400 and 900.</li><li>备注：Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</li></ul></blockquote><pre><code>Symbol       ValueI             1V             5X             10L             50C             100D             500M             1000</code></pre><h4 id="2-个人Code-3"><a href="#2-个人Code-3" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=13 lang=cpp * * [13] Roman to Integer */class Solution {public:    int romanToInt(string s) {        int result = 0;        for(int i=0; i&lt;s.size(); i++)        {            if(s[i] == &#39;I&#39;)            {                if(s[i+1] != &#39;V&#39; &amp;&amp; s[i+1] != &#39;X&#39;)                {                     result += 1;                }                else                {                    result += ( (s[i+1] == &#39;V&#39;)?(4):(9) );                    i++;                }            }            else if (s[i] == &#39;X&#39;)            {                if(s[i+1] != &#39;L&#39; &amp;&amp; s[i+1] != &#39;C&#39;)                {                     result += 10;                }                else                {                    result += ( (s[i+1] == &#39;L&#39;)?(40):(90) );                    i++;                }            }            else if(s[i] == &#39;C&#39;)            {                if(s[i+1] != &#39;D&#39; &amp;&amp; s[i+1] != &#39;M&#39;)                {                     result += 100;                }                else                {                    result += ( (s[i+1] == &#39;D&#39;)?(400):(900) );                    i++;                }            }            else if(s[i] == &#39;V&#39; || s[i] == &#39;L&#39;)            {                result += ( (s[i] == &#39;V&#39;)?(5):(50) );            }            else            {                result += ( (s[i] == &#39;D&#39;)?(500):(1000) );            }        }        return result;    }};</code></pre><blockquote><ul><li>思路：相当简单，先判断I、X、C，之后判断其他</li></ul></blockquote><h4 id="3-best-solution-2"><a href="#3-best-solution-2" class="headerlink" title="(3) best solution"></a>(3) best solution</h4><pre><code class="lang-cpp">// Points://  1- unordered_map cpp标准库，可以直接用，乱序map，用法与map一致//  2- right =&gt; left, easy to judge when to add or substractclass Solution {public:    int romanToInt(string s) {        if (s.empty()) { return 0; }        unordered_map&lt;char, int&gt; mp { {&#39;I&#39;, 1}, {&#39;V&#39;, 5}, {&#39;X&#39;, 10}, {&#39;L&#39;, 50}, {&#39;C&#39;, 100}, {&#39;D&#39;, 500}, {&#39;M&#39;, 1000} };        int sum = mp[s.back()];        for (int i = s.size() - 2; i &gt;= 0; --i) {            sum += mp[s[i]] &gt;= mp[s[i + 1]] ? mp[s[i]] : -mp[s[i]];        }        return sum;    }};</code></pre><blockquote><ul><li>思路：差别不大，用了 <code>unordered_map</code>（记住！）</li></ul></blockquote><h3 id="Q5"><a href="#Q5" class="headerlink" title="Q5"></a>Q5</h3><h4 id="1-题目信息-4"><a href="#1-题目信息-4" class="headerlink" title="(1) 题目信息"></a>(1) 题目信息</h4><blockquote><ul><li>标题：Longest Common Prefix</li><li>编号&amp;难度：[14]，easy</li><li>Tags：string</li><li>描述：Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”.</li><li>例子：</li></ul></blockquote><pre><code>Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]Output: &quot;fl&quot;Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]Output: &quot;&quot;Explanation: There is no common prefix among the input strings.</code></pre><blockquote><ul><li>备注：All given inputs are in lowercase letters a-z.</li></ul></blockquote><h4 id="2-个人Code-4"><a href="#2-个人Code-4" class="headerlink" title="(2) 个人Code"></a>(2) 个人Code</h4><pre><code class="lang-cpp">/* * @lc app=leetcode id=14 lang=cpp * * [14] Longest Common Prefix *///Attention://  1- string内部是char字符组成//  2- string =&gt; char： const char* p_char = p_string.c_str()class Solution {public:    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {        int cnt = 0;        string prefix = &quot;&quot;;        char s_i;        //空strs        if(strs.size() == 0)        {            return prefix;        }        //begin        while(1)        {            if(cnt &lt; strs[0].size())            {                s_i = strs[0][cnt];            }            else            {                return prefix;            }            for(int i=0; i&lt;strs.size(); i++)            {                if(cnt &gt; strs[i].size() || strs[i][cnt] != s_i)                {                    return prefix;                }            }            prefix += s_i;            cnt++;        }    }};</code></pre><blockquote><ul><li>思路：由于是前缀，因此所有string等齐扫描即可，字符初始化为strs[0][cnt]，碰到 <code>越界 or 不等</code> 即可return。</li></ul></blockquote><h2 id="2-收获-amp-总结"><a href="#2-收获-amp-总结" class="headerlink" title="2. 收获&amp;总结"></a>2. 收获&amp;总结</h2><p>最大的不足就是：<strong>C++不熟练！！！写代码太慢了！！！</strong>，一道题能弄个半个钟 ~ 1个钟，我真的佛了自己。。太垃圾了。。。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据结构与算法分析-C语言描述》C++实现</title>
      <link href="/2019/05/28/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-C%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E3%80%8BC++%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/05/28/%E3%80%8A%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90-C%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0%E3%80%8BC++%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="data-structures-and-algorithm-analysis-in-C"><a href="#data-structures-and-algorithm-analysis-in-C" class="headerlink" title="data structures and algorithm analysis in C"></a>data structures and algorithm analysis in C</h1><h1 id="《数据结构与算法分析——C语言描述》"><a href="#《数据结构与算法分析——C语言描述》" class="headerlink" title="《数据结构与算法分析——C语言描述》"></a>《数据结构与算法分析——C语言描述》</h1><p><div align="center"><img src="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/blob/master/book.jpg"></div><br>GitHub: <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C" target="_blank" rel="noopener">data-structures-and-algorithm-analysis-in-C</a></p><h2 id="1、运行环境"><a href="#1、运行环境" class="headerlink" title="1、运行环境"></a>1、运行环境</h2><blockquote><ul><li>Windows</li><li>VS 2017</li><li>cpp</li></ul></blockquote><h2 id="2、参考资料"><a href="#2、参考资料" class="headerlink" title="2、参考资料"></a>2、参考资料</h2><blockquote><ul><li>《数据结构与算法分析——C语言描述》</li><li>Google</li></ul></blockquote><h2 id="3、代码说明"><a href="#3、代码说明" class="headerlink" title="3、代码说明"></a>3、代码说明</h2><p>cpp代码实现（cpp入门弱鸡，混C/cpp风格），每一章节的文件夹对应1个VS2017 cpp工程。实现进度如下：</p><blockquote><ul><li>实现：Chapter 2 ~ 9</li><li>基本实现：Chapter 10</li><li>未实现：Chapter 11-12、Chapter 4.4-4.5</li></ul></blockquote><p>book章节总结：</p><blockquote><ul><li>Chapter 1：数学基本知识、递归介绍</li><li>Chapter 2：大O分析、大Ω分析、大Θ分析、算法题例子</li><li>Chapter 3：链表、栈、队列</li><li>Chapter 4：基本树结构：二叉树、表达式树、二叉查找树、AVL树、伸展树、B树、树的遍历</li><li>Chapter 5：HashMap哈希表（散列）</li><li>Chapter 6：堆（优先队列）：二叉堆、d-堆、左式堆、斜堆、二项队列（森林forest）</li><li>Chapter 7：排序算法：插入、希尔、堆、归并、快排、桶式排序、基数排序；冒泡、选择</li><li>Chapter 8：并查集（不相交集）</li><li>Chapter 9：图论：拓扑排序、最短路算法（uW-uDAG、W-DAG、nw-DAG）、网络流问题、最小生成树、BFS &amp; DFS、NP问题介绍</li><li>Chapter 10：算法设计技巧：贪心、分治、动态规划、回溯</li><li>Chapter 11：摊还分析（M次总共再M平均），例子：二项队列、斜堆、斐波那契堆、伸展树</li><li>Chapter 12：高级DS：红黑树、treap树、k-d树、AA-树、配对堆、skip list etc.</li></ul></blockquote><p>以下总结已完成代码：</p><h3 id="1-Chapter-2"><a href="#1-Chapter-2" class="headerlink" title="1. Chapter_2"></a>1. <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/tree/master/chapter_2" target="_blank" rel="noopener">Chapter_2</a></h3><blockquote><ul><li>最大子序列和问题（3种算法）</li><li>二分法（binary search）</li><li>欧几里得算法gcd（求最大公因子）</li><li>取幂算法</li></ul></blockquote><h3 id="2-Chapter-3"><a href="#2-Chapter-3" class="headerlink" title="2. Chapter_3"></a>2. <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/tree/master/chapter_3" target="_blank" rel="noopener">Chapter_3</a></h3><h4 id="2-1-链表-linkedList"><a href="#2-1-链表-linkedList" class="headerlink" title="2.1 链表 linkedList"></a>2.1 链表 linkedList</h4><h5 id="2-1-1-链表（单链表-linkedList、双链表-linkedList-double、循环链表-linkedList-circle）（N为链表长度）"><a href="#2-1-1-链表（单链表-linkedList、双链表-linkedList-double、循环链表-linkedList-circle）（N为链表长度）" class="headerlink" title="2.1.1 链表（单链表 linkedList、双链表 linkedList_double、循环链表 linkedList_circle）（N为链表长度）"></a>2.1.1 链表（单链表 linkedList、双链表 linkedList_double、循环链表 linkedList_circle）<strong>（N为链表长度）</strong></h5><h6 id="1-共同功能（具体代码实现不同）"><a href="#1-共同功能（具体代码实现不同）" class="headerlink" title="(1) 共同功能（具体代码实现不同）"></a>(1) 共同功能（具体代码实现不同）</h6><blockquote><ul><li>linkedList produceEmptyList()：<strong>生成空单链表，O(1)</strong></li><li>linkedList produceList(const int A[], int N)：<strong>生成单链表，O(N)</strong></li><li>int isEmptyList(linkedList L)：<strong>判断L是否为空单链表，O(1)</strong></li><li>ptrToNode find_x(int x, linkedList L)：<strong>在单链表L中，查找x值位置（线性遍历，第一个碰到的节点），O(N)</strong></li><li>int getListLength(linkedList L)：<strong>获取单链表L的长度，O(N)</strong></li><li>ptrToNode findPrevious(int x, linkedList L)：<strong>在单链表L中，查找x值前一节点位置（线性遍历，第一个碰到的节点），O(N)</strong></li><li>void delete_x(int x, linkedList L)：<strong>在单链表L中，删除x值对应的节点（线性遍历，第一个碰到的节点），O(1)（不考虑findPrevious子函数复杂度）</strong></li><li>void delete_L(linkedList L)：<strong>删除链表，包括表头，O(N)</strong></li><li>void printList(linkedList L)：<strong>打印链表，O(N)</strong></li><li>ptrToNode insert_x(int x, linkedList L, ptrToNode p)：<strong>insert元素x，在p后面插入x, 返回插入x对应node地址，O(1)</strong><h6 id="2-独立功能：不同类型链表内部存在独立功能函数，此处不一一展示"><a href="#2-独立功能：不同类型链表内部存在独立功能函数，此处不一一展示" class="headerlink" title="(2) 独立功能：不同类型链表内部存在独立功能函数，此处不一一展示"></a>(2) 独立功能：不同类型链表内部存在独立功能函数，此处不一一展示</h6><h5 id="2-1-2-链表应用"><a href="#2-1-2-链表应用" class="headerlink" title="2.1.2 链表应用"></a>2.1.2 链表应用</h5></li><li>int<em> bucketSort(const int A[], int N, int M, bool reverseFlag)：<em>*桶式排序，O(N-M)，N个整数，取值范围为0~M-1</em></em></li><li>int get_digit(int num, int digit)：<strong>radixSort辅助函数，获取num的位digit处值，O(digit)</strong></li><li>void radixSort(int<em> A, int N, bool reverseFlag=false, int M=10)：<em>*基数排序，O(PNM)实现，然而书中是O(P(N-M))…</em></em><h4 id="2-2-栈-stack"><a href="#2-2-栈-stack" class="headerlink" title="2.2 栈 stack"></a>2.2 栈 stack</h4><h5 id="2-2-1-栈-（N为栈元素数量）"><a href="#2-2-1-栈-（N为栈元素数量）" class="headerlink" title="2.2.1 栈 （N为栈元素数量）"></a>2.2.1 栈 <strong>（N为栈元素数量）</strong></h5></li><li>int isEmptyStack(Stack S)：<strong>判断是否为空栈，O(1)</strong></li><li>Stack produceEmptyStack()：<strong>生成空栈，O(1)</strong></li><li>Stack produceStack(const int A[], int N)：<strong>生成栈，O(N)</strong></li><li>void push(int x, Stack S)：<strong>栈push，改变栈内容，O(1)</strong></li><li>void pop(Stack S)：<strong>栈pop，改变栈内容，O(1)</strong></li><li>int top(Stack S)：<strong>返回栈顶元素值，不栈内容，O(1)</strong></li><li>void deleteStack(Stack S)：<strong>删除栈，O(N)</strong></li><li>void printStack(Stack S)：<strong>打印栈，O(N)</strong><h5 id="2-2-2-栈应用"><a href="#2-2-2-栈应用" class="headerlink" title="2.2.2 栈应用"></a>2.2.2 栈应用</h5></li><li>int checkSymbols(string inputText)：<strong>平衡符号检测，编译器检查符号是否成对，O(|inputText|)</strong></li><li>int calculatePostfix(const char postfixExpression_array[], int N)：<strong>计算后缀表达式，O(N)</strong></li><li>char<em> transfer_Infix2Postfix(const char postfixExpression_array[], int N)：<em>*中缀表达式 =&gt; 后缀表达式，O(N)</em></em><h4 id="2-3-队列-queue-（N为队列元素数量）（基于链表）"><a href="#2-3-队列-queue-（N为队列元素数量）（基于链表）" class="headerlink" title="2.3 队列 queue （N为队列元素数量）（基于链表）"></a>2.3 队列 queue <strong>（N为队列元素数量）</strong>（基于链表）</h4></li><li>int isEmpty_queue(queue_header Q)：<strong>判断是否为空队列，O(1)</strong></li><li>int isFull_queue(queue_header Q)：<strong>判断是否为满队列，O(1)</strong></li><li>queue_header createEmptyQueue()：<strong>生成空队列，O(1)</strong></li><li>void deleteQueue(queue_header Q)：<strong>删除队列，O(N)</strong></li><li>void enqueue(int x, queue_header Q)：<strong>尾部入队，O(N)</strong></li><li>int dequeue(queue_header Q)：<strong>头部出队，O(1)</strong></li><li>queue_header createQueue(const int A[], int N)：<strong>生成队列，O(N)</strong></li><li>void print_queue(queue_header Q)：<strong>打印队列，O(N)</strong></li></ul></blockquote><h3 id="3-Chapter-4"><a href="#3-Chapter-4" class="headerlink" title="3. Chapter_4"></a>3. <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/tree/master/chapter_4" target="_blank" rel="noopener">Chapter_4</a></h3><h4 id="3-1-树-tree（部分基于栈）"><a href="#3-1-树-tree（部分基于栈）" class="headerlink" title="3.1 树 tree（部分基于栈）"></a>3.1 树 tree（部分基于栈）</h4><h5 id="3-1-1-二叉树binary-tree（表达式树、二叉查找树binary-search-tree【BST，左小右大】）（N为节点树数目）"><a href="#3-1-1-二叉树binary-tree（表达式树、二叉查找树binary-search-tree【BST，左小右大】）（N为节点树数目）" class="headerlink" title="3.1.1 二叉树binary tree（表达式树、二叉查找树binary search tree【BST，左小右大】）（N为节点树数目）"></a>3.1.1 二叉树binary tree（表达式树、二叉查找树binary search tree【BST，左小右大】）<strong>（N为节点树数目）</strong></h5><blockquote><ul><li>tree_bi createEmptyTree()：<strong>生成空树，O(1)</strong></li><li>tree_bi createRoot(int x)：<strong>生成根，O(1)</strong></li><li>int getHeight(searchTree T)：<strong>获取树高度，O(N)</strong></li><li>void delete_wholeST(searchTree T)：<strong>删除树，O(N)</strong></li><li>ptrToNode_bi find_x_ST(int x, searchTree T)：<strong>寻找值为x的节点，O(logN)</strong></li><li>ptrToNode_bi find_min_ST(searchTree T)：<strong>寻找最小值的节点，O(logN)</strong></li><li>ptrToNode_bi find_max_ST(searchTree T)：<strong>寻找最大值的节点，O(logN)</strong></li><li>searchTree insert_ST(int x, searchTree T)：<strong>插入x值的节点，O(logN)</strong></li><li>searchTree delete_ST(int x, searchTree T)：<strong>删除x值的节点，O(logN)</strong></li><li>searchTree create_ST(const int A[], int N)：<strong>生成BST，O(NlogN)</strong></li><li>void printValue_ST(int value, int depth)：<strong>print_ST辅助函数，O(1)</strong></li><li>void print_ST(searchTree T, int depth, int option)：<strong>树的遍历，先序preorder, 中序infix &amp; 后序post, O(N)</strong></li><li>tree_bi build_expressionTree(const int A[], int N)：<strong>构建表达式树， O(N)</strong><h5 id="3-1-2-其余树没实现。。。包括：B树、AVL树、伸展树；红黑树、treap树、k-d树、AA-树（Chapter-12，高级数据结构）"><a href="#3-1-2-其余树没实现。。。包括：B树、AVL树、伸展树；红黑树、treap树、k-d树、AA-树（Chapter-12，高级数据结构）" class="headerlink" title="3.1.2 其余树没实现。。。包括：B树、AVL树、伸展树；红黑树、treap树、k-d树、AA-树（Chapter 12，高级数据结构）"></a>3.1.2 其余树没实现。。。包括：B树、AVL树、伸展树；红黑树、treap树、k-d树、AA-树（Chapter 12，高级数据结构）</h5></li></ul></blockquote><h3 id="4-Chapter-5"><a href="#4-Chapter-5" class="headerlink" title="4. Chapter_5"></a>4. <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/tree/master/chapter_5" target="_blank" rel="noopener">Chapter_5</a></h3><h4 id="4-1-哈希表-HashMap（散列）"><a href="#4-1-哈希表-HashMap（散列）" class="headerlink" title="4.1 哈希表 HashMap（散列）"></a>4.1 哈希表 HashMap（散列）</h4><h5 id="4-1-1-方法1：分离链接法-separate-chainning-method（基于链表）（N为链表个数，tableSize）"><a href="#4-1-1-方法1：分离链接法-separate-chainning-method（基于链表）（N为链表个数，tableSize）" class="headerlink" title="4.1.1 方法1：分离链接法 separate chainning method（基于链表）（N为链表个数，tableSize）"></a>4.1.1 方法1：分离链接法 separate chainning method（基于链表）<strong>（N为链表个数，tableSize）</strong></h5><blockquote><ul><li>int nextPrime_seq(int N)：<strong>寻找大于N的第一个素数，O(N^1.5)</strong></li><li>int hashFuntion_seq(int key, int modValue)：<strong>哈希函数， O(1)</strong></li><li>ptrToHashTable_seq createEmptyHashTable_seq(int tableSize)：<strong>构建空哈希表， O(N)</strong></li><li>void deleteHashTable_seq(ptrToHashTable_seq H)：<strong>删除哈希表H， O(N)</strong></li><li>ptrToNode_seq find_seq(int key, ptrToHashTable_seq H)：<strong>查找H[key]， O(N)</strong></li><li>void insert_seq(int key, ptrToHashTable_seq H)：<strong>插入key， O(N)</strong></li><li>ptrToHashTable_seq createHashTable_seq(const int key[], int N, int tableSize)：<strong>构建哈希表， O(N * tableSize)</strong><h5 id="4-1-2-方法2：开放定址法-open-addressing-（N为链表个数，tableSize）"><a href="#4-1-2-方法2：开放定址法-open-addressing-（N为链表个数，tableSize）" class="headerlink" title="4.1.2 方法2：开放定址法 open addressing （N为链表个数，tableSize）"></a>4.1.2 方法2：开放定址法 open addressing <strong>（N为链表个数，tableSize）</strong></h5></li><li>int nextPrime_oa(int N)：<strong>同nextPrime_seq</strong></li><li>int hashFuntion_oa(int key, int modValue)：<strong>hashFuntion_seq</strong></li><li>ptrToHashTable_oa createEmptyHashTable_oa(int tableSize)：<strong>同createEmptyHashTable_seq</strong></li><li>void deleteHashTable_oa(ptrToHashTable_oa H)：<strong>同deleteHashTable_seq</strong></li><li>position detect_oa(int key, ptrToHashTable_oa H, position current_pos, int collisionNum, int detectFlag)：<strong>线性检测、平方检测，O(1)/O(N)</strong></li><li>position find_oa(int key, ptrToHashTable_oa H, int detectFlag)：<strong>查找key，detect_oa下，O(1)/O(N)</strong></li><li>void insert_oa(int key, ptrToHashTable_oa H, int detectFlag)：<strong>插入key，detect_oa下，O(1)/O(N)</strong></li><li>void delete_oa(int key, ptrToHashTable_oa H, int detectFlag)：<strong>删除key，O(1)/O(N)</strong></li><li>ptrToHashTable_oa createHashTable_oa(const int key[], int N, int tableSize, int detectFlag)：<strong>再散列，O(N)</strong></li><li>ptrToHashTable_oa rehash(ptrToHashTable_oa H, int detectFlag)：<strong>再散列，O(N)</strong><h5 id="4-1-3-Others：双散列（2个散列函数）未实现，可扩散列"><a href="#4-1-3-Others：双散列（2个散列函数）未实现，可扩散列" class="headerlink" title="4.1.3 Others：双散列（2个散列函数）未实现，可扩散列"></a>4.1.3 Others：双散列（2个散列函数）未实现，可扩散列</h5></li></ul></blockquote><h3 id="5-Chapter-6"><a href="#5-Chapter-6" class="headerlink" title="5. Chapter_6"></a>5. <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/tree/master/chapter_6" target="_blank" rel="noopener">Chapter_6</a></h3><h4 id="5-1-堆（优先队列）（N为元素个数）"><a href="#5-1-堆（优先队列）（N为元素个数）" class="headerlink" title="5.1 堆（优先队列）（N为元素个数）"></a>5.1 堆（优先队列）<strong>（N为元素个数）</strong></h4><h5 id="5-1-1-二叉堆-heap-bin（数组实现，上小下大）"><a href="#5-1-1-二叉堆-heap-bin（数组实现，上小下大）" class="headerlink" title="5.1.1 二叉堆 heap_bin（数组实现，上小下大）"></a>5.1.1 二叉堆 heap_bin（数组实现，上小下大）</h5><blockquote><ul><li>PQ_bin createEmptyPQ_bin(int capacity)：<strong>构建空二叉堆，O(1)</strong></li><li>void deletePQ_bin(PQ_bin q)：<strong>删除二叉堆，O(1)</strong></li><li>bool isEmpty_bin(PQ_bin q)：<strong>判断q是否为空，O(1)</strong></li><li>bool isFull_bin(PQ_bin q)：<strong>判断q是否为满，O(1)</strong></li><li>int findMin_bin(PQ_bin q)：<strong>查找最小值，O(1)</strong></li><li>void insert_bin(int x, PQ_bin q)：<strong>插入值x，O(logN)</strong></li><li>int deleteMin_bin(PQ_bin q)：<strong>删除最小值root，O(logN)</strong></li><li>PQ_bin buildHeap_bin(const int A[], int N)：<strong>构建二叉堆，O(NlogN)</strong></li><li>int select_k(const int A[], int N, int k)：<strong>选出数组第k大的数值，O(NlogN)</strong><h5 id="5-1-2-左式堆-heap-left"><a href="#5-1-2-左式堆-heap-left" class="headerlink" title="5.1.2 左式堆 heap_left"></a>5.1.2 左式堆 heap_left</h5></li><li>bool isEmpty_left(PQ_left q)：<strong>判断q是否为空，O(1)</strong></li><li>int findMin_left(PQ_left q)：<strong>查找最小值，O(1)</strong></li><li>PQ_left merge_left(PQ_left q1, PQ_left q2)：<strong>合并q1 &amp; q2，O(logN)</strong></li><li>static PQ_left subMerge_left(PQ_left q1, PQ_left q2)：<strong>merge_left辅助函数</strong></li><li>PQ_left insert_left(int x, PQ_left q)：<strong>插入x，O(logN)</strong></li><li>PQ_left deleteMin_left(PQ_left q)：<strong>删除最小值root，O(logN)</strong></li><li>PQ_left buildHeap_left(const int A[], int N)：<strong>构建左式堆，O(NlogN)</strong><h5 id="5-1-3-斜堆-heap-left-（属于左式堆，差别：交换Npl无条件）"><a href="#5-1-3-斜堆-heap-left-（属于左式堆，差别：交换Npl无条件）" class="headerlink" title="5.1.3 斜堆 heap_left （属于左式堆，差别：交换Npl无条件）"></a>5.1.3 斜堆 heap_left （属于左式堆，差别：交换Npl无条件）</h5></li><li>bool isEmpty_skew(PQ_skew q)：<strong>判断q是否为空，O(1)</strong></li><li>int findMin_skew(PQ_skew q)：<strong>查找最小值，O(1)</strong></li><li>PQ_skew merge_skew(PQ_skew q1, PQ_skew q2)：<strong>合并q1 &amp; q2，O(logN)</strong></li><li>static PQ_skew subMerge_skew(PQ_skew q1, PQ_skew q2)：<strong>merge_skew辅助函数</strong></li><li>PQ_skew insert_skew(int x, PQ_skew q)：<strong>插入x，O(logN)</strong></li><li>PQ_skew deleteMin_skew(PQ_skew q)：<strong>删除最小值root，O(logN)</strong></li><li>PQ_skew buildHeap_skew(const int A[], int N)：<strong>构建斜堆，O(NlogN)</strong></li></ul></blockquote><h3 id="6-Chapter-7"><a href="#6-Chapter-7" class="headerlink" title="6. Chapter_7"></a>6. <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/tree/master/chapter_7" target="_blank" rel="noopener">Chapter_7</a></h3><h4 id="6-1-排序算法-（N为元素个数）（平均大O）"><a href="#6-1-排序算法-（N为元素个数）（平均大O）" class="headerlink" title="6.1 排序算法 （N为元素个数）（平均大O）"></a>6.1 排序算法 <strong>（N为元素个数）</strong>（平均大O）</h4><blockquote><ul><li>void insert_sort(int A[], int N)：<strong>插入排序，O(N^2)</strong></li><li>void shell_sort(int A[], int N)：<strong>希尔排序，O(N^1.5-2)</strong></li><li>void heap_sort(int A[], int N)：<strong>堆排序，O(NlogN)</strong></li><li>void merge_sort(int A[], int N)：<strong>归并排序，O(NlogN)</strong></li><li>void quick_sort(int A[], int N)：<strong>快速排序，O(NlogN)</strong></li><li>void bubble_sort(int A[], int N)：<strong>冒泡排序，O(N^2)</strong></li><li>void selection_sort(int A[], int N)：<strong>选择排序，O(N^2)</strong></li></ul></blockquote><h3 id="7-Chapter-8"><a href="#7-Chapter-8" class="headerlink" title="7. Chapter_8"></a>7. <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/tree/master/chapter_8" target="_blank" rel="noopener">Chapter_8</a></h3><h4 id="7-1-并查集（不相交集）（N为NUMSETS，预设集合size）"><a href="#7-1-并查集（不相交集）（N为NUMSETS，预设集合size）" class="headerlink" title="7.1 并查集（不相交集）（N为NUMSETS，预设集合size）"></a>7.1 并查集（不相交集）<strong>（N为NUMSETS，预设集合size）</strong></h4><blockquote><ul><li>int<em> createEmptySet()：<em>*构建空集，O(N)</em></em></li><li>void union1_set(int<em> s, int root1, int root2)：<em>*union-any，O(1)</em></em></li><li>void union2_set(int<em> s, int root1, int root2)：<em>*union-by-size，O(1)</em></em></li><li>void union3_set(int<em> s, int root1, int root2)：<em>*union-by-height，O(1)</em></em></li><li>int find_set(int<em> s, int value)：<em>*查找value所在集合index，O(value)</em></em></li></ul></blockquote><h3 id="8-Chapter-9"><a href="#8-Chapter-9" class="headerlink" title="8. Chapter_9"></a>8. <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/tree/master/chapter_9" target="_blank" rel="noopener">Chapter_9</a></h3><h4 id="8-1-图论-（-V-为点数，-E-为边数）"><a href="#8-1-图论-（-V-为点数，-E-为边数）" class="headerlink" title="8.1 图论 （|V|为点数，|E|为边数）"></a>8.1 图论 <strong>（|V|为点数，|E|为边数）</strong></h4><blockquote><ul><li>ptrToAdjList_DAG createGraph_adjList(int option, int v_num)：<strong>建图，邻接表，O(|V|+|E|)</strong></li><li>ptrToAdjMatrix_DAG createGraph_adjMatrix(int option, int v_num)：<strong>建图，邻接矩阵，O(|V|^2)</strong></li><li>int<em> getIndegree_adjList(ptrToAdjList_DAG adj_list, int v_num)：<em>*获取入度数组，邻接表，O(|E|)</em></em></li><li>int<em> getIndegree_adjMatrix(ptrToAdjMatrix_DAG adj_matrix, int v_num)：<em>*获取入度数组，邻接矩阵，O(|V|^2)</em></em></li><li>Vertex findNewVertexOfIndegreeZero(IndegreeMap indegree_map)：<strong>找到第一个入度为0的点，O(|V|)</strong></li><li>TopSorted_name_vector topSort(ptrToAdjList_DAG adj_list)：<strong>拓扑排序，DAG，O(|E|)</strong></li><li>DistVector createDistVector(ptrToAdjList_DAG adj_list, int targetV)：<strong>构建距离表，O(|V|)</strong></li><li>DistVector findMinPath_unweighted_1(ptrToAdjList_DAG adj_list, int targetV)：<strong>最短路径算法（uW-DAG）版本1，O(|V|^2)</strong></li><li>DistVector findMinPath_unweighted_2(ptrToAdjList_DAG adj_list, int targetV)：<strong>最短路径算法（uW-DAG）版本2，O(|E| + |V|)，BFS</strong></li><li>DistVector findMinPath_weighted(ptrToAdjList_DAG adj_list, int targetV)：<strong>最短路径算法（W-DAG），Dijkstra，O(|V|^2 + |E|)</strong></li><li>DistVector findMinPath_weighted_negative(ptrToAdjList_DAG adj_list, int targetV)：<strong>最短路径算法（nW-DAG），Bellman-Ford，O(|V| * |E|)</strong></li><li>tree_MST_Prim buildMST_Prim(ptrToAdjList_uDAG adj_list, int targetV)：<strong>最小生成树算法Prim，O(|V|^2)</strong></li><li>tree_MST_Kruskal buildMST_Kruskal(ptrToAdjList_uDAG adj_list)：<strong>最小生成树算法Kruskal，O(|E|log|E|)</strong></li><li>Vertex_vector GraphTraversal_BFS(ptrToAdjList adj_list, int targetV)：<strong>广度优先遍历BFS，O(|E| + |V|)</strong></li><li>Vertex_vector GraphTraversal_DFS(ptrToAdjList adj_list, int targetV)：<strong>深度优先遍历DFS，O(|E| + |V|)</strong></li></ul></blockquote><h3 id="9-Chapter-10"><a href="#9-Chapter-10" class="headerlink" title="9. Chapter_10"></a>9. <a href="https://github.com/Eajack/data-structures-and-algorithm-analysis-in-C/tree/master/chapter_10" target="_blank" rel="noopener">Chapter_10</a></h3><h4 id="9-1-算法设计技巧"><a href="#9-1-算法设计技巧" class="headerlink" title="9.1 算法设计技巧"></a>9.1 算法设计技巧</h4><h5 id="9-1-1-Greedy-Algorithm-贪婪算法"><a href="#9-1-1-Greedy-Algorithm-贪婪算法" class="headerlink" title="9.1.1 Greedy Algorithm 贪婪算法"></a>9.1.1 Greedy Algorithm 贪婪算法</h5><h6 id="1-霍夫曼码"><a href="#1-霍夫曼码" class="headerlink" title="(1) 霍夫曼码"></a>(1) 霍夫曼码</h6><blockquote><ul><li>tree_Huffman buildHuffmanTree(SymbolTable T)：<strong>构建霍夫曼树，O(N)</strong></li><li>HuffmanCodeTable buildHuffmanCodeTable(tree_Huffman treeH)：<strong>构建霍夫曼编码表，O(logN)</strong><h6 id="2-近似装箱问题"><a href="#2-近似装箱问题" class="headerlink" title="(2) 近似装箱问题"></a>(2) 近似装箱问题</h6></li><li>Bins solveBMPOnline_nextFit(const double A[], int N)：<strong>下项适合算法，O(N)</strong></li><li>Bins solveBMPOnline_firstFit(const double A[], int N)：<strong>首次适合算法，O(N^2)</strong></li><li>Bins solveBMPOnline_bestFit(const double A[], int N)：<strong>最佳适合算法，O(N^2)</strong><h5 id="9-1-2-Divide-amp-Conquer-分治算法"><a href="#9-1-2-Divide-amp-Conquer-分治算法" class="headerlink" title="9.1.2 Divide &amp; Conquer 分治算法"></a>9.1.2 Divide &amp; Conquer 分治算法</h5><h6 id="1-最近点问题"><a href="#1-最近点问题" class="headerlink" title="(1) 最近点问题"></a>(1) 最近点问题</h6></li><li>double getMinimumPoints(Points points_vector, Point &amp;a, Point &amp;b)：<strong>原算法O(NlogN)，本代码getMinimumPoints_sub未进一步优化</strong><h6 id="2-矩阵乘法"><a href="#2-矩阵乘法" class="headerlink" title="(2) 矩阵乘法"></a>(2) 矩阵乘法</h6></li><li>Matrix matrix_mul_origin(Matrix A, Matrix B, int rowA, int colA, int rowB, int colB)：<strong>矩阵乘法定义，O(N^3)</strong><h6 id="3-随机化算法-Random-Algorithms"><a href="#3-随机化算法-Random-Algorithms" class="headerlink" title="(3) 随机化算法 Random Algorithms"></a>(3) 随机化算法 Random Algorithms</h6></li><li>double getRandom()：<strong>获取随机数，O(1)</strong></li></ul></blockquote><h2 id="4、ToDo-list-may-be…"><a href="#4、ToDo-list-may-be…" class="headerlink" title="4、ToDo list(may be…)"></a>4、ToDo list(may be…)</h2><p>基本的数据结构和算法实现都过了一遍，然而这东西不多看的话，肯定会忘。所以，刷leetcode也是必须的。考虑以后可能会，每一章按主题来写些总结回顾下，这样也能加深记忆，不过也要看时间吧。。。毕竟总结也十分耗时间，只不过重温的收获应该会多点罢了。</p><blockquote><ul><li>刷leetcode</li><li>每一章按主题写总结文</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据结构&amp;算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 数据结构&amp;算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我所喜欢的句子</title>
      <link href="/2019/05/05/%E6%88%91%E6%89%80%E5%96%9C%E6%AC%A2%E7%9A%84%E5%8F%A5%E5%AD%90/"/>
      <url>/2019/05/05/%E6%88%91%E6%89%80%E5%96%9C%E6%AC%A2%E7%9A%84%E5%8F%A5%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>收集个人喜欢的句子，不限于歌词、台词 etc.</p><blockquote><p>Keep updating…</p><ul><li>1 =&gt; 歌词</li><li>2 =&gt; 电影台词</li><li>3 =&gt; 书籍</li><li>4 …</li></ul><h4 id="2017-10-19"><a href="#2017-10-19" class="headerlink" title="2017/10/19"></a>2017/10/19</h4><blockquote><p>谁也讲气候回暖，原来是冷在情天——<em>张敬轩《摄氏零度》 <1></1></em></p><p>何解初初都是漂亮，何解初初双眼善良——<em>周柏豪《还记得》 <1></1></em></p><p>谁都辛酸过，哪个没有——<em>陈奕迅《葡萄成熟时》 <1></1></em></p><p>那动人时光，不用常会看；最动人时光，未必地老天荒——<em>麦浚龙/谢安琪《罗生门》 <1></1></em></p><p>为何旧知己，在最后变不到老友；来年陌生的，是昨日最亲的某某——<em>陈奕迅《最佳损友》 <1></1></em></p><p>其实，人生并非虚耗，何来尘埃飞舞——<em>陈奕迅《沙龙》 <1></1></em></p><p>任何密友任何伴侣和谐互斗投缘互信尊重退缩生疏挂心忽近又远跟世态摇摆，见惯不会怪——<em>张敬轩《不吐不快》 <1></1></em></p><p>行前行后只差一线；回头学会珍惜今天，无暇停下表演幽怨——<em>Swing《那边见》 <1></1></em></p><p>我未似从前幼稚，我在找天生意义——<em>周柏豪《小白》 <1></1></em></p><p>无聊时欢喜在忙时忘记，生命沉闷亦玩过游戏——<em>陈奕迅《失忆蝴蝶》 <1></1></em></p></blockquote><h4 id="2017-10-20"><a href="#2017-10-20" class="headerlink" title="2017/10/20"></a>2017/10/20</h4><blockquote><p>谁料你，谁料我，能合作到爱死对方；应该不止一次幻想怎么逃亡——<em>陈奕迅《斯德哥尔摩情人》 <1></1></em></p></blockquote><h4 id="2017-10-21"><a href="#2017-10-21" class="headerlink" title="2017/10/21"></a>2017/10/21</h4><blockquote><p>年轻人，就应该多听音乐，才不会胡思乱想。他们不听音乐，抽烟，是坏人——<em>黄秋生（片中是叶湘伦&lt;周杰伦饰演&gt;的父亲）《不能说的秘密》 <2></2></em></p></blockquote><h4 id="2017-10-22"><a href="#2017-10-22" class="headerlink" title="2017/10/22"></a>2017/10/22</h4><blockquote><p>我说自尊啊，看起来或许可笑，但它至少撑着我不让我跌倒；活着，如果只是不甘寂寞的喧嚣，那就咆哮吧，让每个人都能听得到——<em>周杰伦《逆鳞》 <1></1></em></p></blockquote><h4 id="2017-10-28"><a href="#2017-10-28" class="headerlink" title="2017/10/28"></a>2017/10/28</h4><blockquote><p>一起这种艺术，若果只是漫长忍让，应感激忠心的伴侣——<em>陈奕迅《远在咫尺》 <1></1></em></p></blockquote><h4 id="2017-11-12"><a href="#2017-11-12" class="headerlink" title="2017/11/12"></a>2017/11/12</h4><blockquote><p>死亡迟早来找你，切勿凭自己——<em>陈奕迅《黑择明》 <1></1></em></p></blockquote><h4 id="2017-11-16"><a href="#2017-11-16" class="headerlink" title="2017/11/16"></a>2017/11/16</h4><blockquote><p>在有生的瞬间能遇到你，竟花光所有运气——<em>陈奕迅《明年今日》 <1></1></em></p></blockquote><h4 id="2017-11-18"><a href="#2017-11-18" class="headerlink" title="2017/11/18"></a>2017/11/18</h4><blockquote><p>得飘，得飘，得咿的飘——<em>周杰伦《漂移》 <1></1></em></p></blockquote><h4 id="2017-11-24"><a href="#2017-11-24" class="headerlink" title="2017/11/24"></a>2017/11/24</h4><blockquote><p>最可笑的，喊亦正常；最悲壮的，笑亦正常；哪一个可，发育正常——<em>陈奕迅《六月飞霜》 <1></1></em></p></blockquote><h4 id="2019-1-2"><a href="#2019-1-2" class="headerlink" title="2019/1/2"></a>2019/1/2</h4><blockquote><p>感谢你，仍然热爱广东歌——<em>年粤日记 2018 <3></3></em></p></blockquote><h4 id="2019-3-7"><a href="#2019-3-7" class="headerlink" title="2019/3/7"></a>2019/3/7</h4><blockquote><p>谈恋爱，游天地，做喜欢的工作和享受游戏——<em>陈奕迅《怕死》 <1></1></em></p><p>活得精彩结尾切勿流眼泪；开心的派对，散后无法聚——<em>陈奕迅《最后派对》 <1></1></em></p><p>有事钟无艳，无事夏迎春——<em>《钟无艳》 <2></2></em></p></blockquote><h4 id="2019-5-5"><a href="#2019-5-5" class="headerlink" title="2019/5/5"></a>2019/5/5</h4><blockquote><p>紅色藍色白色霧色月色 還有粉紅色——<em>《美孚新村上春树》 <1></1></em></p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> Songs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《统计学习方法-李航》Python实现</title>
      <link href="/2019/02/14/%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%9D%8E%E8%88%AA%E3%80%8BPython%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/02/14/%E3%80%8A%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95-%E6%9D%8E%E8%88%AA%E3%80%8BPython%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Statical-Learning-Method-LiHang-py-Eajack"><a href="#Statical-Learning-Method-LiHang-py-Eajack" class="headerlink" title="Statical-Learning-Method-LiHang_py_Eajack"></a>Statical-Learning-Method-LiHang_py_Eajack</h1><h2 id="1、运行环境"><a href="#1、运行环境" class="headerlink" title="1、运行环境"></a>1、运行环境</h2><blockquote><ul><li>Windows or Linux</li><li>Python3.5.2(Python 3.x.x)</li></ul></blockquote><h2 id="2、第三方库汇总"><a href="#2、第三方库汇总" class="headerlink" title="2、第三方库汇总"></a>2、第三方库汇总</h2><blockquote><ul><li>matplotlib</li><li>numpy</li><li>sklearn</li><li>pandas</li></ul></blockquote><h2 id="3、参考资料"><a href="#3、参考资料" class="headerlink" title="3、参考资料"></a>3、参考资料</h2><blockquote><ul><li>《统计学习方法-李航》</li><li>《机器学习实战》</li><li>Google</li></ul></blockquote><h2 id="4、代码说明"><a href="#4、代码说明" class="headerlink" title="4、代码说明"></a>4、代码说明</h2><p>只用py实现第1章-第8章，第9章-第11章，由于个人时间、章节难度&amp;意志（说白了，就是看到第8章时，刚好隔了一段时间玩了，重新捡起时不想看了…）原因，未完成py实现（之前想的C/C++版就…算了吧）</p><p>大致介绍下每章节代码（部分章节的部分内容，未实现）</p><ol><li><a href="https://github.com/Eajack/-Statical-Learning-Method-LiHang-_py_Eajack/tree/master/Chapter_1" target="_blank" rel="noopener">Chapter_1</a><blockquote><ul><li>最小二乘法（Least Square Method）的单变量&amp;多变量版本</li><li>正则化L2</li><li>PS：正则化L1未实现</li></ul></blockquote></li><li><a href="https://github.com/Eajack/-Statical-Learning-Method-LiHang-_py_Eajack/tree/master/Chapter_2" target="_blank" rel="noopener">Chapter_2</a><blockquote><ul><li>感知机（Perceptron）的原始形式&amp;对偶形式</li></ul></blockquote></li><li><a href="https://github.com/Eajack/-Statical-Learning-Method-LiHang-_py_Eajack/tree/master/Chapter_3" target="_blank" rel="noopener">Chapter_3</a><blockquote><ul><li>KNN（线性扫描&amp;kd树版本）</li></ul></blockquote></li><li><a href="https://github.com/Eajack/-Statical-Learning-Method-LiHang-_py_Eajack/tree/master/Chapter_4" target="_blank" rel="noopener">Chapter_4</a><blockquote><ul><li>朴素贝叶斯（Naive Bayes）</li><li>贝叶斯估计（lambda = 1，又称“拉普拉斯平滑”，Laplace Smoothing）</li></ul></blockquote></li><li><a href="https://github.com/Eajack/-Statical-Learning-Method-LiHang-_py_Eajack/tree/master/Chapter_5" target="_blank" rel="noopener">Chapter_5</a><blockquote><ul><li>ID3决策树，生成、分类</li><li>C4.5决策树，生成、分类</li><li>CART决策树，生成、分类、剪枝</li></ul></blockquote></li><li><a href="https://github.com/Eajack/-Statical-Learning-Method-LiHang-_py_Eajack/tree/master/Chapter_6" target="_blank" rel="noopener">Chapter_6</a><blockquote><ul><li>Logistic回归</li><li>梯度下降法（Gradient Descent,GD）：随机GD（stochastic，SGD）、批量GD（Batch GD）、小批量GD（mini-batch，MBGD）</li><li>PS：本章还有最大熵模型、拟牛顿法&amp;改进的迭代尺度法（imporoved iterative scaling，IIS）未实现</li></ul></blockquote></li><li><a href="https://github.com/Eajack/-Statical-Learning-Method-LiHang-_py_Eajack/tree/master/Chapter_7" target="_blank" rel="noopener">Chapter_7</a><blockquote><ul><li>线性可分SVM（Linear Support Vector Machine in Linearly Separable Case，LSVML）</li><li>序列最小最优化算法（Sequence Minimal Optimization，SMO）</li><li>PS：SVM还包括线性SVM、非线性SVM，未实现。与LSVML思路大致相同，不同于前二者分别引入惩罚系数C、惩罚系数C&amp;核函数</li></ul></blockquote></li><li><a href="https://github.com/Eajack/-Statical-Learning-Method-LiHang-_py_Eajack/tree/master/Chapter_8" target="_blank" rel="noopener">Chapter_8</a><blockquote><ul><li>Adaboost</li><li>PS：未实现提升树</li></ul></blockquote></li><li>Chapter_9 ~ Chapter_11：<blockquote><ul><li>EM&amp;GEM</li><li>隐马尔科夫模型（只略看数学原理）</li><li>条件随机场（未看）</li></ul></blockquote></li><li><a href="https://github.com/Eajack/-Statical-Learning-Method-LiHang-_py_Eajack/tree/master/Extra-MLinAction" target="_blank" rel="noopener">Extra-MLinAction</a><blockquote><ul><li>Kmeans（《机器学习方法》挑的实现章节）</li></ul></blockquote></li></ol><h2 id="5、最后一点"><a href="#5、最后一点" class="headerlink" title="5、最后一点"></a>5、最后一点</h2><p>代码仅供参考，质量一般。这书若每天腾空专心看，大致需耗时2个月可看完，并py代码实现。（C/C++就不一定了，矩阵运算等库可能没py方便）</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
            <tag> 机器学习算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018结束了</title>
      <link href="/2019/01/03/2018%E7%BB%93%E6%9D%9F%E4%BA%86/"/>
      <url>/2019/01/03/2018%E7%BB%93%E6%9D%9F%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>18年终于过了，本想迟点再写总结的，发现去年是19号写的。但是，为什么要延迟呢？其实不是因为实在没空，我知道的，是因为我不想再重新面对2018。因为这一年发生了太多太多事，无论是自己经历，还是家里的事。总之，2018，可以说，不是一个好年。</p><p>想起去年，是用了这个引子</p><blockquote><ul><li>Everyone is struggling everyday.</li></ul></blockquote><p>今年的引子是啥，现在一时没想出来。经过了这1年经历，多少有点感慨和遗憾，当然也有开心的。那就用个沙雕的引子吧，也是最近的签名，也是希望19年多点开心，可以做更多自己想做的事情。</p><p>虽然18年的某些成果勉强算是我希望的，但是这段时间付出的一些东西、做过的一些东西都不是我本意想做的。所以，十分希望，19年能做更多自己内心本身想做的东西，而不是为了某些目的而活得不开心。</p><p>有时候，沙雕快乐点比奋斗逼还要好很多。</p><blockquote><ul><li>早晨起来😀，拥抱太阳🌞</li></ul></blockquote><p>就用去年的模板好了，开始总结下这个所谓的2018。</p><h3 id="1-2018任务清单"><a href="#1-2018任务清单" class="headerlink" title="1- 2018任务清单"></a>1- 2018任务清单</h3><p>作为典型的“积极废人”（指爱给自己立flag，但永远做不到的人），2018年头，我当然是有一堆的Flags的，是延续17未完成的Flags继续做的。现在发现，去年写这总结的时候，还没总结出18年Flags，刚好最近立完19年Flags，这次就顺便把19的也放上来。</p><p>此处不把2018中后期，即10月之后才加入list的任务，放进来了，因为基本没完成，直接纳入19年Flags。</p><ul><li>2018任务清单<ol><li>书单<ul><li>《数据结构与算法分析（C语言描述）》</li><li>《大辞海-哲学卷》</li><li><del>《C++ Primer》</del></li><li><del>《Python学习手册》</del></li></ul></li><li>项目<ul><li>无人机 + 三维建模 项目</li><li>无人机基于GPS路径导航规划</li><li>利用树莓派做狗型机器人</li><li>DSP音频模拟器。将自己的声音处理转换为Eason的声音（Eason项目的一部分）</li><li>自动接垃圾的垃圾桶</li></ul></li><li>日常<ul><li>用自己的钱，淘宝买一架无人机（仅用于拍照，可附加实时传送图片功能，目的在于个人项目：无人机 + 三维重建）</li></ul></li><li>学业计划<ul><li><del>以二作发表一篇B类论文（now：3篇b类1作）</del></li><li><del>争取发一篇EI论文（A类）（now：1篇SCIE/SSCI论文，1篇EI论文）</del></li><li><del>争取申请一项专利</del></li></ul></li><li>锻炼计划<ul><li><del>稳定体重55 - 60kg（目前61.2kg，一般维持在62 - 64kg，2018/1/19）</del></li><li>瘦小腿，到30cm，大腿到45cm</li><li>跑步打卡 &gt; 200天（132天）</li></ul></li></ol></li></ul><p>可以看出2018清单里面还有很多都没完成，原因的话很大程度是因为18年一直在准备保研的事情，自然地，像项目、锻炼跑步等在后面基本都是抛弃了。这也算正常，当初可能18年年初立Flag太过匆忙，而且是寒假，当时也在忙项目什么的，Flag也是匆匆立完算了。</p><p>2019的Flag，这次要吸取17、18年教训了。例如，以下是延迟了2年都没完成的Flag</p><ul><li>2017&amp;2018 拖延任务清单<ol><li>书单<ul><li>《数据结构与算法分析（C语言描述）》 <strong><em>（19年重点完成）</em></strong></li><li>《大辞海-哲学卷》 <strong><em>（抛弃任务）</em></strong></li></ul></li><li>项目 <strong><em>（明显的，1个项目都够1年份了…当初Flags立的时候，就是一想到有idea，就加进来，明显是错误的，根本完成不了这么多。所以，先完成1个就很好了）</em></strong><ul><li>无人机 + 三维建模 项目</li><li>无人机基于GPS路径导航规划</li><li>利用树莓派做狗型机器人</li><li>DSP音频模拟器。将自己的声音处理转换为Eason的声音（Eason项目的一部分）</li><li>自动接垃圾的垃圾桶</li></ul></li><li>日常 <strong><em>（抛弃任务。该任务纳入项目里面了，因为项目idea有无人机项目，所以肯定要买机子）</em></strong><ul><li>用自己的钱，淘宝买一架无人机（仅用于拍照，可附加实时传送图片功能，目的在于个人项目：无人机 + 三维重建）</li></ul></li><li>锻炼计划 <strong><em>（对锻炼计划简单化，变成跑步）</em></strong><ul><li>瘦小腿，到30cm，大腿到45cm</li><li>跑步打卡 &gt; 200天（132天）</li></ul></li></ol></li></ul><p>现在放下19年Flags吧，图片是2018/12/29网易Flags图</p><p><div align="center"><img width="300" height="620" src="https://raw.githubusercontent.com/Eajack/Eajack.github.io/master/img/2019.1.3/2019-Flags.png" alt="2018/12/29网易Flags图"></div></p><center>图1. 2018/12/29网易Flags图</center><ul><li>🌞2019任务清单<ol><li>愿望<ul><li>2019，脱单</li><li>2019，身体健康</li></ul></li><li>日常<ul><li>跑步打卡，100 days以上</li><li>12:30 前早睡打卡，150 days以上</li></ul></li><li>书单<ul><li>《数据结构与算法分析（C语言描述）》（&amp;C/C++算法代码实现）</li><li>《统计学习方法-李航》（&amp;Python，C/C++算法代码实现）</li><li>《机器学习实战》</li><li>5本 非计算机类书籍</li></ul></li><li>代码<ul><li>刷leetcode题目</li><li>入门DL &amp; NLP，常用神经网络模型，算法，框架工具</li></ul></li><li>项目<em>（2019目标：完整完成1项）</em><ul><li>无人机基于GPS导航路径规划</li><li>无人机 + 三维建模</li><li>DSP音频模拟器：将自己声音转变成Eason声音</li><li>做一个室内能自动接垃圾的垃圾桶</li><li>NLP：生成丧话、情话</li></ul></li></ol></li></ul><h3 id="2-2018年月份总结"><a href="#2-2018年月份总结" class="headerlink" title="2- 2018年月份总结"></a>2- 2018年月份总结</h3><p>回想2018，像去年一样，想到多少写多少，但也会刻意把一些东西抹去吧。现在大致回看17年总结，大概17年阴影就是12月妈大病那次事了，其余的话，全年还是不算特别多风波，17年过得还是挺充实的。同样，18年也有阴影，但感觉是不止1个。或许，每一年都有出乎意料的几个阴影和几个月份，今年也要做好心理准备才行。毕竟，人生无常。</p><p><strong>1月</strong>延续17年12月妈的大病，1月我记得是考试周吧。考试是崩了，转的鲤鱼一点屁用都没有，崩了2科，通信原理+马哲（上午马哲，下午通信，中午没睡），搞笑的是，通信比马哲还要垃圾。我猜，应该是四年最垃圾绩点一学期，好像记得3.2来着。1月的回忆寥寥无几，应该就只是考试吧，还有就是18年美赛，美赛做完后，体验不错。第二次美赛，不是自夸，做完后我们都觉得自己做得真的好，无论是论文写作，还是模型构建等。还觉得可以冲F奖的，M奖简直是胸有成竹的自信…当然，最后也就只是个M奖，但是已经很开心了，满足了。美赛完后回家，也好彩，妈身体后来也问题不大。</p><p><strong>2月</strong>2月份寒假，我好像忘了做了什么。应该是在忙垃圾桶项目大创结题吧，然后应该是学了下Python什么的，其余还真没印象了。</p><p><strong>3~6月</strong>大三下开始，估计会是大学四年最痛苦的一个学期。这几个月做的东西，想想，可以是以下集合：准备简历 + 疯狂找&amp;投夏令营信息 + 写&amp;投论文 + 大创结项 + 日常看看课内。然而夏令营结果呵呵，只有pkusz过了，唉，说到这就是泪，这是今年的1个阴影。说到这里，到现在都还是一肚子气，真的忍不住想开骂。这段时间，我联系了那里的1位z老师，呵呵，就不说明是哪位了。当然，当时联系老师肯定是选中几个喜欢的，海投，所有学校都是这样。在所有投的老师中，只有2个老师我个人感觉比较有戏的，一个是中大电院的，另一个就是那个z老师。中大电院老师想我考试周约我见面，我当时拒绝了，因为那时候我开始立了Flag，想去z那里。和z邮件聊了几回，满心欢喜，感觉老师给的回应还算积极，也联系了往届那里的师兄和他室友（z的学生，现在wechat删了），求面经和夏令营套路。那段时间，感觉自己很顺利，就打算赌这一把，不知何时有一种：一定要去到那里的心态。之前想的是，有个不错的就行了，那时突然可能转念开始自负起来，一定要去这个（后来才觉得确实一般，有看到的，不喜勿喷。至于师资力量&amp;人品…不予置评，xzdm）。我想去那里，主要就是2个原因：牌子&amp;城市。确实，这2个因素都很喜欢，但校区很小。</p><p><strong>7月</strong>大三下期末结束，考得还算可以，没什么意外。一考完，马上飞去sz夏令营，隔天开始。夏令营碰到了一堆大佬，不，是巨佬。夏令营是辩论队形式，队里其他4个人，都是刚参加完其他夏令营过来的（唉，怪自己学校考试周这么鬼迟，真的没什么夏令营可以参加了。。）。其他4人分别是，2个天大、1个大工、1个武大，就我一个菜鸡211，2个天大分别参加完上交&amp;中科院电子所、中科院电子所夏令营；大工巨佬，参加完THU汽车学院&amp;计算法学、北大叉院，一来到滔滔不绝，虽说很牛逼，但这人人品不喜欢，就不细说了，有些人就这样，见第一面就不喜欢他了；武大妹子，中科院信工所好像，已有本校offer。今年夏令营生源还是挺不错的，都是大佬，应该救我弱鸡了。后来糊里糊涂当上队长，我们是正方，反方的人也很牛逼，中科大、大工、南理、哈工大、川大的，反正都是大佬。夏令营最值得回忆的应该是，通宵10个人，写辩论剧本，3点睡7点起，说实话，很棒的一次回忆，很久没试过这种头脑风暴了。夏令营除了辩论赛，我第一天去到下午就和z“面试”，说了想做CV，碰到ta博士生（后来加了wechat，又删了），“面试”还行，最终ta还信誓旦旦说约定好要跟ta哦，不能反悔哦，而且ta还和颜悦色。（说到这，真tm又想锤爆，疯狂骂人，wr&lt;&gt;ng不谢。因为直到最后ta才反悔，我真的rlg的运气啊。）面谈完，我真的高兴得不得了，又和好友说，又和家人说，z说9月会有个推免，但是基本没问题，往年推上去的都过了,呵x140…夏令营除了面谈、辩论，还有去鹅厂总部、深圳湾逛了一下，碰到同校2个大佬（1个最后跟z，呵呵，就叫做h吧；1个去复旦），还有就是和几个辩论队的大佬加了个q，也算是这次的一个很好的收获了，空间都有时还有互动。夏令营走的那天，下雨，但那时的我很开心，拿了老师offer，可能那雨是上天的表态，我都还不知后面发生的什么事，蒙在鼓里。</p><p><strong>8月</strong>暑假开始。暑假出现了一件很伤心的事，奶奶走了。唉，很突然，真的很突然的一次，就不细说了，保留在记忆里吧。剩下的暑假 = 科2再次挂科+ 人脸分割大创 + 部分pytorch入门 + 玩 + 准备9月校内答辩&amp;9推。</p><p><strong>9月</strong>另一件伤心事，就是在9月。我被z鸽了。9月，去北京面试，的确面的一般般，数学题做得不好，但问问题我觉得做得还是不错的…然后，我也没想啥，毕竟第一次来北京，面试也算是玩了2，3天。去了人大&amp;颐和园（人大同学带）、王府井（和h、其余面试的一起去）、逛了圈p大（的确很清朝，很适合拍照）。伤心是在我坐飞机回来的那晚，我一下飞机，打开微信，z的博士生和我说我面试有点悬，让我有可能要找下家。我当时在机场快哭出来了，和h在一起，他也在安慰我，说结果还没出啊，也可能不是的。一下飞机，我就打电话给z的博士生，聊了很久，明显地，我是被鸽了，我一直被他安慰。更可恶的是，我q上问z，一直没回复我！！！所以，直到现在，我都还十分厌恶那所学校。然而，恐怖的是，那时我根本没准备其他offer啊，有了这个其他我都没投了啊（tm现在觉得，自己当时心真的大，怕是当时被自己很想去那里的念头，一时自负&amp;高兴冲晕了头脑）。当晚住了招待所，我当晚和我妈聊了下，就和1个好友一直聊，聊到2点。躺在床上，我想着，sl，一切都重头来过了，快6个月的努力白费了。好友和我妈一直安慰我，我不知为什么哭不出来，我当时很困，记得聊了很多，一直在骂一直在骂，好友也是一直骂。但是，都成事实了。没办法，我还是睡了。本来第二天中秋，和另一班好友聚会的，然而哪有什么心情，7点起床马上坐早班车回学校，因为我还要忍痛准备其他学校9推，也就是最后机会。回了校，当我和好友提起，终于忍不住了，我哭了，稀里糊涂，哭了好久，好友陪我去吃饭。真心感谢sl、sz那两天的帮助。sz说，别哭，想下我，被10几个学校拒夏令营的人；要做的是，抓紧机会，还有9推。他说的很平淡，我努力抑制情绪波动，那时真的很佩服他。之后几天23-30号一周，看着别人都拿了offer，我仍在继续投学校，十分幸运保研群有人说hust有导师还有名额，这消息还是我另一个同学和我说的。我当时只是抱着试一下的心态投，电话面试，谁知最后过了。9推，报了3个志愿，都中了，hust计院（最早offer，最终选择）、中大电院（比hust迟一点，拒了offer，因为这个院做硬件、通信多，不喜欢这个）、中大智能工程（拒了复试，但是面试官还催我去，怕是今年竞争不激烈，加上这是新院），其实还有中大电通（新院，后来催我，我说有了offer就没下文）。其实吧，选择也不多，当时还以为还可以选下华工的，但系统只有3个选项，也就那样了，满足吧。只是，z给我留下的阴影，是18年一大阴影。</p><p><div align="center"><img width="400" height="470" src="https://raw.githubusercontent.com/Eajack/Eajack.github.io/master/img/2019.1.3/2018-保研.jpg" alt="2018-保研"></div></p><center>图2. 2018-保研</center><p><strong>10月</strong>10月国庆，总算尘埃落定。玩了1个国庆，师兄说让我国庆过后尽早过去搬砖，我也知道的，所有研究生导师都这样，廉价劳动力…但学校这边还有课，就把这个推到了11月。10月基本都是玩，咸鱼，不再去想z那件破事，开始刷火影（昨天刚刷到300集，阿斯玛走了，唉）。</p><p><strong>11月</strong>11月，是属于华科的。一整个月去武汉搬砖，认识了师姐，初次接触同级的2个（原来他们早来搬砖了）。第一天去到是周五，周六实验室聚餐，被迫喝了2罐黑啤，跟师兄师姐看夜场电影《无双》，当晚2点才睡…这个月，搬砖之余，和师兄师姐去浪了一共3次，第二遍看完《机器学习-周志华》前10章。开始从CVer =&gt; NLPer。</p><center class="half">    <img width="320" height="190" src="https://raw.githubusercontent.com/Eajack/Eajack.github.io/master/img/2019.1.3/2018-11-hust-1.jpg" alt="2018-11-hust-1" hspace="10"><img width="320" height="190" src="https://raw.githubusercontent.com/Eajack/Eajack.github.io/master/img/2019.1.3/2018-11-hust-2.jpg" alt="2018-11-hust-2"></center><center>图3. 2018-11月HUST</center><p><strong>12月</strong>12月，搬砖回来了。继续上课，好像就没啥大事了。刷完《统计学习方法-李航》前5章&amp;Python代码算法实现，接着就是和考完研的好友吃喝玩乐，跨年饭。</p><p>2018完了，这年过得比17年更曲折、惊心动魄。也不想多去想18年的事，最重要是把握现在。过去固然是要回顾，但回顾的作用是以史为鉴，不要再去重新犯错，回顾完之后就继续前行吧，不能一直停留在过去，不管是悲痛的过去还是欢笑的过去。</p><h3 id="3-2019-amp-遐想"><a href="#3-2019-amp-遐想" class="headerlink" title="3- 2019 &amp; 遐想"></a>3- 2019 &amp; 遐想</h3><p>2019来了，我希望这一年能有所变化，能做更多自己本心想做的事。</p><p>去年这段话</p><blockquote><p>这一年，应该是大学最艰难的一年了吧。既然你选择了想要保研这条路，那这一年的所有将会是你大学期间另一个最有怀念价值的拼搏时期。尽我全力，破釜沉舟，背水一战，只求今年9月笑逐颜开。2018年，希望，你做好充分准备，心理准备。</p></blockquote><p>17年的自己，真不好意思，18年多少是有遗憾的。但，这一年的努力、坚持的收获永远都值得回忆。</p><ul><li>遐想</li></ul><p>也是保研过了后，会想得越来越宽，想以后能做更多自己原本就想做的事，例如想第一次去录音棚录歌；想开始规划毕业后先搬砖几年攒钱，之后考虑出国读个博（?，当然时间短是第一要求），或者尝试换一种生活方式，可不想一直上班搬砖到老吧，但要看自己有没有这种勇气了；想工作攒钱，以后能有个自己喜欢的人，一起环游世界（hhh）。</p><p>所以说，还是要先搬砖、攒钱，当然也要考虑房子、人生大事等一堆事。现实就是，万事都离不开💴。与其说是抛弃理想主义，不如说是拥抱实用主义。至少在我目前阅历来说，这句话准确度是很高的，毕竟我也不是什么富二代。在社会，生存是首位。</p><p>不过，我想自己是不会走学术这条路的，之前是这样想，现在也是。这也是为什么我前面说“但是这段时间付出的一些东西、做过的一些东西都不是我本意想做的”，说的其实有一部分就是在为保研弄的东西，沾染了功利性和被迫于现实的一些东西，不是说道德意义上的东西（这个是没有涉及到的…），只是有时感觉，有些东西太过功利了吧。说是这样说，但也不担保以后的自己会不会还是这样，只是目的换成了另一个。</p><p>正如Eason一首歌《然后怎样》的歌词</p><blockquote><p>我最初只贪玩，为何变负担</p></blockquote><p>讲多无谓，加油！</p>]]></content>
      
      
      <categories>
          
          <category> 鸡汤 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸡汤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub-repo收藏（updating）</title>
      <link href="/2019/01/01/GitHub-repo%E6%94%B6%E8%97%8F%EF%BC%88updating%EF%BC%89/"/>
      <url>/2019/01/01/GitHub-repo%E6%94%B6%E8%97%8F%EF%BC%88updating%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>个人在GitHub上面，发现感觉有用的repo分类集合<br>keep updating~<br> <strong>updated on 2019/1/1</strong></p><h2 id="1-Python爬虫"><a href="#1-Python爬虫" class="headerlink" title="1- Python爬虫"></a>1- Python爬虫</h2><blockquote><ul><li><a href="https://github.com/facert/awesome-spider" target="_blank" rel="noopener">各类爬虫代码收集（awesome-spider）</a></li><li><a href="https://github.com/yhangf/PythonCrawler" target="_blank" rel="noopener">Python爬虫集合（PythonCrawler）</a></li></ul></blockquote><h2 id="2-CS竞赛"><a href="#2-CS竞赛" class="headerlink" title="2- CS竞赛"></a>2- CS竞赛</h2><blockquote><ul><li><a href="https://github.com/iphysresearch/DataSciComp" target="_blank" rel="noopener">数据科学竞赛-整理（Data Science Competitions）</a></li></ul></blockquote><h2 id="3-数据集"><a href="#3-数据集" class="headerlink" title="3- 数据集"></a>3- 数据集</h2><h3 id="3-1-杂乱数据集"><a href="#3-1-杂乱数据集" class="headerlink" title="3.1- 杂乱数据集"></a>3.1- 杂乱数据集</h3><blockquote><ul><li><a href="https://github.com/awesomedata/awesome-public-datasets" target="_blank" rel="noopener">各领域公开数据集（Awesome Public Datasets）</a></li></ul></blockquote><h2 id="4-DL-大杂烩"><a href="#4-DL-大杂烩" class="headerlink" title="4- DL 大杂烩"></a>4- DL 大杂烩</h2><h3 id="4-1-大杂烩"><a href="#4-1-大杂烩" class="headerlink" title="4.1- 大杂烩"></a>4.1- 大杂烩</h3><blockquote><ul><li><a href="https://github.com/ChristosChristofidis/awesome-deep-learning" target="_blank" rel="noopener">深度学习各类书籍、教程、项目、数据集&amp;论文 etc.（Awesome Deep Learning）</a></li></ul></blockquote><h3 id="4-2-教程"><a href="#4-2-教程" class="headerlink" title="4.2- 教程"></a>4.2- 教程</h3><blockquote><ul><li><a href="https://github.com/fengdu78/deeplearning_ai_books" target="_blank" rel="noopener">吴恩达DL课程笔记&amp;资源（deeplearning_ai_books）</a></li></ul></blockquote><h2 id="5-ML-大杂烩"><a href="#5-ML-大杂烩" class="headerlink" title="5- ML 大杂烩"></a>5- ML 大杂烩</h2><h3 id="5-1-ML学术"><a href="#5-1-ML学术" class="headerlink" title="5.1- ML学术"></a>5.1- ML学术</h3><blockquote><ul><li><a href="https://github.com/RedditSota/state-of-the-art-result-for-machine-learning-problems" target="_blank" rel="noopener">ML学术前沿进展（state-of-the-art-result-for-machine-learning-problems）</a></li></ul></blockquote><h3 id="5-2-教程"><a href="#5-2-教程" class="headerlink" title="5.2- 教程"></a>5.2- 教程</h3><blockquote><ul><li><a href="https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes" target="_blank" rel="noopener">斯坦福大学2014（吴恩达）机器学习教程中文笔记</a></li><li><a href="https://github.com/wzyonggege/statistical-learning-method" target="_blank" rel="noopener">《统计学习方法》笔记-基于Python算法实现 </a></li></ul></blockquote><h2 id="6-自然语言处理NLP"><a href="#6-自然语言处理NLP" class="headerlink" title="6- 自然语言处理NLP"></a>6- 自然语言处理NLP</h2><h3 id="6-1-NLP大杂烩"><a href="#6-1-NLP大杂烩" class="headerlink" title="6.1- NLP大杂烩"></a>6.1- NLP大杂烩</h3><blockquote><ul><li><a href="https://github.com/fighting41love/funNLP" target="_blank" rel="noopener">各类NLP算法、数据库etc.</a></li><li><a href="https://github.com/crownpku/Awesome-Chinese-NLP" target="_blank" rel="noopener">中文NLP资源：Awesome-Chinese-NLP</a></li></ul></blockquote><h3 id="6-2-NLP学术"><a href="#6-2-NLP学术" class="headerlink" title="6.2- NLP学术"></a>6.2- NLP学术</h3><blockquote><ul><li><a href="https://github.com/sebastianruder/NLP-progress" target="_blank" rel="noopener">NLP-progress</a></li></ul></blockquote><h3 id="6-3-NLP工程"><a href="#6-3-NLP工程" class="headerlink" title="6.3- NLP工程"></a>6.3- NLP工程</h3><blockquote><ul><li><a href="https://github.com/google-research/bert" target="_blank" rel="noopener">谷歌bert</a></li><li><a href="https://github.com/HIT-SCIR/ltp" target="_blank" rel="noopener">哈工大LTP</a></li><li><a href="https://github.com/isnowfy/snownlp" target="_blank" rel="noopener">SnowNLP库，中文电商情感分析库</a></li><li><a href="https://github.com/fxsjy/jieba" target="_blank" rel="noopener">jieba库，中文分词库</a></li></ul></blockquote><h3 id="6-4-NLP-情感分析"><a href="#6-4-NLP-情感分析" class="headerlink" title="6.4- NLP-情感分析"></a>6.4- NLP-情感分析</h3><blockquote><ul><li><a href="https://github.com/rainarch/SentiBridge" target="_blank" rel="noopener">SentiBridge: 中文实体情感知识库</a></li></ul></blockquote><h2 id="7-编程语言"><a href="#7-编程语言" class="headerlink" title="7- 编程语言"></a>7- 编程语言</h2><h3 id="7-1-C语言"><a href="#7-1-C语言" class="headerlink" title="7.1- C语言"></a>7.1- C语言</h3><blockquote><ul><li><a href="https://github.com/jobbole/awesome-c-cn" target="_blank" rel="noopener">C 语言资源大全中文版</a></li></ul></blockquote><h2 id="8-工作"><a href="#8-工作" class="headerlink" title="8- 工作"></a>8- 工作</h2><blockquote><ul><li><a href="https://github.com/kdn251/interviews" target="_blank" rel="noopener">CS工作面试所需知识（interviews）</a></li></ul></blockquote><h2 id="9-书籍、教程-etc"><a href="#9-书籍、教程-etc" class="headerlink" title="9- 书籍、教程 etc."></a>9- 书籍、教程 etc.</h2><blockquote><ul><li><a href="https://github.com/yuanliangding/books" target="_blank" rel="noopener">各类书籍（books）</a></li><li><a href="https://github.com/tuteng/Best-websites-a-programmer-should-visit-zh" target="_blank" rel="noopener">程序员应该访问的最佳网站（中文版）</a></li><li><a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">免费的编程中文书籍索引</a></li><li><a href="https://github.com/prakhar1989/awesome-courses" target="_blank" rel="noopener">Awesome CS Courses</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub-repo收藏分类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>py3爬虫项目</title>
      <link href="/2018/06/20/py3%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE/"/>
      <url>/2018/06/20/py3%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>Github repo地址：<a href="https://github.com/Eajack/py_spider" target="_blank" rel="noopener">py_spider</a><br>欢迎各路大神在issues里面提供ideas，欢迎fork &amp; star</p><h2 id="1、运行环境"><a href="#1、运行环境" class="headerlink" title="1、运行环境"></a>1、运行环境</h2><blockquote><ul><li>Windows or Linux</li><li>Python3.5.2(Python 3.x.x)</li></ul></blockquote><h2 id="2、内置库汇总"><a href="#2、内置库汇总" class="headerlink" title="2、内置库汇总"></a>2、内置库汇总</h2><blockquote><ul><li>urllib</li><li>re,os,time</li><li>json</li></ul></blockquote><h2 id="3、第三方库汇总"><a href="#3、第三方库汇总" class="headerlink" title="3、第三方库汇总"></a>3、第三方库汇总</h2><blockquote><ul><li>bs4(BeautifulSoup)</li><li>requests</li><li>selenium</li><li>jieba</li><li>wordcloud</li><li>matplotlib</li><li>scipy</li><li>snownlp</li><li>xlwt</li><li>xlrd</li><li>[updating…]</li></ul></blockquote><h2 id="4、爬虫说明"><a href="#4、爬虫说明" class="headerlink" title="4、爬虫说明"></a>4、爬虫说明</h2><blockquote><ul><li><a href="https://github.com/Eajack/py_spider/blob/master/%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB/computer_books.py" target="_blank" rel="noopener">computer_books.py</a>：豆瓣”世界著名计算机教材节选”爬虫</li><li><a href="https://github.com/Eajack/py_spider/blob/master/%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB/Eason_Film.py" target="_blank" rel="noopener">Eason_Film.py</a>：豆瓣”Eason电影”爬虫（收到知乎网友反映“无法爬取”，经检查发现豆瓣网页HTML结构改版…该代码已不能爬取，考虑有空再重写……）</li><li><a href="https://github.com/Eajack/py_spider/blob/master/%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB/emojiCrawler.py" target="_blank" rel="noopener">emojiCrawler.py</a>：<a href="http://emojipedia.org/" target="_blank" rel="noopener">emoji官网</a>爬虫，按官网分类爬取所有不同版本的emoji.png图片（eg:Apple,Samsung.Google etc.)</li><li><a href="https://github.com/Eajack/py_spider/blob/master/%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB/wiki_6DegreeSeperation.py" target="_blank" rel="noopener">wiki_6DegreeSeperation.py</a>：wiki爬虫，广度优先遍历，为证明“六度分割理论”，暂时只能尝试，并非完全证明</li><li><a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/EasonLyrics_README.md" target="_blank" rel="noopener">music163_EasonLyrics</a>：网易云Eason所有歌词爬虫 + 文本分析，详见<a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/EasonLyrics_README.md" target="_blank" rel="noopener">EasonLyrics_README</a></li><li><a href="https://github.com/Eajack/py_spider/blob/master/%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB/getCity.py" target="_blank" rel="noopener">getCity.py</a>：基于谷歌地图API简单爬虫，通过经纬度查询该地点所属城市</li><li><a href="https://github.com/Eajack/py_spider/tree/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments" target="_blank" rel="noopener">music163_EasonComments</a>：网易云Eason所有单曲评论数排行、最新10条评论抓取 &amp; 热门评论文本分析,详见<a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/EasonComments_README.md" target="_blank" rel="noopener">EasonComments_README</a></li><li><a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_autoSignIn.py" target="_blank" rel="noopener">music163_autoSignIn.py</a>：网易云音乐网页端，每天定时自动签到（windows）</li><li><a href="https://github.com/Eajack/py_spider/blob/master/%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB/getShares163.py" target="_blank" rel="noopener">getShares163.py</a>：网易股票数据小爬虫</li><li>[updating…]</li></ul></blockquote><h2 id="5、留坑"><a href="#5、留坑" class="headerlink" title="5、留坑"></a>5、留坑</h2><blockquote><ul><li>多线程/进程（解决爬虫太慢）</li><li>Python编程技巧</li><li>[updating…]</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog修复Flag</title>
      <link href="/2018/06/13/Blog%E4%BF%AE%E5%A4%8DFlag/"/>
      <url>/2018/06/13/Blog%E4%BF%AE%E5%A4%8DFlag/</url>
      
        <content type="html"><![CDATA[<p>老早之前就发现blog存在问题了，侧栏文章不知怎得点开后看不了全文……</p><ul><li>eg: <a href="https://eajack.github.io/2018/03/17/FCM%E6%A8%A1%E7%B3%8A%E8%81%9A%E7%B1%BBM%E7%A0%81/">FCM模糊聚类M码</a></li></ul><p>还有，对比其他主题发现这主题不是很人性化，文章不存在折叠功能，要看其他文章滚动条要滚很久…</p><p>先这样吧……</p><p>反正这破站没人看……</p><p>等到暑假再修复下想到得所有问题……</p><p>最近肯定没空了，也不会发什么东西。个人项目&amp;Blog维护只能暑假再说，絮絮叨叨……</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FCM模糊聚类M码</title>
      <link href="/2018/03/17/FCM%E6%A8%A1%E7%B3%8A%E8%81%9A%E7%B1%BBM%E7%A0%81/"/>
      <url>/2018/03/17/FCM%E6%A8%A1%E7%B3%8A%E8%81%9A%E7%B1%BBM%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>源代码，本来用于数模题目中的电网设计</p><pre><code class="lang-matlab">function [clusterResult,U,iter_n] = FCM(upPresureSite, windMachineSites, clusterNum, m)    % 输入：    % clusterNum：聚类个数，1 &lt; K &lt; N（点个数）    % m：模糊指数，1 &lt; m &lt; +无穷    % upPresureSite：升压站坐标，1 x 2 矩阵    % windMachineSites：风机坐标，N x 2 矩阵    % maxWMNum：一串最大风机数，缺省时为5    % minWMNum：一串最小风机数，缺省时为3    %% 1- 初始化 U0 以及 初始化变量    %     maxWMNum = 5;    %     minWMNum = 3;    [dataNum,dimention] = size(windMachineSites) ;    upPresureSiteMatrix = repmat(upPresureSite,[dataNum,1]);    windMachineSites = windMachineSites - upPresureSiteMatrix;  % 以升电站为原点    epsilon = 1e-40; % 收敛精度，epsilon &gt; 0    iters = 10000 ;  % 模糊聚类迭代次数    Uexpo = 2 ;  % 隶属度指数    % 随机初始化 模糊划分矩阵：U0，使U0满足列上相加为1    U0 = rand(clusterNum,dataNum);    U0=U0./(ones(clusterNum,1)*sum(U0));    U = U0 ;    % 初始化聚类中心    centerMatrix = zeros(clusterNum,dimention);    % 初始化价值函数矩阵    valueFunctionMatrix = zeros(iters,1);    % FCM 循环开始    for iterCount = 1:iters        %% 2- 计算clusterNum 个聚类中心        Uout = U .* Uexpo;  % 隶属度指数相乘        centerMatrix = (Uout * windMachineSites) ./ sum(U(clusterNum,:));        %% 3- 计算 价值函数        % 3.1- 计算 距离矩阵        distMatrix = zeros(clusterNum, dataNum);        % 遍历clusterNum个聚类中心        for clusterCount = 1:clusterNum            % 求当前聚类中心求与所有样本点距离            for dataCount = 1:dataNum                distMatrix(clusterCount,dataCount) = ...                norm( centerMatrix(clusterCount,:) - windMachineSites(dataCount,:) );            end        end        % 3.2- 计算价值函数 值        distMatrix2 = distMatrix .^ 2;  % 平方        valueFunctionMatrix(iterCount) = sum(sum(distMatrix2 .* Uout));        %% 4- 计算新的 模糊划分矩阵U        for i = 1:clusterNum            for j = 1:dataNum                DijVector = distMatrix(i,j) * ones(clusterNum,1);                DNjVector = distMatrix(:,j);                temp = (DijVector ./ DNjVector).^(2/(Uexpo-1));                temp = sum(temp);                valueFunctionMatrix(i,j) = 1 / temp;            end        end        %% 5- 算法终止条件判断        if iterCount &gt; 1 &amp;&amp; abs(valueFunctionMatrix(iterCount) - valueFunctionMatrix(iterCount-1)) &lt;= epsilon            break;        end    end    iter_n = iterCount; % 实际迭代次数    [max_U,clusterAns]=max(U);    clusterResult = [ windMachineSites+upPresureSiteMatrix , clusterAns&#39; ] ;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《2018年刑侦科推理试题》Python版求解⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄</title>
      <link href="/2018/03/07/%E3%80%8A2018%E5%B9%B4%E5%88%91%E4%BE%A6%E7%A7%91%E6%8E%A8%E7%90%86%E8%AF%95%E9%A2%98%E3%80%8BPython%E7%89%88%E6%B1%82%E8%A7%A3%E2%81%84(%E2%81%84%20%E2%81%84%E2%80%A2%E2%81%84%CF%89%E2%81%84%E2%80%A2%E2%81%84%20%E2%81%84)%E2%81%84/"/>
      <url>/2018/03/07/%E3%80%8A2018%E5%B9%B4%E5%88%91%E4%BE%A6%E7%A7%91%E6%8E%A8%E7%90%86%E8%AF%95%E9%A2%98%E3%80%8BPython%E7%89%88%E6%B1%82%E8%A7%A3%E2%81%84(%E2%81%84%20%E2%81%84%E2%80%A2%E2%81%84%CF%89%E2%81%84%E2%80%A2%E2%81%84%20%E2%81%84)%E2%81%84/</url>
      
        <content type="html"><![CDATA[<p>昨天刷知乎想法，看到Milo Yip的<a href="https://www.zhihu.com/pin/954541989945905152" target="_blank" rel="noopener">深夜暴力編程</a>，感觉有点意思，所有尝试用py写了下…思路没什么，就是暴力遍历而已，纯粹一时兴起~先抛结果：BCACACDABA</p><p>Python代码如下：</p><pre><code class="lang-python"># !/usr/bin/env python3# -*- coding : utf-8 -*-# ==================================================================================================================# Author: Eajack# date:2018/3/7# ==================================================================================================================# Function：#   2018年刑侦科推理试题，暴力遍历……# ==================================================================================================================# Results：#   [&#39;B&#39;, &#39;C&#39;, &#39;A&#39;, &#39;C&#39;, &#39;A&#39;, &#39;C&#39;, &#39;D&#39;, &#39;A&#39;, &#39;B&#39;, &#39;A&#39;]#   [Finished in 5.7s]#   经过检验，答案都是对的（如果没眼花的话……）# ==================================================================================================================def preparation(answers):    global maxCount,maxOption,minCount,minOption    numCountsDict = {i:answers.count(i) for i in set(answers)}    numCountsList = []    for key,value in numCountsDict.items():        numCountsList.append([value,key])    numCountsList = sorted(numCountsList,reverse = True)    maxCount = numCountsList[0][0]    maxOption = numCountsList[0][1]    minCount = numCountsList[-1][0]    minOption = numCountsList[-1][1]def Q3Test(answers):    if(answers[2] == 1):        return (answers[5]==answers[1]==answers[3] and answers[2]!=answers[5])    else:        if(answers[2]==2):            return (answers[2]==answers[1]==answers[3] and answers[5]!=answers[2])        else:            if(answers[2]==3):                return (answers[2]==answers[5]==answers[3] and answers[1]!=answers[2])            else:                return (answers[2]==answers[5]==answers[1] and answers[3]!=answers[2])def Q4Test(answers):    trueList = [int(answers[0]==answers[4]),int(answers[1]==answers[6]),int(answers[0]==answers[8]),int(answers[5]==answers[9])]    if(sum(trueList)==1 and trueList[answers[3]-1]==1):        return True    else:        return Falsedef Q6Test(answers):    if(answers[5] == 1):        return (answers[1]==answers[3]==answers[7])    else:        if(answers[5]==2):            return (answers[0]==answers[5]==answers[7])        else:            if(answers[5]==3):                return (answers[2]==answers[9]==answers[7])            else:                return (answers[4]==answers[8]==answers[7])def Q8Test(answers):    if(answers[7] == 1):        return (abs(answers[6]-answers[0])!=1)    else:        if(answers[7]==2):            return (abs(answers[4]-answers[0])!=1)        else:            if(answers[7]==3):                return (abs(answers[1]-answers[0])!=1)            else:                return (abs(answers[9]-answers[0])!=1)if __name__ == &#39;__main__&#39;:#    # globals    Q2toQ5 = {1:3,2:4,3:1,4:2}    Q4toQDouble = {1:[1,5],2:[2,7],3:[1,9],4:[6,10]}    Q5toQX = {1:8,2:4,3:9,4:7}    Q7toQY = {1:3,2:2,3:1,4:4}    Q9toQZ = {1:6,2:10,3:2,4:9}    Q10toQ = {1:3,2:2,3:4,4:1}    answers2ADs = {1:&#39;A&#39;,2:&#39;B&#39;,3:&#39;C&#39;,4:&#39;D&#39;}    maxCount = []    maxOption = []    minCount = []    minOption = []#    for Q1 in range(1,5):        for Q2 in range(1,5):            for Q3 in range(1,5):                for Q4 in range(1,5):                    for Q5 in range(1,5):                        for Q6 in range(1,5):                            for Q7 in range(1,5):                                for Q8 in range(1,5):                                    for Q9 in range(1,5):                                        for Q10 in range(1,5):                                            answers = [Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q8,Q9,Q10]                                            preparation(answers)                                            # 2题 检验                                            if(Q2toQ5[Q2] != Q5):                                                continue;                                            else:                                                # 3题 检验                                                if(Q3Test(answers) != True):                                                    continue;                                                else:                                                    # 4题 检验                                                    if(Q4Test(answers) != True):                                                        continue;                                                    else:                                                        # 5题 检验                                                        if(Q5 != answers[Q5toQX[Q5]-1]):                                                            continue;                                                        else:                                                            # 6题 检验                                                            if(Q6Test(answers) != True):                                                                continue;                                                            else:                                                                # 7题 检验                                                                if(minOption != Q7toQY[Q7]):                                                                    continue;                                                                else:                                                                    # 8题 检验                                                                    if(Q8Test(answers) != True):                                                                        continue;                                                                    else:                                                                        # 9题 检验                                                                        if((Q1==Q6) == (answers[Q9toQZ[Q9]-1] == Q5)):                                                                            continue;                                                                        else:                                                                            # 10题 检验                                                                            if(maxCount - minCount != Q10toQ[Q10]):                                                                                continue;                                                                            else:                                                                                answersADs = [answers2ADs[answer] for answer in answers ]                                                                                print(answersADs)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV零碎点笔记</title>
      <link href="/2018/02/20/OpenCV%E9%9B%B6%E7%A2%8E%E7%82%B9%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/02/20/OpenCV%E9%9B%B6%E7%A2%8E%E7%82%B9%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>Series:<strong>OpenCV学习笔记</strong></p><h3 id="updating"><a href="#updating" class="headerlink" title="updating"></a><em>updating</em></h3><h3 id="1-OpenCV常用常数"><a href="#1-OpenCV常用常数" class="headerlink" title="1. OpenCV常用常数"></a>1. OpenCV常用常数</h3><ul><li>矩阵数据类型：<code>CV_&lt;bit_depth&gt;(S|U|F)C&lt;number_of_channels&gt;</code></li></ul><blockquote><p>S = 符号整型  U = 无符号整型  F = 浮点型</p><p>E.g.:<br>CV_8UC1 是指一个8位无符号整型单通道矩阵<br>CV_32FC2是指一个32位浮点型双通道矩阵</p></blockquote><p>列出如下：</p><div class="table-container"><table><thead><tr><th>数</th><th>据</th><th>类</th><th>型</th></tr></thead><tbody><tr><td>CV_8UC1</td><td>CV_8SC1</td><td>CV_16U C1</td><td>CV_16SC1</td></tr><tr><td>CV_8UC2</td><td>CV_8SC2</td><td>CV_16U C2</td><td>CV_16SC2</td></tr><tr><td>CV_8UC3</td><td>CV_8SC3</td><td>CV_16U C3</td><td>CV_16SC3</td></tr><tr><td>CV_8UC4</td><td>CV_8SC4</td><td>CV_16U C4</td><td>CV_16SC4</td></tr><tr><td>CV_32SC1</td><td>CV_32FC1</td><td>CV_64FC1</td><td>NULL</td></tr><tr><td>CV_32SC2</td><td>CV_32FC2</td><td>CV_64FC2</td><td>NULL</td></tr><tr><td>CV_32SC3</td><td>CV_32FC3</td><td>CV_64FC3</td><td>NULL</td></tr><tr><td>CV_32SC4</td><td>CV_32FC4</td><td>CV_64FC4</td><td>NULL</td></tr></tbody></table></div><h3 id="2-OpenCV平台配置汇总"><a href="#2-OpenCV平台配置汇总" class="headerlink" title="2.OpenCV平台配置汇总"></a>2.OpenCV平台配置汇总</h3><ul><li><a href="http://blog.csdn.net/wx7788250/article/details/54970903" target="_blank" rel="noopener">【OpenCV】CodeBlocks+OpenCV3.2环境搭建</a></li><li><a href="https://robocoderhan.github.io/2016/12/13/Raspberry%20Pi%203%20+%20Raspbian%20Jessie%20+%20OpenCV%203/" target="_blank" rel="noopener">Raspberry Pi 3 + Raspbian Jessie + OpenCV 3</a></li><li><a href="http://www.srccodes.com/p/article/56/uninstall-remove-opencv-raspberry-pi-jessie-debain-make-uninstall-open-source-computer-vision-opencvlib" target="_blank" rel="noopener">How to uninstall OpenCV (Open Source Computer Vision) from Raspberry Pi - Raspbian Jessie?</a>(需翻墙)</li><li><a href="http://blog.csdn.net/xukai871105/article/details/40988101" target="_blank" rel="noopener">树莓派学习笔记—— 源代码方式安装opencv</a> &amp; <a href="http://blog.csdn.net/xukai871105/article/details/41084949" target="_blank" rel="noopener">树莓派学习笔记——apt方式安装opencv</a></li><li><a href="http://blog.csdn.net/dango_miracle/article/details/78681131" target="_blank" rel="noopener">【OpenCV】VS2017配置OpenCV2.4.13.4（其余高版本同理）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>侧栏音乐</title>
      <link href="/2018/02/18/%E4%BE%A7%E6%A0%8F%E9%9F%B3%E4%B9%90/"/>
      <url>/2018/02/18/%E4%BE%A7%E6%A0%8F%E9%9F%B3%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<p>以下为目前侧栏音乐备选音乐列表：</p><blockquote><ul><li><a href="http://music.163.com/#/song?id=734287" target="_blank" rel="noopener">GARNET CROW - 《夢みたあとで》</a></li><li><a href="http://music.163.com/#/song?id=34852492" target="_blank" rel="noopener">nero - 《831143》</a></li><li><a href="http://music.163.com/#/song?id=677804" target="_blank" rel="noopener">ZARD - 《運命のルーレット廻して》</a></li><li><a href="http://music.163.com/#/song?id=28996833" target="_blank" rel="noopener">软木 - 《secret base》</a></li><li><a href="http://music.163.com/#/song?id=28940048" target="_blank" rel="noopener"> Supper Moment - 《无尽》</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017年我到底都做了什么？</title>
      <link href="/2018/01/19/2017%E6%88%91%E5%88%B0%E5%BA%95%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2018/01/19/2017%E6%88%91%E5%88%B0%E5%BA%95%E9%83%BD%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>习惯地，从大学开始，每一年结束后，也就是期末完了之后的寒假期间，都会多多少少写点年度总结，不然都不知自己这一年浑浑噩噩怎么度过的……</p><blockquote><ul><li>Everyone is struggling everyday.</li></ul></blockquote><h3 id="1-2017任务清单"><a href="#1-2017任务清单" class="headerlink" title="1- 2017任务清单"></a>1- 2017任务清单</h3><p>从16年开始，在每年的开始，都会初步列出下一年的任务清单。当然，清单也会在下一年期间更新。</p><ul><li>2017任务清单<ol><li>书单<ul><li>《数据结构与算法分析（C语言描述）》</li><li>《一站式C编程》</li><li>《大辞海-哲学卷》</li><li><del>《Python编程入门与实践》</del></li><li><del>《Python简明教程》</del></li><li><del>《OpenCV3编程入门》</del></li><li><strong>以下为小说，喜马拉雅听书</strong></li><li><del>《只有你听到-乙一》</del></li><li><del>《zoo-乙一》</del></li><li><del>《献给死者的音乐-乙一》</del></li><li><del>《全部成为F-森博嗣》</del></li><li><del>《寂寞的频率-乙一》</del></li><li><del>《夏日，烟火，我的尸体-乙一》</del></li><li><del>《平面狗-乙一》</del></li></ul></li><li>项目idea（至少完成5项）<ul><li><del>Eason网易云歌曲爬虫。1- 爬取网易云音乐Eason歌曲歌词文本，以及热门评论&amp;最新评论，文本分析得到词云图、词频图&amp;情绪分析图。2- 爬取网易云音乐Eason所有歌曲对应的评论数，并进行排名。</del></li><li><del>emoji官网图片爬虫。爬取emoji官网所有emoji图片，并按原官网分类进行归类。</del></li><li><del>QQ空间爬虫。1- 爬取个人空间所有说说，文本分析得到Top30词频词语、年度关键词&amp;年度关键标点符号，说说数量时间分析。2- 爬取好友QQ空间说说，分析同上。</del></li><li>无人机 + 三维建模 项目</li><li>无人机基于GPS路径导航规划</li><li>利用树莓派做狗型机器人</li><li>DSP音频模拟器。将自己的声音处理转换为Eason的声音（Eason项目的一部分）</li><li>自动接垃圾的垃圾桶</li></ul></li><li>日常计划<ul><li><del>用自己的钱买一部新电脑，配置：i5+GTX960以上，适合计算机方面编程工作。（奖学金+兼职，暗影2pro）</del></li><li><del>自己搭建个人blog网站（Eajack Blog）</del></li><li>用自己的钱，淘宝买一架无人机（仅用于拍照，可附加实时传送图片功能，目的在于个人项目：无人机 + 三维重建）</li></ul></li><li>学业计划<ul><li><del>以一作发表1篇B类论文（目前：B类1作2篇，B类6作一篇）</del></li><li>以二作发表一篇B类论文</li><li>争取发一篇EI论文（A类）</li><li>争取申请一项专利</li></ul></li><li>锻炼计划<ul><li>稳定体重55 - 60kg（目前61.2kg，一般维持在62 - 64kg，2018/1/19）</li><li>瘦小腿，到30cm，大腿到45cm</li><li>跑步打卡 &gt; 200天（132天）</li></ul></li></ol></li></ul><p>以上为2017年的任务清单（包括了一开始的任务以及后来添加的任务），画删除线的为已经完成的。发现，有很多任务都还没完成啊。的确，flag真的是个永远都有的东西。</p><blockquote><ul><li>Flags are endless.</li></ul></blockquote><p>2018年任务清单计划将会延续17年未完成任务，2018任务清单也要开始整理了…</p><h3 id="2-2017年此外的收获"><a href="#2-2017年此外的收获" class="headerlink" title="2- 2017年此外的收获"></a>2- 2017年此外的收获</h3><p>回想2017，有什么值得回忆的呢？此刻能想到多少就写多少回忆吧。</p><p><strong>1月</strong>大二上考完期末，到了大二下寒假，数模美赛。最终拿了国际二等奖（Honorable Mention)，队友们都觉得都能拿一等的（M奖），谁知结果也就那样，多少有些失望，但是也就那样吧。还记得当时刷美赛表情包，很好玩。美赛完，第二天刚好赶上高三班聚，最后一个到场，2年不见，大家都变了很多，还拍照留念。</p><p><strong>2月</strong>大二上寒假。记得是在玩了很久？具体忘了。也在自学数据结构&amp;算法，看C语言书籍好像。<br>寒假，大学冬宣（自己没参与）回高中看了一次学校。</p><p><strong>3~6月</strong>大二下开始，日常开始注意课内平时学习（因为大二上感觉平时看书时间变少了，现在想想，这学期大三上看书也少了很多，也就导致考得这么渣吧……）。申了个大创（后来通过是国创）和挑战杯（三等奖立项）。开始泡基地，一直至今。这段时间 = 日常复习课内知识 + 学习Python（爬虫）+  M道出游、活动。</p><p><strong>7月</strong>大二下期末考完，记得挺吃力，虽然平时有看书。但最后绩点成绩有点出乎意料又符合自己意愿，心里很满足，现在想想，大概大二下的绩点应该会是大学4年最高的一次了，想想这学期，是真的呵呵，超级无语，超级无奈。都过去了，就那样吧，只能祈祷了，转鲤鱼hhh。</p><p><strong>8月</strong>暑假开始，基本整个暑假都在做大创项目（那时候知道是国创和挑战杯3等奖了）。还有学车，科目2竟然没过，就来学校了，大概我大学毕业才能拿得到驾照吧。。hhh。此外，还进一步学了Python。</p><p><strong>9月</strong>大三上开始。我也知道，这是最关键的一个学期，可是我真的没想到，这学期期末崩了，虽然成绩还没出全，但我感觉会崩的比较厉害，有可能是大学期间最崩的一次吗？（仅猜测，但还是继续祈祷啊啊啊啊啊）。9月，相当忙。9月 = 数模国赛（这次终于拿了国二，虽然没有国一，也满足了） + 大创中期答辩准备（包括报销等）。基本这2件事就已经充斥了整个9月份，真的相当忙，记得当时一开学那个月真的超累。还有一件小事，也是这次比赛开始，我喜欢上了一位女生，国赛后约出去玩，刚好那时碰上我生日，她约我出去吃饭算是过了生日。一开始很开心，虽然我觉得她好像不喜欢我，但又有点疑惑。但最后还是决定了，表白吧。</p><p><strong>10月</strong>9月份，基本没看过课内课本。10月份开始学习课内，但这不是最主要的回忆。10月初，国庆，刚好她生日也是国庆期间。本来打算国庆前约她出来玩帮她提前过生日，表白好了，但说推迟到国庆之后。国庆回来后，虽然我也发现了她开始躲避我的样子，但还是决定表白吧，可不可以都算了。约了出来吃饭、看电影，她拉了个师妹，我知道是尴尬吧。师妹也知道我的心思，后来一天晚上，还是表白了。一起学习完回去路上，傻乎乎的我硬塞了个写了一晚上的信给她，说了几句就匆匆走了。当然，那晚12:30，她微信拒了我，好人牌，说了很多话。那晚的聊天都截图保存了。幸亏现在也还算朋友。那晚本来以为3点都睡不着，谁知，1点多睡着了。后来，和好友倾诉，缓了好一段时间。那段时间，学习都被耽搁了啊，哎，真的不该。</p><p><strong>11月</strong>继续缓和心情，又一定程度上影响学习，这学期的课内学习真的被耽搁了。也开始了大创进度。这个月，主要都是在学课内，课外基本很少碰了。</p><p><strong>12月</strong>复习周，史上最恐怖复习考试周，真的是相当恐怖，不单止是因为考试，还有其他事情。2017.12 ~ 2018.1的考试复习周，也就是到现在为止的时间，我经历了什么呢？12月初，还在搞着郭老师的车厢异常检测项目，全面复习还没开始，想想是真的可怕。之后开始复习，逐科复习，特别最恐怖的马哲（马哲恐怖之处不仅在于老师改卷，更在于它对其他科目复习进度&amp;考试精力的影响，这门课应该是我大学4年最恐怖的一门课了吧）。之后，一件令我哭了好几次的事发生了。平安夜开始，我妈重病一场，去医院打点滴、一两天内不能诊断出是什么病，就全身无力劳累、无法下床、头痛等，那一周刚好复习周，这一次导致我复习周都没心思了，一天和爸、外婆、爷爷、妈妈通话好几次，哭了好几次，我知道爸也哭了，十分记得爸爸说“医生说可能病毒入侵了，有病毒入脑了，什么淋巴病毒”，那天下午，我刚上完马哲重点课，报完项目经费，听到后在日月湖忍不住哭了，也听到了爸在抽泣，我说“没事的，很快就知道什么病了，这样就好了”。终于，后来幸亏检测出什么病了，一种很罕见的病，名字是英文名，我知道病名后马上百度，也真的幸亏网上说可以治愈，当时马上松了口气。之后复习周，都和家里人通话，哭了好几次，幸亏现在妈也好了很多。那段时间真的，身心煎熬，在最恐怖的一个复习考试周发生这种事情。还有一件糟心事，也是在复习周后期，她突然脱单了，我当时也没有很大冲击，就一两天缓缓就过去了，当时在复习根本理不了这些小事（算是小事吧…）。</p><p>总的来说，这个大三上期末期间，真的是相当身心煎熬的一次。家里的突然，一周哭了好几次，心情相当低落；爆炸的复习，连续3天2、3点睡觉（之前复习周都没有试过）；她的突然脱单。。可以说，这个狗血剧情，真的电视剧才有吧，这段时间，太恐怖了，大概是老天爷给我的考验，也是最糟心的一次年末了，记忆深刻的一次年末。</p><h3 id="3-2018来了"><a href="#3-2018来了" class="headerlink" title="3- 2018来了"></a>3- 2018来了</h3><p>2018，来了。这一年，应该要比2017更艰难。</p><p>这一年，应该是大学最艰难的一年了吧。既然你选择了想要保研这条路，那这一年的所有将会是你大学期间另一个最有怀念价值的拼搏时期。尽我全力，破釜沉舟，背水一战，只求今年9月笑逐颜开。2018年，希望，你做好充分准备，心理准备。</p><p>2018的清单，也要腾时间出来整理了……</p>]]></content>
      
      
      <categories>
          
          <category> 鸡汤 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 鸡汤 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《C++ Primer（第五版）》中文版学习笔记（1）</title>
      <link href="/2017/10/10/%E3%80%8AC++%20Primer%EF%BC%88%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%89%E3%80%8B%E4%B8%AD%E6%96%87%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/10/10/%E3%80%8AC++%20Primer%EF%BC%88%E7%AC%AC%E4%BA%94%E7%89%88%EF%BC%89%E3%80%8B%E4%B8%AD%E6%96%87%E7%89%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong> Series ：《C++ Primer（第五版）》中文版学习笔记 </strong></p><h3 id="第1章-开始"><a href="#第1章-开始" class="headerlink" title="第1章 开始"></a>第1章 开始</h3><ul><li>C++ 标准输入输出流库：<code>iostream</code><ul><li>cin：标准输入</li><li>cout：标准输出</li><li>cerr：输出警告&amp;错误消息</li><li>clog：输出程序运行时一般信息</li></ul></li></ul><pre><code class="lang-cpp">// 示例代码：#include &lt;iostream&gt;int main(){    std::cout &lt;&lt; &quot;Enter 2 numbers:&quot; &lt;&lt; std::endl;    int v1 = 0, v2 = 0;    std::cin &gt;&gt; v1 &gt;&gt; v2;    std::cout &lt;&lt; &quot;The sum of &quot; &lt;&lt; v1 &lt;&lt; &quot;and&quot; &lt;&lt; v2              &lt;&lt; &quot; is &quot; &lt;&lt; v1 + v2 &lt;&lt; std::endl;    return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eason Projects</title>
      <link href="/2017/10/05/Eason%20Projects/"/>
      <url>/2017/10/05/Eason%20Projects/</url>
      
        <content type="html"><![CDATA[<p>作为一个Eason Fan，连写代码、做项目也是喜欢在Eason上面花心思的……</p><h3 id="1-intro"><a href="#1-intro" class="headerlink" title="1.intro"></a>1.intro</h3><p>汇总目前我做过的关于Eason（陈奕迅）的项目，包括以下几个</p><blockquote><ul><li><a href="https://github.com/Eajack/py_spider/blob/master/%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB/Eason_Film.py" target="_blank" rel="noopener">Eason_Film.py</a>：爬取豆瓣所有Eason电影列表</li><li><a href="https://github.com/Eajack/py_spider/tree/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics" target="_blank" rel="noopener">music163_EasonLyrics</a>：网易云平台Eason所有单曲歌词爬虫，文本分析</li><li><a href="https://github.com/Eajack/py_spider/tree/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments" target="_blank" rel="noopener">music163_EasonComments</a>：网易云平台Eason所有单曲评论数、热门评论&amp;最新10条评论爬虫，文本分析</li></ul></blockquote><h3 id="2-结果分析"><a href="#2-结果分析" class="headerlink" title="2.结果分析"></a>2.结果分析</h3><h4 id="2-1-Eason-Film"><a href="#2-1-Eason-Film" class="headerlink" title="2.1 Eason_Film"></a>2.1 Eason_Film</h4><p>一共爬取到<strong>67</strong>部电影，详见<a href="https://github.com/Eajack/py_spider/blob/master/%E9%9D%99%E6%80%81%E7%88%AC%E8%99%AB/Eason%E7%94%B5%E5%BD%B1.txt" target="_blank" rel="noopener">Eason电影.txt</a></p><h4 id="2-2-music163-EasonLyrics"><a href="#2-2-music163-EasonLyrics" class="headerlink" title="2.2 music163_EasonLyrics"></a>2.2 music163_EasonLyrics</h4><h5 id="2-2-1-歌词"><a href="#2-2-1-歌词" class="headerlink" title="2.2.1 歌词"></a>2.2.1 歌词</h5><p>一共爬取到<strong>536</strong>首歌歌词（去重），歌词txt文件详见<a href="https://github.com/Eajack/py_spider/tree/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/Lyrics" target="_blank" rel="noopener">Lyrics</a></p><h5 id="2-2-2-结果图片"><a href="#2-2-2-结果图片" class="headerlink" title="2.2.2 结果图片"></a>2.2.2 结果图片</h5><p>图片结果如下：</p><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/resultsPNGs/EasonLyricsCloud.png" alt="Eason歌词词云图" title="Eason歌词词云图"></p><p>上图为歌词词云图</p><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/resultsPNGs/%E5%89%8D30%E8%AF%8D%E9%A2%91%E6%9F%B1%E5%BD%A2%E5%9B%BE.png" alt="TOP 30词频柱形图" title="TOP 30词频柱形图"></p><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/resultsPNGs/%E5%89%8D30%E8%AF%8D%E9%A2%91%E9%A5%BC%E7%8A%B6%E5%9B%BE.png" alt="TOP 30词频饼状图" title="TOP 30词频饼状图"></p><p>由上述二图分析可知，词频最高的词语为<strong>“没有”</strong>，其次为“一个”、“我们”等</p><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/resultsPNGs/%E6%83%85%E7%BB%AA%E5%88%86%E6%9E%90%E6%8A%98%E7%BA%BF%E5%9B%BE.png" alt="情绪分析折线图.png" title="情绪分析折线图"></p><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/resultsPNGs/%E6%83%85%E7%BB%AA%E5%88%86%E6%9E%90%E6%AF%94%E4%BE%8B%E9%A5%BC%E7%8A%B6%E5%9B%BE.png" alt="情绪分析比例饼状图.png" title="情绪分析比例饼状图.png"></p><p>上述二图为情绪分析指数结果图，由于运用的是snownlp库，但该库是主要针对商品评论做的情感分析库……未免与实际情况有所偏差。结果分析得知歌词情绪分析指数呈“两边低，中间高”分布，评分多集中在0.5~0.8，评分越高，说明歌曲的积极程度越高。同时，取情绪指数 &gt;= 0.6的作为正面情绪，统计出比例，并做出饼状图，发现Eason的歌<strong>正面情绪歌曲竟然占比67%</strong>……看来Eason唱的歌还是挺积极的啊……</p><h4 id="2-3-music163-EasonComments"><a href="#2-3-music163-EasonComments" class="headerlink" title="2.3 music163_EasonComments"></a>2.3 music163_EasonComments</h4><h5 id="2-3-1-评论数据分析"><a href="#2-3-1-评论数据分析" class="headerlink" title="2.3.1 评论数据分析"></a>2.3.1 评论数据分析</h5><p><strong>截止2017.10.3凌晨</strong>（具体忘了时间），一共爬取到<strong>5451</strong>条热门评论，详见<a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/resultXLS/hotComments.xls" target="_blank" rel="noopener">hotComments.xls</a>；爬取最新10条评论，共<strong>8492</strong>条，详见<a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/resultXLS/Newcomments.xls" target="_blank" rel="noopener">Newcomments.xls</a>；爬取到<strong>858</strong>首单曲以及对应的网易云单曲ID，详见<a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/resultXLS/songName2ID.xls" target="_blank" rel="noopener">songName2ID.xls</a>；爬取到所有单曲评论数，详见<a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/resultXLS/songName2commentsNum.xls" target="_blank" rel="noopener">songName2commentsNum.xls</a>取前10排行如下：</p><div class="table-container"><table><thead><tr><th>歌名</th><th>评论数</th></tr></thead><tbody><tr><td>陪你度过漫长岁月 - (电影《陪安东尼度过漫长岁月》主题曲)</td><td>79350</td></tr><tr><td>好久不见</td><td>67875</td></tr><tr><td>十年</td><td>60062</td></tr><tr><td>不要说话</td><td>56746</td></tr><tr><td>阴天快乐</td><td>50840</td></tr><tr><td>可以了</td><td>40998</td></tr><tr><td>让我留在你身边 - (电影《摆渡人》爱情版主题曲)</td><td>38108</td></tr><tr><td>淘汰</td><td>36806</td></tr><tr><td>富士山下</td><td>36433</td></tr><tr><td>最佳损友</td><td>34811</td></tr></tbody></table></div><p><strong>评论过1w的歌曲数量仅有38首</strong>，<strong>999+歌曲有241首</strong>，感觉比周董的百万《晴天》以及很多的过万歌差别很远啊……最低评论（去除最新专辑《C’mon in~》的需收费，未公开的《未知track》0评论）歌曲是《美丽有罪 (James Ting Remix)》，仅<strong>1</strong>条评论（应该是版权也没了）</p><h5 id="2-3-2-评论文本分析"><a href="#2-3-2-评论文本分析" class="headerlink" title="2.3.2 评论文本分析"></a>2.3.2 评论文本分析</h5><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/resultsPNGs/%E7%83%AD%E9%97%A8%E8%AF%84%E8%AE%BA%E8%AF%8D%E4%BA%91.png" alt="热门评论词云.png" title="热门评论词云.png"></p><p>上图为热门评论词云图</p><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/resultsPNGs/%E5%89%8D30%E8%AF%8D%E9%A2%91%E6%9F%B1%E5%BD%A2%E5%9B%BE.png" alt="TOP 30词频柱形图.png" title="TOP 30词频柱形图.png"></p><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/resultsPNGs/%E5%89%8D30%E8%AF%8D%E9%A2%91%E9%A5%BC%E7%8A%B6%E5%9B%BE.png" alt="TOP 30词频饼状图.png" title="TOP 30词频饼状图.png"></p><p>上述二图为热门评论词频分析图，可知词频最高的是“首歌”（这里jieba分词可能有点问题），之后是“一个”（其实该词属于常用词，照理可以剔除）。因此，在我心目中，词频最高的是“喜欢”，第二是“陈奕迅”，也符合常理啦~~</p><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/resultsPNGs/%E6%83%85%E7%BB%AA%E6%8C%87%E6%95%B0%E6%9B%B2%E7%BA%BF.png" alt="情绪指数曲线.png" title="情绪指数曲线.png"></p><p><img src="https://raw.githubusercontent.com/Eajack/py_spider/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonComments/resultsPNGs/%E6%83%85%E7%BB%AA%E5%88%86%E6%9E%90%E9%A5%BC%E7%8A%B6%E6%AF%94%E4%BE%8B%E5%9B%BE.png" alt="情绪分析饼状比例图.png" title="情绪分析饼状比例图.png"></p><p>情绪分析套路与前面类似，只是在处理文本方面有些许不同。在这里，我们也可以看到snownlp库的不足了……（虽然也不知道是不是对的，但感觉上不是十分靠谱）。此处情感曲线呈类似指数函数趋势（这结果也是厉害……），正面情绪评论比重为76%，此处不多做分析。</p><h3 id="3-New-Ideas"><a href="#3-New-Ideas" class="headerlink" title="3.New Ideas"></a>3.New Ideas</h3><p>以上是目前关于做过的关于Eason的项目，比较偏软件方面，均为Python爬虫。此外，作为Eason Fan，我是十分羡慕Eason的歌喉的。个人有一个长远Project：做一个DSP音频处理器（软件 or 硬件），将自己的声音处理变成Eason的声音。由于个人认为该项目难度相当大，所以作为一个长期Project，或许几年之后才能做出了，但希望自己能坚持做。具体项目细节、所需技术&amp;目标等还没细想，之后开工后会继续慢慢想着</p><h3 id="4-More"><a href="#4-More" class="headerlink" title="4.More"></a>4.More</h3><p>Python爬虫项目玩了有一阵子了，从暑假开始玩，现在也该不玩了。个人所有Py3爬虫项目以及思路、结果等在GitHub：<a href="https://github.com/Eajack/py_spider" target="_blank" rel="noopener">py_spider</a>，也不是很牛逼的东西，纯属娱乐~~</p><p>现在要开坑CV + 算法了……希望，如果有人看到这文章，有点子或者想讨论的可以多多评论留言~~</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
            <tag> Eason </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>あの顷～ジンジンバオヂュオニ～- whiteeeen歌词（罗马音）</title>
      <link href="/2017/10/05/%E3%81%82%E3%81%AE%E9%A1%B7%EF%BD%9E%E3%82%B8%E3%83%B3%E3%82%B8%E3%83%B3%E3%83%90%E3%82%AA%E3%83%82%E3%83%A5%E3%82%AA%E3%83%8B%EF%BD%9E-%20whiteeeen%E6%AD%8C%E8%AF%8D%EF%BC%88%E7%BD%97%E9%A9%AC%E9%9F%B3%EF%BC%89/"/>
      <url>/2017/10/05/%E3%81%82%E3%81%AE%E9%A1%B7%EF%BD%9E%E3%82%B8%E3%83%B3%E3%82%B8%E3%83%B3%E3%83%90%E3%82%AA%E3%83%82%E3%83%A5%E3%82%AA%E3%83%8B%EF%BD%9E-%20whiteeeen%E6%AD%8C%E8%AF%8D%EF%BC%88%E7%BD%97%E9%A9%AC%E9%9F%B3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>网易云评论：</li><li>summer海芋：2012年1月电影《那些年》的主题曲，由木村充利作曲，九把刀作词，胡夏演唱，收录在《那些年，我们一起追的女孩》电影原声带以及胡夏第二张个人专辑《燃点》中。2015年10月被日本歌手whiteeeen翻唱 </li></ul></blockquote><h4 id="来源：百度知道"><a href="#来源：百度知道" class="headerlink" title="来源：百度知道"></a>来源：<a href="https://zhidao.baidu.com/question/1240473122105477739.html" target="_blank" rel="noopener">百度知道</a></h4><pre><code>** あの顷～ジンジンバオヂュオニ～ **** 歌：whiteeeen **** 词：Jiu Ba Dao, Ayume Yamashita, JIN **** 曲：Chong Li Mu Cun **** part 1 **月日が流れて  溢れたす思いてtsukihi ga nagarete ahuredasu omoite无邪気な君の笑颜mujakina kimi no egao少年は今日ネクタイしてshounen ha kyoo nekutai shite少女との誓いを立てるshoujyo to no chikai wo tateru镜を见つめて　落ち着きなくしてkagami wo mitsumete ochitsuki nakushite着饰る君はきっとkikazaru kimi ha kittoこれまでで一番　绮丽な姿をkoremade de ichiban kirei na sugata wo仆に见せてくれるんだろうboku ni misetekure rundarouあの顷に戻れるならanokoro ni modorerunaiまた君の前の席に座るんだmatakimi no mae no sekini suwarundaもう一度君に恋をしてmou ichido kimini koiwoshiteいだずらをしかってitazura wo shigatte风が吹く季节　すれ违った恋kazega fuku kisetsu sure chigatta koi言い出せず　思い闭じ込めたiidasezu  omoitojikometa君はいつだってそう仆のすべてkimi ha itsu tatte sou boku no subeteこの世界中にただ一人kono sekaijyu ni tada hitoriできるだけ强く　ああ抱きしめたいdekiru dake tsuyoku aa dakishimedai辉く満天の夜空にkagayaku manten no yozora ni汚れなき仆ら二人で交わしたkegarenaki boku ra futari de kawashitaあの约束を忘れないano yakusoku wo wasurenaiジンジンバオヂュオニjin jin bao zhe ni** part 2 **なれない手つきで　髪を整えてnarinai te tsukise kami wo totonoete背伸びした立ち姿senobishi tadachi sugata君は笑うのかな？　笑ってくれるかな？kimi ha warau no ganawaratte kureru kana喜ぶ颜がみたいのyorokobu kao ga mitaino黒板の数式すら　kokuban no suushiki suraそっちのけで　ふざけあっていたよねsocchi no kedefuzakeatteitayone隣に座る谁もが皆tonari ni suwaru daremoga mina君に恋してたよkimi ni koite tayoいつも思い出す君が离れないitsumo omoidasu kimiga hanare nai何も手につかないくらいにdaremo teni tsukanaiku naini仆も呼ぶ声も弾ける笑颜もbokumo yobu koemo hajikeru egaomoいますぐ君にただ会いたいimasugu kimini tada aitai儚く散りゆくあの流れ星にhakanaku chiriyuku ano nagare hoshi ni何度も何度も愿ったよnandomo nandomo negatta yo小さな幸せ届け未来までchi i sana shiawase tedoke mirai made止まった记忆そのままにああずっとtomatta kioku sono mamaniaa zutto风が吹く季节　すれ违った恋kazega fuku kisetsu sure chigatta koi言い出せず　思い闭じ込めたiidasezu  omoitojikometa君はいつだってそう仆のすべてkimi ha itsu tatte sou boku no subeteこの世界中にただ一人kono sekaijyu ni tada hitoriできるだけ强く　ああ抱きしめたいdekiru dake tsuyoku aa dakishimedai辉く満天の夜空にkagayaku manten no yozora ni汚れなき仆ら二人で交わしたkegarenaki boku ra futari de kawashitaあの约束を忘れないano yakusoku wo wasurenaiジンジンバオヂュオニjin jin bao zhe ni</code></pre>]]></content>
      
      
      <categories>
          
          <category> Songs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>知乎语录</title>
      <link href="/2017/09/24/%E7%9F%A5%E4%B9%8E%E8%AF%AD%E5%BD%95/"/>
      <url>/2017/09/24/%E7%9F%A5%E4%B9%8E%E8%AF%AD%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>收录在知乎上感触的语句<br>keep updating……</p><h5 id="怎样才算真正喜欢一个人？"><a href="#怎样才算真正喜欢一个人？" class="headerlink" title="怎样才算真正喜欢一个人？"></a><a href="https://www.zhihu.com/question/60916632/answer/182975309" target="_blank" rel="noopener">怎样才算真正喜欢一个人？</a></h5><blockquote><ul><li>作者：阆苑仙葩林带鱼</li><li>那天我在巷口看到一棵长得怪异的榕树，<br>当我的第一反应是拍给你看的时候，<br>我就知道大事不妙了。<br>（出处不明）</li></ul></blockquote><h5 id="清华电子信息或者北大信息科学技术学院应该怎么选？"><a href="#清华电子信息或者北大信息科学技术学院应该怎么选？" class="headerlink" title="清华电子信息或者北大信息科学技术学院应该怎么选？"></a><a href="https://www.zhihu.com/question/61645207/answer/191380481" target="_blank" rel="noopener">清华电子信息或者北大信息科学技术学院应该怎么选？</a></h5><blockquote><ul><li>作者：吴辰晔</li><li>电子系的老师，喜欢聊信号，把图像看成信号，把语音看成信号，把文字也看成信号，希望把整个世界都变成信号，然后用滤波器一类的手段，从时域频域开始分析，处理。</li></ul></blockquote><h5 id="大学里面究竟是学习重要还是人际关系重要？大学到底是学习什么？"><a href="#大学里面究竟是学习重要还是人际关系重要？大学到底是学习什么？" class="headerlink" title="大学里面究竟是学习重要还是人际关系重要？大学到底是学习什么？"></a><a href="https://www.zhihu.com/question/26125708/answer/68279043" target="_blank" rel="noopener">大学里面究竟是学习重要还是人际关系重要？大学到底是学习什么？</a></h5><blockquote><ul><li>作者：徐佳鑫</li><li>总有一天，我们会走出校园，我们会把所有课堂上学到的知识忘光。通识教育也不例外，但学习的意义不在于记住和没记住，恰在于知道和不知道</li></ul></blockquote><h5 id="你是什么时候发现自己老了？"><a href="#你是什么时候发现自己老了？" class="headerlink" title="你是什么时候发现自己老了？"></a><a href="https://www.zhihu.com/question/28227804/answer/135325847" target="_blank" rel="noopener">你是什么时候发现自己老了？</a></h5><blockquote><ul><li>作者：曾加</li><li>在决定放弃的那一刻，我突然发现，自己和以前不一样了：<br>过去的我，在遇到自己最感兴趣的问题（比如好玩的数学题）时，一定会打破砂锅问到底，无论自己有多忙，或是多么没思路，我一直会对它念念不忘，最终让自己逼近真相：要么亲自解决这个问题，要么知道有人解决了它，或是人类还没有解决它但现在，在我最喜欢的东西面前，我竟然也开始退却了：我开始为自己「放弃」寻找各种各样的理由——工作太忙、问题太难，或是问题的解决对我而言并无意义……我渐渐地开始不再因为「好奇心」而去做一件事情，却开始在乎所谓的「效率」和「意义」。<br>我知道，知难而退、懂得取舍、不钻牛角尖的我更像一个普通人或正常人，但却也明白，在我决定放弃的那一刻，我便不再是原来的我了。当我们说一个人老了的时候，有时并不是指他在身体机能上的老去，而是指，他不再拥有年轻人的心气。也许，我的老去，就发生在我放弃自己最喜欢事物的一瞬间。</li></ul></blockquote><h5 id="北京邮电大学是一所怎样的学校？"><a href="#北京邮电大学是一所怎样的学校？" class="headerlink" title="北京邮电大学是一所怎样的学校？"></a><a href="https://www.zhihu.com/question/53256995/answer/134241965" target="_blank" rel="noopener">北京邮电大学是一所怎样的学校？</a></h5><blockquote><ul><li>作者：晟气凌人</li><li>计科这个专业，放眼全世界，都是一个很靠自学的专业，说实在的，教师和教材在这个专业中起到的作用并没有那么大，入门了之后，你最后的高度，取决于你的意念、努力程度和在写代码上花的时间。</li></ul></blockquote><h5 id="你做过的最能反映你应试能力的一件事是什么？"><a href="#你做过的最能反映你应试能力的一件事是什么？" class="headerlink" title="你做过的最能反映你应试能力的一件事是什么？"></a><a href="https://www.zhihu.com/question/63531778/answer/210148962" target="_blank" rel="noopener">你做过的最能反映你应试能力的一件事是什么？</a></h5><blockquote><ul><li>作者：鬼谷弈邪</li><li>平时则放荡冶游，考试则熟读讲义，不问学问之有无，惟争分数之多寡；试验既终，书籍束之高阁，毫不过问，敷衍三四年，潦草塞责，文凭到手，即可借此活动于社会，岂非与求学初衷大相背驰乎？光阴虚度，学问毫无，是自误也。<br>——蔡元培</li></ul></blockquote><h5 id="恋人之间的最好状态是怎样的？"><a href="#恋人之间的最好状态是怎样的？" class="headerlink" title="恋人之间的最好状态是怎样的？"></a><a href="https://www.zhihu.com/question/31997695/answer/192428185" target="_blank" rel="noopener">恋人之间的最好状态是怎样的？</a></h5><blockquote><ul><li>作者：Charles Wang</li><li>1、伴侣是自己最好的朋友</li><li>2、聊得来</li><li>3、和对方在一起可以有效的降低焦虑</li><li>4、共处一室各自做事情，不会感到被打扰，也不会感到冷场</li><li>5、对方能引起自己强烈的性欲</li><li>6、双方可以坦诚自己的性癖好</li><li>7、三观相合，遇到不同见解时，能够求同存异</li><li>8、双方均财务独立</li><li>9、双方都不是因为想恋爱才和对方在一起</li><li>10、互相欣赏、共同学习进步</li><li>传说中的 第11条</li><li>——因为爱，你想要成为一个更好的人。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 心情 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>831143-nero 歌词（罗马音）</title>
      <link href="/2017/09/22/831143-nero%20%E6%AD%8C%E8%AF%8D%EF%BC%88%E7%BD%97%E9%A9%AC%E9%9F%B3%EF%BC%89/"/>
      <url>/2017/09/22/831143-nero%20%E6%AD%8C%E8%AF%8D%EF%BC%88%E7%BD%97%E9%A9%AC%E9%9F%B3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>网易云评论：</li><li>貝諾馬尼亞公爵丶:一共8个字母，3个单词，表达同1个含义。<br>那就是<br>I（1个字母）<br>LOVE（4个字母） YOU（3个字母） 我爱你。 ——831143 </li></ul></blockquote><h4 id="来源：百度知道"><a href="#来源：百度知道" class="headerlink" title="来源：百度知道"></a>来源：<a href="https://zhidao.baidu.com/question/492188440949911092.html" target="_blank" rel="noopener">百度知道</a></h4><pre><code>**831143 - nero****Part 1 :**初めて仆と出会った日を君は覚えてる？hajimete boku to deatta hi wo kimi wa oboeteru? 偶然がもたらした小さな奇迹だguuzen ga motarashita chiisana kiseki da 君にはちょっと照れくさくって话してないけどkimi ni wa chotto terekusaku tte hanashite nai kedo 今覚えば仆の一目惚れだったなima omoeba boku no hitomebore datta na いろんな事があってironna koto ga atte 二人で笑って泣いてfutari de waratte naite その全てが大切な宝物なんだsono subete ga taisetsu na takaramono nanda 何にも言わないで黙って闻いて仆がする话をnannimo iwanaide damatte kiite boku ga suru hanashi wo 背中越しの手に隠しているこの包みと共にsenakagoshi no te ni kakushiteiru kono tsutsumi to tomo ni 君が喜んでくれるかどうか少し不安だけどkimi ga yorokonde kureru ka dou ka sukoshi fuan dakedo これからも爱を捧げてたいのはやっぱり君なんだkorekara mo ai wo sasagetetai no wa yappari kimi nanda **Part 2 :**待ちきれなくて少し早く目が覚めた朝はmachikire nakute sukoshi hayaku me ga sameta asa wa なんとなくいつもと违う気がしたよnantonaku itsumo to chigau ki ga shita yo 憧れだった梦のような君との未来がakogare datta yume no you na kimi to no mirai ga 现実味を帯びて迎えに来るんだろうgenjitsumi wo obite mukae ni kurun darou ロマンチストなんてromanchisuto nante 性に合わないみたいでshou ni awanai mitai de 洒落た言叶は一つも言えないけれどshareta kotoba wa hitotsu mo ienai keredo 君を呼び出して空に叫んだあの日を思い出すよkimi wo yobidashite sora ni sakenda ano hi wo omoidasu yo はにかむ笑颜で耻ずかしそうに颔いていたっけなhanikamu egae de hazukashisou ni unazuiteita kke na 震える手をぎゅっと握り缔めてもう一度伝えようfurueru te wo gyutto nigirishimete mouichido tsutaeyou 今でも変わらない仆の想いを同じ台词でima demo kawaranai boku no omoi wo onaji serifu de **Part 3 :**ついにその瞬间がtsui ni sono shunkan ga 近づいてきたようですchikazuite kita you desu 此処まで来れたのはそう、君のお阴だkoko made koreta no wa sou, kimi no okage da 扉が开いて仆に向かって歩く君の姿tobira ga hiraite boku ni mukatte aruku kimi no sugata どんな颜したら良いのかさえも分からなくなる程donna kao shitara ii no ka sae mo wakaranaku naru hodo 仆の知る限り今日の君が一番绮丽だよboku no shiru kagiri kyou no kimi ga ichiban kirei da yo 涙を堪えて爱を示すように君にキスをしようnamida wo koraete ai wo shimesu you ni kimi ni kisu wo shiyou誓いのキスをchikai no kisu wo</code></pre>]]></content>
      
      
      <categories>
          
          <category> Songs </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设置树莓派开机自启动程序</title>
      <link href="/2017/09/01/%E8%AE%BE%E7%BD%AE%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F/"/>
      <url>/2017/09/01/%E8%AE%BE%E7%BD%AE%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>关于如何设置树莓派开机自启动程序的资料如下：</p><blockquote><ul><li><a href="http://www.jianshu.com/p/1a160067d8fd" target="_blank" rel="noopener">几种设置树莓派开机自启的方法</a></li><li><a href="http://blog.csdn.net/qq_31669419/article/details/53331560" target="_blank" rel="noopener">妙算（树莓派等linux系统）程序开机自启动</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 树莓派 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>music163_EasonLyrics项目</title>
      <link href="/2017/09/01/music163_EasonLyrics%E9%A1%B9%E7%9B%AE/"/>
      <url>/2017/09/01/music163_EasonLyrics%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="1、intro"><a href="#1、intro" class="headerlink" title="1、intro"></a>1、intro</h3><blockquote><p>1)-<a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/EasonLyrics.py" target="_blank" rel="noopener">EasonLyrics.py</a>：Eason网易云歌词爬虫</p><p>2)-<a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/wordsAnalysis.py" target="_blank" rel="noopener">wordsAnalysis.py</a>:</p><ul><li>歌词文本分析，包括jieba分词统计词汇（去单字）</li><li>根据词频生成词云</li><li>词频统计，做柱形图 &amp; 饼状图</li><li>歌词情绪分析简易版demo (饼状图 &amp; 曲线图)</li></ul><p>3)-<a href="https://github.com/Eajack/py_spider/tree/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/Lyrics" target="_blank" rel="noopener">Lyrics</a>:下载的歌词txt文档</p><p>4)-<a href="https://github.com/Eajack/py_spider/tree/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/resultsPNGs" target="_blank" rel="noopener">resultsPNGs</a>:所有分析结果图片汇总</p><p>5)-<a href="https://github.com/Eajack/py_spider/blob/master/%E5%8A%A8%E6%80%81%E7%88%AC%E8%99%AB/music163_EasonLyrics/Eason.jpg" target="_blank" rel="noopener">Eason</a>:Eason图片词云背景图</p></blockquote><h3 id="2、思路"><a href="#2、思路" class="headerlink" title="2、思路"></a>2、思路</h3><h4 id="1）EasonLyrics思路"><a href="#1）EasonLyrics思路" class="headerlink" title="1）EasonLyrics思路"></a>1）EasonLyrics思路</h4><p>获取所有Eason专辑ID =&gt; 遍历专辑得到单曲ID并过滤同名歌曲 =&gt; 通过api<code>http://music.163.com/api/song/lyric?id=[IDNUM]</code>获得歌词，并储存为txt文件</p><h4 id="2）文本分析思路"><a href="#2）文本分析思路" class="headerlink" title="2）文本分析思路"></a>2）文本分析思路</h4><p>jieba库、wordcloud库、matplotlib库、snownlp库的使用。多百度、google&amp;github。</p><h3 id="3、遇到的问题以及解决思路"><a href="#3、遇到的问题以及解决思路" class="headerlink" title="3、遇到的问题以及解决思路"></a>3、遇到的问题以及解决思路</h3><h4 id="1）爬取歌词思路选择"><a href="#1）爬取歌词思路选择" class="headerlink" title="1）爬取歌词思路选择"></a>1）爬取歌词思路选择</h4><ol><li><strong>bs+urllib</strong>：一开始的时候，原本想通过网站<code>http://music.163.com/#/search/m/?s=陈奕迅</code>翻页遍历。但是发现用bs无法爬取，因为翻页网址没变，但在chrome里面的检查源码变了，但直接用bs+urllib爬不了html源码，只可以得到首页源码（而且后来发现bs爬的源码和chrome端不一样，因为html里面嵌入了frame，需要selenium库转换frame）</li><li><strong>selenium模拟翻页</strong>：转变思路后，但我还是想通过搜索页翻页爬取。百度发现说，可能是<code>Ajax</code>、js渲染或者的问题（还没学过前端，又不懂），说selenium库可以渲染js，用了下还是想模拟翻页，然而发现<code>set_to_iframe</code>（转换html框架）后还是不行（find到“下一页”的key，但模拟按键<code>click()</code>报错“该地方unclickable”）。因此,又放弃selenium模拟翻页思路。</li><li><strong>破解params&amp;encSecKey</strong>：随后在chrome端的Neteworks发现XHR有该页歌曲的歌名、ID等所有信息，因此觉得只要爬取这个XHR就行了。然而，之后在百度时发现说网易云api参数param有ASE加密，看一下这个XHR的Headers下部果然有<br>Form data请求参数params&amp;encSecKey，不过明显看出是加密的动态密码。搜了知乎有人破解过，github上也有人破解。不过想了下感觉好难就放弃了。</li><li><strong>专辑ID =&gt; 单曲ID =&gt; api获取歌词</strong>：最后，还是选择了另一种思路，就是现在的思路，结合了selenium库的<code>set_to_iframe</code>。</li></ol><h4 id="2）其余"><a href="#2）其余" class="headerlink" title="2）其余"></a>2）其余</h4><ol><li>文本分析方面，多google、github、看文档等就行了。有常见的歌词文本分析方向可以搜索。</li><li>经典的 utf-8(unicode) =&gt; gbk 编码问题（代码里有注释笔记）</li><li>其余剩下就是Python编程的一些技巧了。主要耗时在爬虫思路的确定以及实现。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python零碎点笔记</title>
      <link href="/2017/08/27/Python%E9%9B%B6%E7%A2%8E%E7%82%B9%E7%AC%94%E8%AE%B0%20/"/>
      <url>/2017/08/27/Python%E9%9B%B6%E7%A2%8E%E7%82%B9%E7%AC%94%E8%AE%B0%20/</url>
      
        <content type="html"><![CDATA[<h3 id="updating-on-2017-8-27"><a href="#updating-on-2017-8-27" class="headerlink" title="updating on 2017/8/27"></a><em>updating on 2017/8/27</em></h3><p><code>整理个人用过的Python零碎的资料</code></p><h3 id="1-Python-windows平台配置汇总"><a href="#1-Python-windows平台配置汇总" class="headerlink" title="1.Python windows平台配置汇总"></a>1.Python windows平台配置汇总</h3><ul><li><a href="http://blog.csdn.net/fx677588/article/details/58164902" target="_blank" rel="noopener">pyCharm最新2017激活码</a></li><li><a href="http://www.cnblogs.com/jesselzj/p/7086521.html" target="_blank" rel="noopener">Windows10+Python3下安装NumPy+SciPy+Matplotlib</a></li></ul><h3 id="2-Python-常用库文档汇总"><a href="#2-Python-常用库文档汇总" class="headerlink" title="2.Python 常用库文档汇总"></a>2.Python 常用库文档汇总</h3><ul><li><a href="http://beautifulsoup.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">Beautiful Soup 4.4.0中文文档</a></li><li><a href="http://docs.python-requests.org/zh_CN/latest/user/quickstart.html" target="_blank" rel="noopener">Requests 2.18.1中文文档</a></li><li><a href="http://www.cnblogs.com/Lands-ljk/p/5447127.html" target="_blank" rel="noopener">Python3学习笔记（urllib模块的使用）</a></li><li><a href="https://python-selenium-zh.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">selenium + python 中文文档</a></li></ul><h3 id="3-Python-常用库安装"><a href="#3-Python-常用库安装" class="headerlink" title="3.Python 常用库安装"></a>3.Python 常用库安装</h3><ul><li><a href="https://github.com/amueller/word_cloud" target="_blank" rel="noopener">wordcloud</a></li></ul><blockquote><p>PS:无VS2015的windows下pip安装wordcloud报错<br><code>Unable to find vcvarsall.bat</code>，不用去装SDK/VS那些，下载对应Python版本的<a href="http://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud" target="_blank" rel="noopener">whl文件</a>。之后，pip install [whl文件名]</p></blockquote><ul><li><a href="http://www.cnblogs.com/jesselzj/p/7086521.html" target="_blank" rel="noopener">Windows10+Python3下安装NumPy+SciPy+Matplotlib</a></li></ul><h3 id="3-正则表达式"><a href="#3-正则表达式" class="headerlink" title="3.正则表达式"></a>3.正则表达式</h3><ul><li><a href="http://tool.oschina.net/regex/" target="_blank" rel="noopener">在线正则表达式测试</a></li><li><a href="https://www.w3cschool.cn/regexp/tfua1pq5.html" target="_blank" rel="noopener">W3Cschool 正则表达式</a></li></ul><h3 id="4-Python相关教程"><a href="#4-Python相关教程" class="headerlink" title="4.Python相关教程"></a>4.Python相关教程</h3><ul><li><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰Python3教程</a></li><li><a href="http://cuiqingcai.com/1052.html" target="_blank" rel="noopener">Python爬虫学习系列教程-静觅</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日常小技巧总结</title>
      <link href="/2017/08/16/%E6%97%A5%E5%B8%B8%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
      <url>/2017/08/16/%E6%97%A5%E5%B8%B8%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="updating"><a href="#updating" class="headerlink" title="updating"></a><em>updating</em></h3><h3 id="1-windows批量重命名去括号"><a href="#1-windows批量重命名去括号" class="headerlink" title="1. windows批量重命名去括号"></a>1. windows批量重命名去括号</h3><p>2017/8/16，最近在忙着OpenCV物体识别的项目，需要收集训练图片，因此要重命名，谁知生成XML文件时，报错XML的key不可以有”()”符号，因此百度了以下技巧，做下笔记。</p><pre><code class="lang-.bat">@Echo Off&amp;SetLocal ENABLEDELAYEDEXPANSIONFOR %%a in (*) do (set &quot;name=%%a&quot;set &quot;name=!name: (=!&quot;set &quot;name=!name:)=!&quot;ren &quot;%%a&quot; &quot;!name!&quot;)exit</code></pre><p>服用方式：先用windows传统批量重命名方式得到一系列带括号文件名，然后把该脚本放在文件夹里，运行。</p>]]></content>
      
      
      <categories>
          
          <category> 杂乱 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV边缘检测</title>
      <link href="/2017/08/09/OpenCV%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/"/>
      <url>/2017/08/09/OpenCV%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<p>Series:<strong>OpenCV学习笔记</strong><br><em>边缘检测</em></p><pre><code class="lang-cpp">/*Author:EajackDate:2017/8/9Series:OpenCV笔记Function:OpenCV边缘检测Key Points:    1、Canny边缘检测步骤:原图转成灰度图 =&gt; blur降噪 =&gt; Canny边缘检测 =&gt; edge作为掩码        Canny(srcImg,edgeImg,double threshlod1,double threshold2)    2、Sobel算子边缘提取步骤: X方向梯度 =&gt; X方向梯度 =&gt; 整体方向梯度                                       [x,y]        X : Sobel(srcImg,sobel_x,CV_16S,1,0,3,1,1,BORDER_DEFAULT);        Y : Sobel(srcImg,sobel_y,CV_16S,0,1,3,1,1,BORDER_DEFAULT);        addWeighted(abs_sobel_x,0.5,abs_sobel_y,0.5,0,sobel_dst);*/#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;opencv2/opencv.hpp&gt;#include&lt;opencv2/highgui/highgui.hpp&gt;#include&lt;opencv2/imgproc/imgproc.hpp&gt;using namespace cv;using namespace std;int main(){    Mat srcImg = imread(&quot;photo.jpg&quot;);    /*1 Canny边缘检测 */    Mat srcClone = srcImg.clone();    Mat dst,edge,gray;    /*原图转成灰度图 =&gt; blur降噪 =&gt; Canny边缘检测 =&gt; edge作为掩码*/    // 创建与src同类型和大小的矩阵(dst)    dst.create(srcClone.size(),srcClone.type());    // 将原图转化为灰度图    cvtColor(srcClone,gray,CV_BGR2GRAY);    //先用3x3 内核降噪    blur(gray,edge,Size(3,3));    //运行Canny算子    Canny(edge,edge,150,50,3);    //设置dst所有元素为0    dst = Scalar::all(0);    // 使用Canny输出edge作为掩码,来将原图srcClone复制到dst    srcClone.copyTo(dst,edge);    imshow(&quot;Canny 边缘检测&quot;,dst);    imwrite(&quot;canny.jpg&quot;,dst);    /*2 sobel边缘检测 */    Mat sobel_x,sobel_y;    Mat abs_sobel_x,abs_sobel_y,sobel_dst;    // X方向梯度    Sobel(srcImg,sobel_x,CV_16S,1,0,3,1,1,BORDER_DEFAULT);    convertScaleAbs(sobel_x,abs_sobel_x);    imshow(&quot;X方向sobel&quot;,abs_sobel_x);    imwrite(&quot;sobel_x.jpg&quot;,abs_sobel_x);    // Y方向梯度    Sobel(srcImg,sobel_y,CV_16S,0,1,3,1,1,BORDER_DEFAULT);    convertScaleAbs(sobel_y,abs_sobel_y);    imshow(&quot;Y方向sobel&quot;,abs_sobel_y);    imwrite(&quot;sobel_y.jpg&quot;,abs_sobel_y);    //合并梯度（近似）    addWeighted(abs_sobel_x,0.5,abs_sobel_y,0.5,0,sobel_dst);    imshow(&quot;整体方向sobel&quot;,sobel_dst);    imwrite(&quot;sobel.jpg&quot;,sobel_dst);    waitKey(0);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV数学形态学</title>
      <link href="/2017/08/08/OpenCV%E6%95%B0%E5%AD%A6%E5%BD%A2%E6%80%81%E5%AD%A6/"/>
      <url>/2017/08/08/OpenCV%E6%95%B0%E5%AD%A6%E5%BD%A2%E6%80%81%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p>Series:<strong>OpenCV学习笔记</strong><br><em>数学形态学</em></p><pre><code class="lang-cpp">/*Author:EajackDate:2017/8/8Series:OpenCV笔记Function:OpenCV数学形态学KeyPoints:    dilate(srcImg,dstImg,element);    erode(srcImg,dstImg,element);    morphologyEx(srcImg,dstImg,MORPH_OPEN,element);    // MORPH_CLOSE,MORPH_GRADIENT,MORPH_TOPHAT,MORPH_BLACKHAT //*/# include &lt;stdio.h&gt;# include &lt;iostream&gt;# include &lt;vector&gt;# include &lt;opencv2/opencv.hpp&gt;# include &lt;opencv2/highgui/highgui.hpp&gt;# include &lt;opencv2/imgproc/imgproc.hpp&gt;using namespace cv;using namespace std;int main(){    Mat frame =imread(&quot;photo.jpg&quot;);    Mat dilate_frame,erode_frame;    Mat open_frame,close_frame,grad_frame,top_frame,black_frame;    Mat flood_frame;    Mat element = getStructuringElement(MORPH_RECT,Size(10,10));    imshow(&quot;原图&quot;,frame);    // start    dilate(frame,dilate_frame,element);    imshow(&quot;膨胀操作&quot;,dilate_frame);    erode(frame,erode_frame,element);    imshow(&quot;腐蚀操作&quot;,erode_frame);    morphologyEx(frame,open_frame,MORPH_OPEN,element);    imshow(&quot;开运算&quot;,open_frame);    morphologyEx(frame,close_frame,MORPH_CLOSE,element);    imshow(&quot;闭运算&quot;,close_frame);    morphologyEx(frame,grad_frame,MORPH_GRADIENT,element);    imshow(&quot;梯度运算&quot;,grad_frame);    morphologyEx(frame,top_frame,MORPH_TOPHAT,element);    imshow(&quot;顶帽运算&quot;,top_frame);    morphologyEx(frame,black_frame,MORPH_BLACKHAT,element);    imshow(&quot;黑帽运算&quot;,black_frame);    Rect buffer;    floodFill(frame,Point(50,300),Scalar(155,255,55),                    &amp;buffer,Scalar(20,20,20),Scalar(20,20,20));    imshow(&quot;漫水填充&quot;,frame);    imwrite(&quot;dilate.jpg&quot;,dilate_frame);    imwrite(&quot;erode.jpg&quot;,erode_frame);    imwrite(&quot;open.jpg&quot;,open_frame);    imwrite(&quot;close.jpg&quot;,close_frame);    imwrite(&quot;grad.jpg&quot;,grad_frame);    imwrite(&quot;top.jpg&quot;,top_frame);    imwrite(&quot;black.jpg&quot;,black_frame);    imwrite(&quot;floodfill.jpg&quot;,frame);    waitKey(0);}</code></pre>]]></content>
      
      
      <categories>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>沃·兹季硕德 名言汇总</title>
      <link href="/2017/07/31/%E6%B2%83%C2%B7%E5%85%B9%E5%AD%A3%E7%A1%95%E5%BE%B7%20%E5%90%8D%E8%A8%80%E6%B1%87%E6%80%BB/"/>
      <url>/2017/07/31/%E6%B2%83%C2%B7%E5%85%B9%E5%AD%A3%E7%A1%95%E5%BE%B7%20%E5%90%8D%E8%A8%80%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<p>Keep updating……</p><p>从前，有个人叫——沃·兹季硕德，曾留下如下名言感悟：</p><blockquote><ul><li>既然在过去输掉了现在，那就要在现在赢得未来。</li><li>每一个不甘心的现在，都有一个从前作为理由。</li><li>Just be yourself and then you will be a giant someday.</li><li>Everyone is struggling everyday.</li><li>……</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 心情 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 简明教程</title>
      <link href="/2017/07/20/Markdown%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
      <url>/2017/07/20/Markdown%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>PS:来源于<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">作业部落</a>在线Markdown编辑器的Markdown语法说明</p><p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p><blockquote><ul><li>整理知识，学习笔记</li><li>发布日记，杂文，所见所想</li><li>撰写发布技术文稿（代码支持）</li><li>撰写发布学术论文（LaTeX 公式支持）</li></ul></blockquote><p><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"></p><p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p><h3 id="Windows-Mac-Linux-全平台客户端"><a href="#Windows-Mac-Linux-全平台客户端" class="headerlink" title="Windows/Mac/Linux 全平台客户端"></a><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="noopener">Windows/Mac/Linux 全平台客户端</a></h3><blockquote><p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class="icon-file"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p></blockquote><hr><h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p><h3 id="1-制作一份待办事宜-Todo-列表"><a href="#1-制作一份待办事宜-Todo-列表" class="headerlink" title="1. 制作一份待办事宜 Todo 列表"></a>1. 制作一份待办事宜 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表" target="_blank" rel="noopener">Todo 列表</a></h3><ul><li>[ ] 支持以 PDF 格式导出文稿</li><li>[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li>[x] 新增 Todo 列表功能</li><li>[x] 修复 LaTex 公式渲染问题</li><li>[x] 新增 LaTex 公式编号功能</li></ul><h3 id="2-书写一个质能守恒公式LaTeX"><a href="#2-书写一个质能守恒公式LaTeX" class="headerlink" title="2. 书写一个质能守恒公式LaTeX"></a>2. 书写一个质能守恒公式<sup><a href="#fn_LaTeX" id="reffn_LaTeX">LaTeX</a></sup></h3><script type="math/tex; mode=display">E=mc^2</script><h3 id="3-高亮一段代码code"><a href="#3-高亮一段代码code" class="headerlink" title="3. 高亮一段代码code"></a>3. 高亮一段代码<sup><a href="#fn_code" id="reffn_code">code</a></sup></h3><pre><code class="lang-python">@requires_authorizationclass SomeClass:    passif __name__ == &#39;__main__&#39;:    # A comment    print &#39;hello world&#39;</code></pre><h3 id="4-高效绘制-流程图"><a href="#4-高效绘制-流程图" class="headerlink" title="4. 高效绘制 流程图"></a>4. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图" target="_blank" rel="noopener">流程图</a></h3><pre><code class="lang-flow">st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op</code></pre><h3 id="5-高效绘制-序列图"><a href="#5-高效绘制-序列图" class="headerlink" title="5. 高效绘制 序列图"></a>5. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图" target="_blank" rel="noopener">序列图</a></h3><pre><code class="lang-seq">Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!</code></pre><h3 id="6-高效绘制-甘特图"><a href="#6-高效绘制-甘特图" class="headerlink" title="6. 高效绘制 甘特图"></a>6. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-甘特图" target="_blank" rel="noopener">甘特图</a></h3><pre><code class="lang-gantt">    title 项目开发流程    section 项目确定        需求分析       :a1, 2016-06-22, 3d        可行性报告     :after a1, 5d        概念验证       : 5d    section 项目实施        概要设计      :2016-07-05  , 5d        详细设计      :2016-07-08, 10d        编码          :2016-07-15, 10d        测试          :2016-07-22, 5d    section 发布验收        发布: 2d        验收: 3d</code></pre><h3 id="7-绘制表格"><a href="#7-绘制表格" class="headerlink" title="7. 绘制表格"></a>7. 绘制表格</h3><div class="table-container"><table><thead><tr><th>项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>计算机</td><td style="text-align:right">$1600</td><td style="text-align:center">5</td></tr><tr><td>手机</td><td style="text-align:right">$12</td><td style="text-align:center">12</td></tr><tr><td>管线</td><td style="text-align:right">$1</td><td style="text-align:center">234</td></tr></tbody></table></div><h3 id="8-更详细语法说明"><a href="#8-更详细语法说明" class="headerlink" title="8. 更详细语法说明"></a>8. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown" target="_blank" rel="noopener">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册" target="_blank" rel="noopener">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p><p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p><hr><h2 id="什么是-Cmd-Markdown"><a href="#什么是-Cmd-Markdown" class="headerlink" title="什么是 Cmd Markdown"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p><h3 id="1-实时同步预览"><a href="#1-实时同步预览" class="headerlink" title="1. 实时同步预览"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p><h3 id="2-编辑工具栏"><a href="#2-编辑工具栏" class="headerlink" title="2. 编辑工具栏"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p><p><img src="https://www.zybuluo.com/static/img/toolbar-editor.png" alt="tool-editor"></p><h3 id="3-编辑模式"><a href="#3-编辑模式" class="headerlink" title="3. 编辑模式"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右侧的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p><h3 id="4-实时的云端文稿"><a href="#4-实时的云端文稿" class="headerlink" title="4. 实时的云端文稿"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p><h3 id="5-离线模式"><a href="#5-离线模式" class="headerlink" title="5. 离线模式"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p><h3 id="6-管理工具栏"><a href="#6-管理工具栏" class="headerlink" title="6. 管理工具栏"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p><p><img src="https://www.zybuluo.com/static/img/toolbar-manager.jpg" alt="tool-manager"></p><p>通过管理工具栏可以：</p><p><i class="icon-share">&lt;/i&gt; 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class="icon-file"></i> 新建：开始撰写一篇新的文稿<br><i class="icon-trash">&lt;/i&gt; 删除：删除当前的文稿<br><i class="icon-cloud"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class="icon-reorder">&lt;/i&gt; 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class="icon-pencil"></i> 模式：切换 普通/Vim/Emacs 编辑模式</i></i></i></p><h3 id="7-阅读工具栏"><a href="#7-阅读工具栏" class="headerlink" title="7. 阅读工具栏"></a>7. 阅读工具栏</h3><p><img src="https://www.zybuluo.com/static/img/toolbar-reader.jpg" alt="tool-manager"></p><p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p><p>工具栏上的五个图标依次为：</p><p><i class="icon-list">&lt;/i&gt; 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class="icon-chevron-sign-left"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class="icon-adjust">&lt;/i&gt; 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class="icon-desktop"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class="icon-fullscreen"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</i></i></p><h3 id="8-阅读模式"><a href="#8-阅读模式" class="headerlink" title="8. 阅读模式"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class="icon-desktop"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p><h3 id="9-标签、分类和搜索"><a href="#9-标签、分类和搜索" class="headerlink" title="9. 标签、分类和搜索"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p><p>标签： 未分类</p><p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p><p><img src="https://www.zybuluo.com/static/img/file-list.png" alt="file-list"></p><h3 id="10-文稿发布和分享"><a href="#10-文稿发布和分享" class="headerlink" title="10. 文稿发布和分享"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p><hr><p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p><p>作者 <a href="http://weibo.com/ghosert" target="_blank" rel="noopener">@ghosert</a><br>2016 年 07月 07日    </p><blockquote id="fn_LaTeX"><sup>LaTeX</sup>. 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">MathJax</a> 参考更多使用方法。<a href="#reffn_LaTeX" title="Jump back to footnote [LaTeX] in the text."> &#8617;</a></blockquote><blockquote id="fn_code"><sup>code</sup>. 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。<a href="#reffn_code" title="Jump back to footnote [code] in the text."> &#8617;</a></blockquote>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>CV</title>
      <link href="/aboutMe/index.html"/>
      <url>/aboutMe/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="Eajack-Lau"><a href="#Eajack-Lau" class="headerlink" title="Eajack Lau"></a>Eajack Lau</h1><p><em>updated on 2019/9/5</em></p><p><a href="https://eajack.github.io/aboutMe_zh/">中文版本</a></p><h2 id="Contacts"><a href="#Contacts" class="headerlink" title="Contacts"></a>Contacts</h2><ul><li>Email: eajacklau@163.com</li><li>Personal Website: <a href="https://eajack.github.io/">https://eajack.github.io/</a></li></ul><h2 id="Education"><a href="#Education" class="headerlink" title="Education"></a>Education</h2><ul><li><p>Sep. 2015-June 2019</p><blockquote><ul><li>College: Jinan University (JNU), China</li><li>Major: Electronic Information Science and Technology, School of Intelligent Systems Science and Engineering</li><li>Major courses included: C Programming Language, Signals and Systems,Digital Image Processing, Digital Signal Processing</li></ul></blockquote></li><li><p>Sep. 2019-Present</p><blockquote><ul><li>College (postgraduate recommendation): Huazhong University of Science and Technology (HUST), China</li><li>Major: Computer Science &amp; Technology, School of Computer Science &amp; Technology</li></ul></blockquote></li></ul><h2 id="Honors"><a href="#Honors" class="headerlink" title="Honors"></a>Honors</h2><ul><li>Jan. 2018-Dec. 2018<blockquote><ul><li><strong>“National Scholarship”</strong> in the 2017-2018 academic year</li><li><strong>“Excellent Student”</strong> in the 2017-2018 academic year</li><li><strong>Meritorious Winner (international first prize)</strong> in 2018 Mathematical Contest in Modeling (MCM/ICM 2018)</li><li><strong>“Best Project Award”</strong> in “Win with Innovation” Jinan University Innovation Competition (the 3rd Issue in 11th Season)</li></ul></blockquote></li></ul><ul><li><p>Jan. 2017-Dec. 2017</p><blockquote><ul><li><strong>National second prize &amp; Provincial first prize</strong> in 2017 China Undergraduate Mathematical Contest in Modeling (CUMCM 2017)</li><li><strong>Honorable Mention (international second prize)</strong> in 2017 Mathematical Contest in Modeling (MCM/ICM 2017)</li><li><strong>National third prize</strong> in CCSE Cup 2017, National University Students Electrical Math Modeling Competition</li><li>National Encouragement Scholarship in the 2016-2017 academic year</li><li>Excellent League Member of Jinan University in the 2016-2017 academic year</li></ul></blockquote></li><li><p>Jan. 2016-Dec. 2016</p><blockquote><ul><li><strong>Provincial second prize</strong> in 2016 China Undergraduate Mathematical Contest in Modeling (CUMCM 2016)</li><li>National Encouragement Scholarship in the 2015-2016 academic year</li><li>Excellent League Member of Jinan University in the 2015-2016 academic year</li></ul></blockquote></li></ul><h2 id="Project-Experience"><a href="#Project-Experience" class="headerlink" title="Project Experience"></a>Project Experience</h2><p><strong>Graduation Design：Sentiment Analysis on User Reviews Based on Natural Language Processing（Multi-label &amp; Multi-classification Text Classification problem，2018.11 ~ 2019.4）</strong></p><p> 1.What I do</p><blockquote><ul><li>Project idea source:  “Fine-grained User Reviews Sentiment Analysis” competition in “AI Challenger 2018” </li><li>Preliminary work：Literature research in the field of sentiment analysis in NLP，MeiTuan reviews crawler（about 2.3 million），text preprocessing on million-level text data set</li><li>ML scheme：(1) TF-IDF + SVM/Multinomial Logistic Regression/Naive Bayes；(2) Extracting<br>algorithm based on Pos Tagging Rules. Programming environment：Python3.5, sklearn, numpy etc..</li><li>DL scheme: (1) baseline：FastText；(2) Text-CNN-Based models. Programming environment: Python3.5, TensorFlow, sklearn etc.. Tricks: (1) word embedding layer: Word2vec/GloVe/FastText/ELMo (2)Learning rate exponential attenuation strategy/L2 Regularization/Dropout (3)Hyperparameter fine-tune(batch_size etc.) </li></ul></blockquote><h5 id="Apr-2018-Apr-2019-Foreground-extraction-algorithm-based-on-face-detection-and-image-segmentation-leader"><a href="#Apr-2018-Apr-2019-Foreground-extraction-algorithm-based-on-face-detection-and-image-segmentation-leader" class="headerlink" title="Apr. 2018-Apr. 2019(Foreground extraction algorithm based on face detection and image segmentation (leader))"></a>Apr. 2018-Apr. 2019(Foreground extraction algorithm based on face detection and image segmentation (leader))</h5><p>1.Project outcome</p><blockquote><ul><li>Rated as <strong>2018 National Training Program of Innovation for Undergraduates</strong></li></ul></blockquote><p> 2.What I do</p><blockquote><ul><li>complete the C/C++ testing project on GrabCut algorithm(image matting algorithm) based on OpenCV</li><li>Preliminary study on deep matting (especially on <a href="http://xiaoyongshen.me/webpage_portrait/index.html" target="_blank" rel="noopener"><em>Automatic Portrait Segmentation for Image Stylization</em></a> &amp; <a href="http://www.cse.cuhk.edu.hk/leojia/projects/automatting/index.html" target="_blank" rel="noopener"><em>Deep Automatic Portrait Matting</em></a>)</li><li>Literature survey on traditional matting algorithm &amp; deep matting (based on Deep Learning)</li></ul></blockquote><h5 id="Apr-2018-Apr-2019-Algorithm-research-on-bus-smart-travel-plan-participant"><a href="#Apr-2018-Apr-2019-Algorithm-research-on-bus-smart-travel-plan-participant" class="headerlink" title="Apr. 2018-Apr. 2019(Algorithm research on bus smart travel plan (participant))"></a>Apr. 2018-Apr. 2019(Algorithm research on bus smart travel plan (participant))</h5><p>1.Project outcome</p><blockquote><ul><li>Rated as <strong>2018 National Training Program of Innovation for Undergraduates</strong></li></ul></blockquote><p>2.What I do</p><blockquote><ul><li>Complete the C/C++ project about  people counting of bus video</li></ul></blockquote><h5 id="Apr-2018-Sep-2018-Abnormal-behavior-detection-in-trolley-compartment-participant"><a href="#Apr-2018-Sep-2018-Abnormal-behavior-detection-in-trolley-compartment-participant" class="headerlink" title="Apr. 2018-Sep. 2018(Abnormal behavior detection in trolley compartment (participant))"></a>Apr. 2018-Sep. 2018(Abnormal behavior detection in trolley compartment (participant))</h5><p>1.Project outcome</p><blockquote><ul><li><strong> the project of Institute of Internet of Things and Logistics Engineering of Jinan University</strong></li></ul></blockquote><p>2.What I do</p><blockquote><ul><li>complete the background modeling algorithm(codebook algorithm) with C/C++</li></ul></blockquote><h5 id="July-2017-Apr-2018-The-design-of-intelligent-trash-bin-with-image-processing-technology-leader"><a href="#July-2017-Apr-2018-The-design-of-intelligent-trash-bin-with-image-processing-technology-leader" class="headerlink" title="July 2017-Apr. 2018(The design of intelligent trash bin with image processing technology (leader))"></a>July 2017-Apr. 2018(The design of intelligent trash bin with image processing technology (leader))</h5><p>1.Project outcome</p><blockquote><ul><li>Rated as <strong>2017 National Training Program of Innovation for Undergraduates</strong></li><li><strong>“Best Project Award”</strong> in “Win with Innovation” Jinan University Innovation Competition (the 3rd Issue in 11th Season)</li></ul></blockquote><p>2.What I do</p><blockquote><ul><li>Implemented trash image recognition and classification algorithm with C/C++ programming language on OpenCV platform</li><li>Accomplished the testing algorithm with Python on Raspberry Pi board</li><li>Designed trash bin 3D models on the SolidWorks software platform</li></ul></blockquote><h5 id="July-2016-Apr-2017-Intelligent-transportation-project-based-on-video-image-processing-participant"><a href="#July-2016-Apr-2017-Intelligent-transportation-project-based-on-video-image-processing-participant" class="headerlink" title="July 2016-Apr. 2017(Intelligent transportation project based on video image processing (participant))"></a>July 2016-Apr. 2017(Intelligent transportation project based on video image processing (participant))</h5><p>1.Project outcome</p><blockquote><ul><li>Rated as <strong>2016 Provincial Training Program of Innovation for Undergraduates</strong></li></ul></blockquote><p>2.What I do</p><blockquote><ul><li>Completed the design of traffic flow video background extraction algorithm</li></ul></blockquote><h2 id="Organization-experience"><a href="#Organization-experience" class="headerlink" title="Organization experience"></a>Organization experience</h2><ul><li>Sep. 2016-Sep. 2018(<strong>Mathematical Modeling Innovation Practice Base of Jinan University</strong>)<blockquote><ul><li>Work as assistant &amp; minister in academic department</li></ul></blockquote></li></ul><h2 id="Professional-Skills"><a href="#Professional-Skills" class="headerlink" title="Professional Skills"></a>Professional Skills</h2><blockquote><ul><li>Familiar with MATLAB &amp; Python, as well as C/C++</li><li>Interested in <strong>Computer Vision(CV), Natural Language Processing(NLP fresher) &amp; Machine Learning Field</strong></li><li>Software project experience in NLP/CV</li><li>Extensive experience in team work and working on a regular schedule</li><li>English ability: <strong>CET4(573), CET6(502)</strong>; Skillful English reading ability</li></ul></blockquote>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>CV</title>
      <link href="/aboutMe_zh/index.html"/>
      <url>/aboutMe_zh/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="Eajack-Lau"><a href="#Eajack-Lau" class="headerlink" title="Eajack Lau"></a>Eajack Lau</h1><p><em>更新于 2019/9/5</em></p><p><a href="https://eajack.github.io/aboutMe/">English Version</a></p><h2 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h2><ul><li>Email: eajacklau@163.com</li><li>个人博客: <a href="https://eajack.github.io/">https://eajack.github.io/</a></li></ul><h2 id="教育背景"><a href="#教育背景" class="headerlink" title="教育背景"></a>教育背景</h2><ul><li><p>2015.9 ~ 2019.6</p><blockquote><ul><li>学校: 暨南大学</li><li>专业: 电子信息科学与技术，智能科学与工程学院</li><li>主要专业课程: 《C语言编程与设计》、《信号与系统》、《数字图像处理》、《数字信号处理》</li></ul></blockquote></li><li><p>2019.9 至今</p><blockquote><ul><li>学校（保研）: 华中科技大学</li><li>专业: 计算机技术，计算机科学与技术学院</li></ul></blockquote></li></ul><h2 id="荣誉称号"><a href="#荣誉称号" class="headerlink" title="荣誉称号"></a>荣誉称号</h2><ul><li>2018.1 ~ 2018.12<blockquote><ul><li><strong>国家奖学金</strong></li><li><strong>优秀学生称号</strong></li><li><strong>Meritorious Winner</strong>（2018年美国大学生数学建模竞赛）</li><li><strong>“最佳项目奖”</strong>（第11季第3期暨南大学“赢在创新”比赛）</li></ul></blockquote></li></ul><ul><li><p>2017.1 ~ 2017.12</p><blockquote><ul><li><strong>国家级二等奖</strong>（2017年全国大学生数学建模竞赛）</li><li><strong>Honorable Mention </strong>（2017年美国大学生数学建模竞赛）</li><li><strong>国家级三等奖</strong>（2017年“电工杯”）</li><li>国家励志奖学金</li><li>“优秀共青团员称号”</li></ul></blockquote></li><li><p>2016.1 ~ 2016.12</p><blockquote><ul><li><strong>省二等奖</strong>（2016年全国大学生数学建模竞赛）</li><li>国家励志奖学金</li><li>“优秀共青团员称号”</li></ul></blockquote></li></ul><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><p><strong>毕设项目：基于自然语言处理的用户评论情感分析（文本多标签多分类问题，2018.11 ~ 2019.4）</strong></p><p> 1.负责工作</p><blockquote><ul><li>项目 idea来源：基于本人参加的， “AI Challenger 全球 AI 挑战赛”其中的“细粒度用户评论情感分析” 赛道的相关工作（网页链接：<a href="https://challenger.ai/competition/fsauor2018）" target="_blank" rel="noopener">https://challenger.ai/competition/fsauor2018）</a> </li><li>前期工作：NLP 情感分析领域文献调研，美团评论爬虫（约 230万条） ，百万级的文本数据集预处理</li><li>传统机器学习 ML 方案：(1) TF-IDF + SVM/多项逻辑回归/朴素贝叶斯；(2) 基于词性模板。编程环境：Python3.5、sklearn、numpy等第三方库</li><li>深度学习 DL 方案：(1) baseline：FastText 官方模型；(2) 基于 Text-CNN 文本多标签多分类模型。编程环境：Python3.5、TensorFlow 框架、sklearn 等第三方库。技术细节：(1) word embedding 层：Word2vec/GloVe/FastText/ELMo (2) 学习率指数衰减策略、L2 正则化/Dropout (3)batch_size 等超参数调整工作</li></ul></blockquote><p><strong>基于人脸检测和图像分割的前景提取算法（负责人，2018.4 ~ 2019.4）</strong></p><p>1.项目成果</p><blockquote><ul><li>2018年国家级大学生创新训练项目</li></ul></blockquote><p> 2.负责工作</p><blockquote><ul><li>基于OpenCV平台的GrabCut算法的C/C++测试工程项目</li><li>对深度抠图算法（deep matting）的初步了解（特别是这2篇论文：<a href="http://xiaoyongshen.me/webpage_portrait/index.html" target="_blank" rel="noopener"><em>Automatic Portrait Segmentation for Image Stylization</em></a> &amp; <a href="http://www.cse.cuhk.edu.hk/leojia/projects/automatting/index.html" target="_blank" rel="noopener"><em>Deep Automatic Portrait Matting</em></a>)</li><li>对传统抠图算法 &amp; 深度学习抠图算法 的文献调研</li></ul></blockquote><p><strong>公交智慧出行方案的算法研究（参与人，2018.4 ~ 2019.4）</strong></p><p>1.项目成果</p><blockquote><ul><li>2018年国家级大学生创新训练项目</li></ul></blockquote><p>2.负责工作</p><blockquote><ul><li>基于OpenCV平台的公交车视频人头计数的算法C/C++代码实现</li></ul></blockquote><p><strong>车厢异常行为检测（参与人，2018.4 ~ 2018.9）</strong></p><p>1.项目成果</p><blockquote><ul><li>暨南大学物联网与物流工程研究院项目</li></ul></blockquote><p>2.负责工作</p><blockquote><ul><li>基于OpenCV平台的码本法人数统计C/C++代码的实现</li></ul></blockquote><p><strong>基于运动检测与图像识别技术的智能化自动分类垃圾桶（负责人，2017.4 ~ 2018.4）</strong></p><p>1.项目成果</p><blockquote><ul><li>2017年国家级大学生创新训练项目</li><li><strong>“最佳项目奖”</strong>（第11季第3期暨南大学“赢在创新”比赛）</li></ul></blockquote><p>2.负责工作</p><blockquote><ul><li>协助工作：协助项目成员完成基于SolidWorks软件的垃圾桶 3D模型初步设计，以及基于OpenCV平台的运动检测算法的 C/C++实现</li><li>硬件平台：垃圾桶框架模型，以及以 Raspberry Pi开发板为核心的硬件系统</li><li>软件算法：基于 TensorFlow框架，垃圾图像分类算法的 Python 实现；基于 OpenCV 平台的图像识别与 分类算法 C/C++实现，主要包括 SURF特征点检测算法、BoW词袋模型以及 SVM分类算法 </li></ul></blockquote><p><strong>基于视频图像处理的智能交通灯动态控制研究（参与人，2016.4 ~ 2017.4）</strong></p><p>1.项目成果</p><blockquote><ul><li>2016年广东省大学生创新训练项目</li></ul></blockquote><p>2.负责工作</p><blockquote><ul><li>交通流视频背景建模的MATLAB代码实现</li></ul></blockquote><h2 id="组织经历"><a href="#组织经历" class="headerlink" title="组织经历"></a>组织经历</h2><ul><li>2016.9 ~ 2018.9 (<strong>暨南大学数学建模创新实践基地 </strong>)<blockquote><ul><li>学术部干事&amp;部长</li></ul></blockquote></li></ul><h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><blockquote><ul><li>熟悉使用 MATLAB和 Python语言，较为熟悉 C/C++语言</li><li>对<strong>计算机视觉（CV）、自然语言处理（NLP入门者）等机器学习相关领域</strong>感兴趣</li><li>拥有较为丰富的 NLP/CV领域的 ML/DL相关项目经验</li><li>擅于团队合作，习惯于规律的工作安排</li><li>英语水平: <strong>CET4(573), CET6(502)</strong>; 良好的英语阅读能力</li></ul></blockquote>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>gallery</title>
      <link href="/gallery/index.html"/>
      <url>/gallery/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>timeline</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
